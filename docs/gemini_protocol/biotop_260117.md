## USER üßë‚Äçüíª

This is the Gemini CLI. We are setting up the context for our chat.
Today's date is Samstag, 17. Januar 2026 (formatted according to the user's locale).
My operating system is: win32
The project's temporary directory is: C:\Users\Fried\.gemini\tmp\e28ee0484ec4cae024692ec5e73476d86df6b49984f53c9f0519d586dbfc0130
I'm currently working in the directory: C:\Users\Fried\OneDrive\Studium\Inf\INF-Einf-B\GameOfLife
Here is the folder structure of the current working directories:

Showing up to 200 items (files + folders). Folders or files indicated with ... contain more items not shown, were ignored, or the display limit (200 items) was reached.

C:\Users\Fried\OneDrive\Studium\Inf\INF-Einf-B\GameOfLife\
‚îú‚îÄ‚îÄ‚îÄ.gitignore
‚îú‚îÄ‚îÄ‚îÄconfig.xlaunch
‚îú‚îÄ‚îÄ‚îÄdocker-compose.yml
‚îú‚îÄ‚îÄ‚îÄDockerfile
‚îú‚îÄ‚îÄ‚îÄfile_io.c
‚îú‚îÄ‚îÄ‚îÄfile_io.h
‚îú‚îÄ‚îÄ‚îÄgame_logic.c
‚îú‚îÄ‚îÄ‚îÄgame_logic.h
‚îú‚îÄ‚îÄ‚îÄgenerate_setup_2von3.py
‚îú‚îÄ‚îÄ‚îÄgenerate_setup.py
‚îú‚îÄ‚îÄ‚îÄgui.c
‚îú‚îÄ‚îÄ‚îÄgui.h
‚îú‚îÄ‚îÄ‚îÄmain.c
‚îú‚îÄ‚îÄ‚îÄproject-logfile.md
‚îú‚îÄ‚îÄ‚îÄREADME.md
‚îú‚îÄ‚îÄ‚îÄsetup_2GGG_gatter.bio
‚îú‚îÄ‚îÄ‚îÄsetup_bio_readme.md
‚îú‚îÄ‚îÄ‚îÄsetup_calculator.bio
‚îú‚îÄ‚îÄ‚îÄsetup_chess.bio
‚îú‚îÄ‚îÄ‚îÄsetup_erzeugt_GGG.bio
‚îú‚îÄ‚îÄ‚îÄsetup_rot_gewinnt_erstaunlicherweise.bio
‚îú‚îÄ‚îÄ‚îÄsetup.bio
‚îú‚îÄ‚îÄ‚îÄtest_logic.c
‚îú‚îÄ‚îÄ‚îÄ.git\...
‚îú‚îÄ‚îÄ‚îÄbiotope_results\
‚îú‚îÄ‚îÄ‚îÄdocs\
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄADR-0000-template.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄADR-0001-competitive-biotope-mode.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄADR-0002-biotope-ui-system.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄADR-0003-integrated-simulation-protocol.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_SPEC-0000-template.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_SPEC-0001-competitive-biotope-mode.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_SPEC-0002-biotope-ui-system.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_SPEC-0003-integrated-simulation-protocol.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TASKS-0000-template.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TASKS-0001-competitive-biotope-mode.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TASKS-0002-biotope-ui-system.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TASKS-0003-integrated-simulation-protocol.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TECH_DESIGN-0000-template.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TECH_DESIGN-0001-competitive-biotope-mode.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TECH_DESIGN-0002-biotope-ui-system.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄDEV_TECH_DESIGN-0003-integrated-simulation-protocol.md
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄPERFORMANCE_REPORT_UI.md
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄgemini_protocol\
‚îÇ       ‚îú‚îÄ‚îÄ‚îÄbiotop.md
‚îÇ       ‚îú‚îÄ‚îÄ‚îÄbiotop1.md
‚îÇ       ‚îú‚îÄ‚îÄ‚îÄbiotop2.md
‚îÇ       ‚îú‚îÄ‚îÄ‚îÄbiotop3.json
‚îÇ       ‚îú‚îÄ‚îÄ‚îÄbiotop3.md
‚îÇ       ‚îú‚îÄ‚îÄ‚îÄbiotop4.json
‚îÇ       ‚îî‚îÄ‚îÄ‚îÄbiotop4.md
‚îî‚îÄ‚îÄ‚îÄutilities\

Reminder: Do not return an empty response when a tool call is required.

My setup is complete. I will provide my first command in the next turn.

---

## USER üßë‚Äçüíª

Feature implementieren

Bitte mache dich mit den Inhalten der folgenden Dokumente vertraut. Sie liefern die grundlegenden Informationen zu dem anspruchsvollen Projekt, an dem wir gemeinsam arbeiten werden.
Hintergrundinformationen findest du in @docs/ADR-0003-integrated-simulation-protocol.md 
Die f√ºr die Umsetzung verbindlichen Dokumente:
 @docs/DEV_SPEC-0003-integrated-simulation-protocol.md @docs/DEV_TECH_DESIGN-0003-integrated-simulation-protocol.md 
Bitte beginne mit der Implementierung.
Folge dabei der in 
 @docs/DEV_TASKS-0003-integrated-simulation-protocol.md 
vorgegebenen Aufgabenliste.
Erfrage ggf. fehlende Informationen.
Beachte, dass die App in einem Docker-Container l√§uft.
Bitte f√ºhre relevante Funktionstests interaktiv durch. Das bedeutet: Du weist den Anwender an, Aktionen durchzuf√ºhren (z. B.: bash-Anweisungen, npm run build, docker-compose, ...). Der Anwender berichtet das Ergebnis.
Berichte jetzt umfassend √ºber den aktuellen Stand der Entwicklung.
--- Content from referenced files ---
Content from @docs/ADR-0003-integrated-simulation-protocol.md:
### **ADR-0003: Integrated Simulation Protocol and Replay System**

**Status:** Proposed

**Date:** 2026-01-17

#### **1. Context and Problem Statement**

The "Biotope - Game of Life" application currently allows users to configure and run competitive simulations. However, the system lacks a comprehensive mechanism to document and reproduce these simulations. 

Currently:
- The **initial state** (grid configuration) is mutable and is overwritten in memory as the simulation progresses. Unless a user manually saves before running, the starting setup is lost.
- The **simulation parameters** (e.g., `max_rounds`, `delay_ms`) are not persisted in the current `.bio` file format.
- **Results logging** is limited to a Markdown summary at the end, which is insufficient for re-running the exact same scenario.
- There is no **integrated user interface** to browse, select, and load previous simulation protocols; users would have to rely on external file management.

We need a solution that ensures every simulation run is fully documented (protocolled) and can be easily reloaded by the user to verify results or replay interesting scenarios.

#### **2. Decision**

We will implement an **Integrated Simulation Protocol System** ("Solution 1") with the following core components:

1.  **Extended Protocol Format:** 
    We will extend the existing file I/O logic to support a comprehensive protocol format (likely preserving the `.bio` extension or using a new `.log` extension). This format will store:
    - **Header:** Configuration metadata (`max_rounds`, `delay_ms`, `max_population`, timestamp).
    - **Body:** The complete initial grid state (RLE or coordinate list).
    - **Footer (Optional/Appended):** Simulation results (Winner, final scores), appended if the simulation completes successfully.

2.  **"Save-on-Start" Strategy:**
    To ensure robustness, the application will automatically serialize the complete *initial* state (Grid + Config) to a file in the `biotope_results/` directory immediately upon transitioning from `STATE_EDIT` to `STATE_RUNNING`. This guarantees that a protocol exists even if the application crashes during execution.

3.  **In-App File Browser (UI):**
    A new UI state (`STATE_LOAD`) will be implemented to replace the generic "Load" function. This custom interface will:
    - Scan the `biotope_results/` directory.
    - Allow the user to navigate through available protocol files using keyboard input (e.g., Arrow Keys).
    - Display metadata previews (Date, Config) for the selected file.
    - Load the selected file into the `STATE_EDIT` mode for inspection or replay.

#### **3. Consequences of the Decision**

**Positive Consequences (Advantages):**
- **Complete Reproducibility:** Users can exactly recreate any past simulation run, satisfying the core requirement for a "protocol".
- **Robustness:** By saving at the start, data is preserved even in the event of a runtime crash or power failure.
- **Usability:** The integrated browser eliminates the need for users to interact with the OS file system to swap "save files".
- **Portability:** A single file contains everything needed to define a simulation run, making it easy to share specific scenarios between users.

**Negative Consequences (Disadvantages):**
- **Implementation Complexity:** Implementing a directory scanner and a scrollable list UI in Raylib (immediate mode drawing) is more involved than using standard OS dialogs.
- **Storage Footprint:** Automatically saving every run will generate a large number of files over time, potentially requiring a future "cleanup" feature.
- **Format Migration:** The loader must be written defensively to handle legacy `.bio` files that lack the new protocol headers.

#### **4. Alternatives Considered**

**Alternative 2: Snapshot & Memory (Save-at-End)**
- *Concept:* Keep a copy of the initial world in RAM and write the protocol file only after the simulation finishes (`STATE_GAME_OVER`).
- *Pros:* Reduces disk I/O; avoids creating files for aborted/mistaken runs.
- *Cons:* **Critical failure point:** If the application crashes during the simulation, the initial configuration is lost forever. This was deemed unacceptable for a "protocol" system.

**Alternative 3: JSON Manifest (Separated Data)**
- *Concept:* Use a central `manifest.json` to track runs and separate grid data (`.bio`) from metadata (`.json`).
- *Pros:* Cleaner data structure; standard format for metadata.
- *Cons:* Introduces a dependency on a JSON parser (e.g., `cJSON`) or complex string parsing in C. Given the project's constraint to minimize external dependencies and maintain simplicity, adding a JSON handling layer was rejected in favor of a custom, line-based text format.
Content from @docs/DEV_SPEC-0003-integrated-simulation-protocol.md:
# Requirements Analysis & Specification: Integrated Simulation Protocol and Replay System

This document details the requirements for the "Integrated Simulation Protocol and Replay System", as described in **ADR-0003**.

---

### 1. Detailed Requirements Specification

The objective is to transform the existing save/load functionality into a robust auditing and replay system. This involves changes to the data persistence layer, the simulation lifecycle, and the user interface.

#### 1.1 Extended Protocol Format
The existing `.bio` file format must be extended to capture the full context of a simulation.
*   **Legacy Format:** `Rows Cols MaxPop` (Header) + List of Cells.
*   **New Protocol Format:**
    *   **Header:** Must include `Rows`, `Cols`, `MaxPop`, `MaxRounds`, `DelayMS`, and a `Timestamp`.
    *   **Body:** List of active cells (Team Red/Blue).
    *   **Footer (Optional):** If a simulation completes, results (Winner, Final Population Counts) should be appended to the file.
    *   **Compatibility:** The loader must distinguish between legacy files (3 integer header) and protocol files (extended header) to prevent crashes.

#### 1.2 "Save-on-Start" Automation
*   **Trigger:** Transition from `STATE_EDIT` to `STATE_RUNNING` (when user presses `ENTER`).
*   **Action:** Automatically generate a filename using the pattern `biotope_results/run_YYYYMMDD_HHMMSS.bio`.
*   **Content:** Serialize the *current* state of the grid and the *current* configuration settings immediately before the first simulation tick.
*   **Error Handling:** If file creation fails (e.g., directory missing), the simulation should still proceed, but an error message should be displayed.

#### 1.3 In-App File Browser (UI)
A new UI state `STATE_LOAD` will replace the simple "Load" toggle.
*   **Directory Scanning:** The system must list all valid `.bio` files in the `biotope_results/` and root directories.
*   **Navigation:**
    *   **Up/Down Arrows:** Select file.
    *   **Enter:** Load selected file and transition to `STATE_EDIT`.
    *   **Esc/Q:** Return to `STATE_CONFIG` or `STATE_EDIT` without loading.
*   **Preview:** When a file is selected (highlighted), display its metadata (Date, Grid Size, Max Rounds) on the side or bottom panel before loading.
*   **Sorting:** Files should ideally be sorted by date (newest first).

---

### 2. User Stories & Acceptance Criteria

**Epic: Simulation Audit and Replayability**

*   **User Story 1: Automatic Protocol Generation**
    *   **As a** Researcher/Player,
    *   **I want** my simulation setup to be saved automatically when I start the game,
    *   **So that** I don't lose my configuration if I forget to save manually or if the program crashes.
    *   **Acceptance Criteria:**
        *   Pressing `ENTER` in Editor Mode creates a new file in `biotope_results/`.
        *   The filename contains the current timestamp.
        *   The file contains `MaxRounds`, `Delay`, and `MaxPopulation` in addition to grid dimensions.
        *   The simulation starts immediately after saving.

*   **User Story 2: Browse Protocol History**
    *   **As a** Researcher/Player,
    *   **I want** to browse a list of past simulation runs within the application,
    *   **So that** I can find a specific experiment without leaving the game window.
    *   **Acceptance Criteria:**
        *   Pressing `[L]` opens a file browser view (`STATE_LOAD`).
        *   The view lists files from the `biotope_results` folder.
        *   The user can navigate the list using keyboard arrows.
        *   The currently selected filename is visually highlighted.

*   **User Story 3: Load and Replay**
    *   **As a** Researcher/Player,
    *   **I want** to load a selected protocol file,
    *   **So that** the application restores the exact Grid, Max Rounds, and Delay settings from that run.
    *   **Acceptance Criteria:**
        *   Selecting a file and pressing `ENTER` loads the state.
        *   The application transitions to `STATE_EDIT`.
        *   Grid dimensions resize automatically if the file differs from current settings.
        *   Configuration counters (Rounds, Delay) are updated to match the file.
        *   Legacy files (old format) can still be loaded without errors (using default defaults for missing values).

---

### 3. Prioritization and Dependency Analysis

*   **Prioritization (MoSCoW Method):**
    *   **Must-Have (MVP):**
        *   Extension of `save_grid` / `load_grid` functions to handle new metadata.
        *   Automatic "Save-on-Start" logic in `gui.c`.
        *   Basic List UI in `STATE_LOAD` (rendering file names).
        *   Keyboard navigation logic for the list.
    *   **Should-Have:**
        *   Metadata preview (parsing header without loading full grid) in the UI.
        *   Sorting files by date (Newest First).
        *   Appending results (Winner) to the file end upon `STATE_GAME_OVER`.
    *   **Could-Have:**
        *   Deleting files from the UI.
        *   Sub-directory navigation.
    *   **Won't-Have (in this increment):**
        *   JSON formatting.
        *   Mouse support for file selection (Keyboard only for MVP).

*   **Dependencies:**
    1.  **File I/O Update:** The `file_io.c` module must be updated to support the new format *before* the UI can display metadata or load correctly.
    2.  **Directory Access:** Platform-specific (Windows `dirent.h` or WinAPI) logic is needed to list files.

---

### 4. Product Backlog

| ID | Epic | User Story / Task | Priority | Est. Effort |
| :-- | :--- | :--- | :--- | :--- |
| **PB-01** | Protocol | **Task:** Update `file_io.c` `save_grid` to include `max_rounds`, `delay`, `timestamp`. | High | 1h |
| **PB-02** | Protocol | **Task:** Update `file_io.c` `load_grid` to parse new header (with backward compatibility). | High | 1.5h |
| **PB-03** | Protocol | **Task:** Implement `list_files` helper function (using `dirent.h` or equivalent for Win32). | High | 1h |
| **PB-04** | Automation | **Story 1:** Integrate `save_grid` call into `STATE_EDIT` -> `STATE_RUNNING` transition. | High | 0.5h |
| **PB-05** | UI | **Task:** Create `STATE_LOAD` structure and render loop in `gui.c`. | High | 1h |
| **PB-06** | UI | **Story 2:** Implement scrolling/selection logic for file list. | High | 1.5h |
| **PB-07** | UI | **Story 3:** Connect `STATE_LOAD` selection to `load_grid` function. | High | 0.5h |
| **PB-08** | Protocol | **Task:** Append simulation results to file in `STATE_GAME_OVER`. | Medium | 0.5h |

---

### 5. Definition of Done (DoD)

A Product Backlog Item is considered "Done" when:

*   **Compilability:** The code compiles with `gcc` without errors or new warnings.
*   **Tests:**
    *   Manual verification: Saving a grid produces the expected file content.
    *   Manual verification: Loading the file restores the exact state.
    *   Manual verification: The "Save-on-Start" creates a file every time the simulation runs.
*   **Acceptance Criteria:** All ACs defined in the User Story are met.
*   **No Regressions:** Existing `.bio` files (if any) can still be loaded (backward compatibility).
*   **Code Style:** Code follows the existing indentation and naming conventions of the project (K&R style, clear variable names).
*   **Documentation:** Functions in `file_io.h` are documented with comments explaining the new format.
Content from @docs/DEV_TASKS-0003-integrated-simulation-protocol.md:
# DEV_TASKS-0003: Integrated Simulation Protocol and Replay System

This document outlines the step-by-step implementation plan for the Integrated Simulation Protocol and Replay System.

**Developer:** Please follow these steps precisely. The plan is broken into phases and small steps to allow for interruptions and ensure stability. After each "Verification" step, report the outcome. This iterative process is crucial for maintaining quality.

**Briefing Documents:**
*   [ADR-0003: Integrated Simulation Protocol](../../docs/ADR-0003-integrated-simulation-protocol.md)
*   [DEV_SPEC-0003: Integrated Simulation Protocol Spec](../../docs/DEV_SPEC-0003-integrated-simulation-protocol.md)
*   [DEV_TECH_DESIGN-0003: Technical Specification](../../docs/DEV_TECH_DESIGN-0003-integrated-simulation-protocol.md)

---

## Phase 1: File I/O Core Enhancements

*Goal: Update the file persistence layer to support the new extended protocol format (v2) while maintaining backward compatibility with existing .bio files.*

- [ ] **Step 1.1: Update `GameConfig` and Headers**
    - [ ] **Action:** In `gui.h`, ensure `GameConfig` struct is fully defined and accessible for `file_io.c`. (It is currently defined in `gui.c` but might need to be moved to `gui.h` or `game_logic.h` if `file_io.h` needs to see it, or forward declared). *Correction:* `file_io.h` already includes `gui.h`.
    - [ ] **Action:** Open `file_io.h`. Add the `ProtocolInfo` struct definition as specified in the Tech Design (Section 4.1).
    - [ ] **Action:** Update `save_grid` prototype in `file_io.h` to explicitly take `GameConfig *c` (already done in current code, just verify).
    - [ ] **Action:** Add prototypes for `list_protocol_files` and `load_protocol_metadata` to `file_io.h`.
    - [ ] **Verification (Interactive Test):**
        1.  Run `gcc -c main.c gui.c file_io.c game_logic.c` (or your build command).
        2.  **Expected Result:** Compilation succeeds. No "unknown type" errors for `ProtocolInfo`.

- [ ] **Step 1.2: Implement Extended Save Logic**
    - [ ] **Action:** In `file_io.c`, modify `save_grid`.
    - [ ] **Action:** Change the `fprintf` header writing logic. Instead of just `%d %d %d`, it should now write `2 %ld %d %d %d %d %d` (Version, Timestamp, Rows, Cols, MaxPop, MaxRounds, Delay).
    - [ ] **Action:** Use `time(NULL)` to get the current timestamp.
    - [ ] **Verification (Interactive Test):**
        1.  Compile and run the game.
        2.  Go to Editor, place some cells.
        3.  Press `S` to save to `setup.bio`.
        4.  Open `setup.bio` in a text editor.
        5.  **Expected Result:** The first line should now look like `2 1705481234 50 50 100 1000 100` (7 numbers starting with 2).

- [ ] **Step 1.3: Implement Backward-Compatible Load Logic**
    - [ ] **Action:** In `file_io.c`, modify `load_grid`.
    - [ ] **Action:** Update the `fscanf` logic to read the first line.
    - [ ] **Action:** Check the return value of `fscanf`.
        -   If it reads 3 items: It's legacy. Parse as `Rows, Cols, MaxPop`. Set `MaxRounds=1000`, `Delay=100`.
        -   If it reads 7 items (and first is 2): It's v2. Parse all fields.
    - [ ] **Action:** Ensure `GameConfig *c` is updated with the loaded values (`max_rounds`, `delay_ms`).
    - [ ] **Verification (Interactive Test):**
        1.  Create a file `legacy_test.bio` manually with content: `20 20 50
0 0 1`. *Note: The UI currently hardcodes "setup.bio" for loading.*
        2.  **Alternative Verification:** Save a new file using the game (Step 1.2). Restart game. Press `L`.
        3.  **Expected Result:** The grid loads correctly. The configuration (Rounds, Delay) matches what was saved.

## Phase 2: Directory Helper & File Listing

*Goal: Enable the application to inspect the file system and list available protocol files.*

- [ ] **Step 2.1: Implement `list_protocol_files`**
    - [ ] **Action:** In `file_io.c`, include `<dirent.h>` (or `<windows.h>` if MinGW is missing it, but try dirent first).
    - [ ] **Action:** Implement `int list_protocol_files(const char *dir_path, ProtocolInfo **out_list)`.
    - [ ] **Action:** Logic:
        1.  Open directory.
        2.  Loop through files.
        3.  Filter for `.bio` extension.
        4.  For each match:
            -   `malloc` or `realloc` the list.
            -   Store filename.
            -   Call helper `load_protocol_metadata` (stub for now) to get details.
    - [ ] **Verification (Interactive Test):**
        1.  Create a temporary `test_list.c` main file that calls `list_protocol_files(".")` and prints found names.
        2.  Run it.
        3.  **Expected Result:** It lists `setup.bio` and any other .bio files in the folder.

- [ ] **Step 2.2: Implement `load_protocol_metadata`**
    - [ ] **Action:** In `file_io.c`, implement `load_protocol_metadata`.
    - [ ] **Action:** Logic: Open file, read *only* the first line (header), parse version, rows, cols, rounds, timestamp. Close file. Return 1 on success.
    - [ ] **Verification (Interactive Test):**
        1.  Update `test_list.c` to print the metadata (Rows, Cols, Rounds) next to the filename.
        2.  **Expected Result:** Correct metadata is displayed for the v2 file created in Phase 1.

- [ ] **Step 2.3: Sorting**
    - [ ] **Action:** In `list_protocol_files`, after collecting all files, use `qsort` to sort the array of `ProtocolInfo`.
    - [ ] **Action:** Comparator: Sort by `timestamp` descending (newest first).
    - [ ] **Verification:**
        1.  Create two bio files manually with different timestamps in the header.
        2.  Run `test_list.c`.
        3.  **Expected Result:** The file with the higher timestamp appears first.

## Phase 3: GUI - Auto-Save Implementation

*Goal: Automate the creation of protocol files when the simulation starts.*

- [ ] **Step 3.1: Trigger Auto-Save**
    - [ ] **Action:** In `gui.c`, locate `STATE_EDIT`. Find the block handling `KEY_ENTER` (transition to `STATE_RUNNING`).
    - [ ] **Action:** Before changing state, construct a filename: `biotope_results/run_YYYYMMDD_HHMMSS.bio`.
    - [ ] **Action:** Ensure `biotope_results` directory exists (use `mkdir` or `CreateDirectory` wrapper in `file_io` if needed, or assume it exists/create manually for now).
    - [ ] **Action:** Call `save_grid(filename, gui_world, &config)`.
    - [ ] **Verification (Interactive Test):**
        1.  Start game.
        2.  Setup a pattern.
        3.  Press `ENTER` to run.
        4.  Check `biotope_results/` folder in Windows Explorer.
        5.  **Expected Result:** A new file `run_....bio` exists with the correct content.

## Phase 4: GUI - File Browser (The "Replay" UI)

*Goal: Replace the simple "Load" button with a full file browser.*

- [ ] **Step 4.1: Define `STATE_LOAD`**
    - [ ] **Action:** In `gui.c`, add `STATE_LOAD` to the `AppState` enum.
    - [ ] **Action:** In `gui.c`, add global (or static) variables for the file list state:
        -   `ProtocolInfo *fileList = NULL`
        -   `int fileCount = 0`
        -   `int selectedFileIndex = 0`

- [ ] **Step 4.2: Implement Transition and Loading List**
    - [ ] **Action:** In `STATE_EDIT` (or `STATE_CONFIG`), change `KEY_L` logic. Instead of calling `load_grid` immediately:
        -   Call `list_protocol_files("biotope_results", &fileList)`.
        -   Set `selectedFileIndex = 0`.
        -   Set `state = STATE_LOAD`.
    - [ ] **Verification (Interactive Test):**
        1.  Start game. Press `L`.
        2.  **Expected Result:** Screen changes (likely blank or black for now as we haven't rendered `STATE_LOAD` yet), but no crash.

- [ ] **Step 4.3: Implement Rendering for `STATE_LOAD`**
    - [ ] **Action:** In the main drawing loop (switch `state`), add `case STATE_LOAD:`
    - [ ] **Action:** Draw Title "PROTOCOL ARCHIVE".
    - [ ] **Action:** Loop through `fileList`. Draw filenames.
    - [ ] **Action:** Draw a rectangle/highlight around `fileList[selectedFileIndex]`.
    - [ ] **Action:** Draw a "Preview" box on the right side:
        -   "Date: ..." (convert timestamp to string)
        -   "Grid: WxH"
        -   "Rounds: ..."
    - [ ] **Verification (Interactive Test):**
        1.  Start game. Press `L`.
        2.  **Expected Result:** You see the list of files generated in Phase 3. The first one is highlighted.

- [ ] **Step 4.4: Implement Input for `STATE_LOAD`**
    - [ ] **Action:** In the logic loop for `STATE_LOAD`:
        -   `KEY_UP`: `selectedFileIndex--` (clamp to 0).
        -   `KEY_DOWN`: `selectedFileIndex++` (clamp to `fileCount-1`).
        -   `KEY_ENTER`:
            -   Call `load_grid(fileList[selectedFileIndex].filepath, ...)`
            -   Free `fileList`.
            -   Transition to `STATE_EDIT`.
        -   `KEY_Q` or `KEY_ESC`:
            -   Free `fileList`.
            -   Transition back to `STATE_EDIT`.
    - [ ] **Verification (Interactive Test):**
        1.  Start game. Run a few simulations to generate files.
        2.  Go to Editor. Press `L`.
        3.  Navigate with arrows. Observe preview changing.
        4.  Press Enter on an old run.
        5.  **Expected Result:** The game returns to Editor mode with the EXACT grid and settings from that old run.

---
**Final Verification:**
1.  Full walkthrough: Config -> Edit -> Run (Auto-save) -> Finish -> Edit -> Load (Browser) -> Select -> Replay.
2.  Ensure no memory leaks (check `fileList` freeing).
Content from @docs/DEV_TECH_DESIGN-0003-integrated-simulation-protocol.md:
# Technical Design: Integrated Simulation Protocol and Replay System

**Status:** Proposed
**Date:** 2026-01-17

## 1. Introduction

This document describes the technical architecture for the "Integrated Simulation Protocol and Replay System". The goal is to extend the current `GameOfLife` application to support comprehensive logging of simulation starts, ensure reproducibility, and provide a user-friendly interface for loading past simulations. This design addresses requirements defined in **DEV_SPEC-0003** and **ADR-0003**.

## 2. System Architecture

The feature touches upon three main areas of the application:
1.  **File I/O Layer (`file_io.c/h`)**: Enhanced to read/write the extended protocol format.
2.  **Core Game Logic (`gui.c`)**: State machine updates to handle the new `STATE_LOAD` and automatic saving triggers.
3.  **File System Interface (`main.c` / `file_io.c`)**: New functionality to list and sort directory contents.

### 2.1 Component Diagram

```mermaid
graph TD
    User[User Input] --> GUI[GUI Module (gui.c)]
    GUI -->|Transition to STATE_RUNNING| Saver[Auto-Save Logic]
    GUI -->|Transition to STATE_LOAD| Browser[File Browser UI]
    
    Saver -->|Write Protocol| FileIO[File I/O Module (file_io.c)]
    Browser -->|List Files| FileIO
    Browser -->|Read Metadata| FileIO
    Browser -->|Load Protocol| FileIO
    
    FileIO -->|Read/Write| FS[File System (.bio files)]
```

## 3. Detailed Component Design

### 3.1 Extended Protocol Format (`.bio` v2)

We will extend the `.bio` format while maintaining backwards compatibility where possible.

**Format Specification:**
The file is text-based.
*   **Line 1 (Header):** `VERSION TIMESTAMP ROWS COLS MAX_POP MAX_ROUNDS DELAY_MS`
    *   `VERSION`: Integer, e.g., `2`. (Legacy files start with `ROWS` directly).
    *   `TIMESTAMP`: Long integer (Unix epoch).
*   **Body:** Same as existing logic (Lines containing `Row Col Team`).
*   **Footer (Optional):** Key-value pairs starting with `#` for results.

**Backward Compatibility Strategy:**
*   When reading line 1, we check if the first number is small (e.g., < 10 for version) or large (e.g., > 10 for Rows, assuming sensible grid defaults).
*   *Refined approach:* The legacy format is `ROWS COLS MAX_POP` (3 integers). The new format will have 7 integers. `fscanf` return value check will determine the format version.
    *   If `fscanf` returns 3: Treat as Legacy (Version 1). Default `max_rounds=1000`, `delay=100`.
    *   If `fscanf` returns 7: Treat as Version 2.

### 3.2 File I/O Module Enhancements

**New Functions in `file_io.h`:**
```c
// Struct to hold file metadata for the browser
typedef struct {
    char filename[256];
    long timestamp;
    int rows, cols;
    int max_rounds;
} ProtocolInfo;

// Lists .bio files in a directory. Returns count.
// Caller must free the list.
int list_protocol_files(const char *dir_path, ProtocolInfo **out_list);

// Loads just the header to preview metadata
int load_protocol_metadata(const char *filename, ProtocolInfo *info);
```

**Modified Functions:**
*   `save_grid(...)`: Adds new parameters to the signature or extracts them from `GameConfig`.
*   `load_grid(...)`: Updates `GameConfig` with the new fields (`max_rounds`, `delay_ms`).

### 3.3 State Machine Changes (`gui.c`)

**New State: `STATE_LOAD`**
*   **Entry:** Call `list_protocol_files`. Sort result by timestamp (descending).
*   **Render:**
    *   Draw a scrollable list of filenames.
    *   Highlight selected index.
    *   Draw a "Preview Panel" showing details of the selected file (`ProtocolInfo`).
*   **Input:**
    *   `UP/DOWN`: Change selection index.
    *   `ENTER`: Call `load_grid` with selected file, free list, transition to `STATE_EDIT`.
    *   `ESC/Q`: Free list, transition back to `STATE_CONFIG` (or previous state).

**Automatic Save Trigger:**
*   Inside `STATE_EDIT`, when `KEY_ENTER` is pressed:
    1.  Generate filename: `biotope_results/run_<timestamp>.bio`.
    2.  Call `save_grid`.
    3.  Transition to `STATE_RUNNING`.

### 3.4 Directory Listing Implementation (Win32)

Since the environment is Windows (`win32`), we will use `<windows.h>` and `FindFirstFile` / `FindNextFile` for directory traversal if `dirent.h` is not available or reliable.
*   *Note:* MinGW usually provides `dirent.h`. We will try `dirent.h` first for portability, falling back to WinAPI if strictly necessary. Given the context, `dirent.h` is preferred for simpler code.

## 4. Data Models

### 4.1 ProtocolInfo Struct
Used for passing file data to the UI.

```c
typedef struct {
    char filename[128]; // e.g., "run_20260117_120000.bio"
    char filepath[256]; // Full relative path
    long timestamp;     // For sorting
    
    // Preview Data
    int rows;
    int cols;
    int max_rounds;
    int max_population;
} ProtocolInfo;
```

## 5. Security and Performance

### 5.1 Performance
*   **File Listing:** Listing thousands of files might be slow.
    *   *Mitigation:* We will cap the displayed list to the most recent 100 files if performance becomes an issue. For MVP, we load all.
*   **Rendering:** The file list rendering will use simple text rendering. No complex textures.

### 5.2 Security
*   **Path Traversal:** The loader should strictly prefix filenames with `biotope_results/` or `./` and not allow arbitrary paths from user input (though user input is only via selection, not text entry).
*   **Buffer Overflows:** Standard C strictness. Use `snprintf` instead of `sprintf`. Check bounds when reading filenames.

## 6. Implementation Plan

1.  **Phase 1: File I/O Core**
    *   Modify `save_grid` to write v2 header.
    *   Modify `load_grid` to detect v1 vs v2 and parse accordingly.
    
2.  **Phase 2: Directory Helper**
    *   Implement `list_protocol_files` using `dirent.h`.
    *   Implement helper to parse timestamp from filename or file stat.

3.  **Phase 3: GUI - Auto-Save**
    *   Inject saving logic into `STATE_EDIT` transition.

4.  **Phase 4: GUI - Browser**
    *   Implement `STATE_LOAD` rendering loop.
    *   Connect input handling to navigation.

## 7. API / Function Signatures (Draft)

```c
// file_io.h

// Writes extended format
int save_grid_extended(const char *filename, World *w, GameConfig *c);

// Reads extended format, handles backward compat
int load_grid_extended(const char *filename, World *w, GameConfig *c);

// Returns number of files found. 
// 'count' is updated.
// Returns array of ProtocolInfo. Caller must free.
ProtocolInfo* get_protocol_list(int *count);
```
--- End of content ---

---

## MODEL ‚ú®

Ich beginne mit der Implementierung des **Integrated Simulation Protocol System** und folge dabei strikt dem Plan in `DEV_TASKS-0003`.

**Planung Phase 1: File I/O Kern-Erweiterungen**

Zuerst werde ich die bestehenden Header-Dateien analysieren, um die notwendigen √Ñnderungen an den Datenstrukturen vorzubereiten.

### Schritt 1: Analyse der Codebasis
Ich lese `gui.h`, `file_io.h` und `file_io.c`, um den aktuellen Stand der `GameConfig` und `save_grid`/`load_grid` Funktionen zu pr√ºfen.**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "gui.h"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "file_io.h"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "file_io.c"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "read_file-1768657704288-aa33b16c280898",
  "name": "read_file",
  "response": {
    "output": "#ifndef GUI_H\n#define GUI_H\n\n#include \"game_logic.h\"\n\n// KI-Agent unterst√ºtzt\ntypedef enum {\n    STATE_CONFIG,\n    STATE_EDIT,\n    STATE_RUNNING,\n    STATE_FINISHED, // KI-Agent unterst√ºtzt: New state for viewing final grid\n    STATE_GAME_OVER\n} AppState;\n\n// KI-Agent unterst√ºtzt\ntypedef struct {\n    int rows;\n    int cols;\n    int delay_ms;\n    int max_population;\n    int max_rounds;\n    // Current counters needed for UI display\n    int current_red_pop;\n    int current_blue_pop;\n    int current_round;\n} GameConfig;\n\n// KI-Agent unterst√ºtzt\nvoid run_gui_app();\n\n#endif // GUI_H\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768657704474-564ff8cd16f",
  "name": "read_file",
  "response": {
    "output": "#ifndef FILE_IO_H\n#define FILE_IO_H\n\n#include \"game_logic.h\"\n#include \"gui.h\" // For GameConfig struct\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner);\n\n#endif // FILE_IO_H\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768657704656-c54356727ec3f",
  "name": "read_file",
  "response": {
    "output": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h> // For malloc/free\n#include \"file_io.h\"\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) {\n        printf(\"Error saving file %s\\n\", filename);\n        return 0;\n    }\n    \n    // Header: Rows Cols MaxPop\n    fprintf(f, \"%d %d %d\\n\", c->rows, c->cols, c->max_population);\n    \n    // Save live cells only: r c team\n    for(int i=0; i < w->rows * w->cols; i++) {\n        if (w->grid[i] != DEAD) {\n            int r = i / w->cols;\n            int c_idx = i % w->cols;\n            fprintf(f, \"%d %d %d\\n\", r, c_idx, w->grid[i]);\n        }\n    }\n    \n    fclose(f);\n    printf(\"Saved to %s\\n\", filename);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        printf(\"Error opening file %s\\n\", filename);\n        return 0; // Fail\n    }\n    \n    int rows, cols, max_pop;\n    if (fscanf(f, \"%d %d %d\", &rows, &cols, &max_pop) != 3) {\n        fclose(f);\n        return 0;\n    }\n    \n    // Check if loaded config matches current world size\n    // If mismatch, we resize the world and update config\n    if (rows != c->rows || cols != c->cols) {\n        printf(\"Resizing world from %dx%d to %dx%d...\\n\", c->rows, c->cols, rows, cols);\n        \n        // Free old grid\n        free(w->grid);\n        \n        // Allocate new grid\n        w->grid = (int*)malloc(rows * cols * sizeof(int));\n        if (!w->grid) {\n            printf(\"Error: Failed to allocate memory for new grid size.\\n\");\n            fclose(f);\n            return 0;\n        }\n        \n        // Update dimensions\n        w->rows = rows;\n        w->cols = cols;\n        c->rows = rows;\n        c->cols = cols;\n    }\n    \n    // Always update max_population from file (as per file format)\n    c->max_population = max_pop;\n    \n    // Clear current grid (safely, using new dimensions)\n    for(int i=0; i < w->rows * w->cols; i++) w->grid[i] = DEAD;\n    c->current_blue_pop = 0;\n    c->current_red_pop = 0;\n    \n    int r, c_idx, team;\n    while (fscanf(f, \"%d %d %d\", &r, &c_idx, &team) == 3) {\n        if (r >= 0 && r < rows && c_idx >= 0 && c_idx < cols) {\n            int idx = r * cols + c_idx;\n            w->grid[idx] = team;\n            if (team == TEAM_RED) c->current_red_pop++;\n            if (team == TEAM_BLUE) c->current_blue_pop++;\n        }\n    }\n    \n    fclose(f);\n    printf(\"Loaded from %s\\n\", filename);\n    return 1; // Success\n}\n\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) return;\n    \n    time_t now = time(NULL);\n    struct tm *t = localtime(&now);\n    \n    fprintf(f, \"# Biotope Game Results\\n\\n\");\n    fprintf(f, \"**Date:** %02d.%02d.%04d %02d:%02d\\n\\n\", \n            t->tm_mday, t->tm_mon+1, t->tm_year+1900, t->tm_hour, t->tm_min);\n            \n    fprintf(f, \"## Configuration\\n\");\n    fprintf(f, \"- Grid: %dx%d\\n\", c->rows, c->cols);\n    fprintf(f, \"- Max Population: %d\\n\", c->max_population);\n    fprintf(f, \"- Max Rounds: %d\\n\\n\", c->max_rounds);\n    \n    fprintf(f, \"## Final Score\\n\");\n    fprintf(f, \"- **Red Team:** %d\\n\", c->current_red_pop);\n    fprintf(f, \"- **Blue Team:** %d\\n\\n\", c->current_blue_pop);\n    \n    fprintf(f, \"## Result\\n\");\n    if (winner == TEAM_RED) fprintf(f, \"**Winner: RED TEAM**\\n\");\n    else if (winner == TEAM_BLUE) fprintf(f, \"**Winner: BLUE TEAM**\\n\");\n    else fprintf(f, \"**DRAW**\\n\");\n    \n    fclose(f);\n    printf(\"Stats exported to %s\\n\", filename);\n}\n"
  }
}
```

---

## MODEL ‚ú®

Ich beginne mit **Schritt 1.1: Update `GameConfig` und Headers**.
Ich werde die Struktur `ProtocolInfo` und die neuen Funktionsprototypen in `file_io.h` hinzuf√ºgen.

Danach folgt **Schritt 1.2 & 1.3: Erweiterung der Speicher- und Ladelogik**.
Ich werde `save_grid` in `file_io.c` so anpassen, dass das neue v2-Format geschrieben wird, und `load_grid` so erweitern, dass sowohl das alte als auch das neue Format gelesen werden k√∂nnen. Au√üerdem f√ºge ich leere Implementierungen (Stubs) f√ºr die neuen Funktionen hinzu, damit der Code kompiliert werden kann.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "new_string": "#include \"gui.h\" // For GameConfig struct\n\n// Struct to hold file metadata for the browser\ntypedef struct {\n    char filename[128]; // e.g., \"run_20260117_120000.bio\"\n    char filepath[256]; // Full relative path\n    long timestamp;     // For sorting\n    \n    // Preview Data\n    int rows;\n    int cols;\n    int max_rounds;\n    int max_population;\n} ProtocolInfo;\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner);\n\n// Lists .bio files in a directory. Returns count.\n// Caller must free the list.\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list);\n\n// Loads just the header to preview metadata\nint load_protocol_metadata(const char *filename, ProtocolInfo *info);\n\n#endif // FILE_IO_H",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.h",
    "old_string": "#include \"gui.h\" // For GameConfig struct\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner);\n\n#endif // FILE_IO_H",
    "instruction": "Add ProtocolInfo struct and new function prototypes for list_protocol_files and load_protocol_metadata."
  }
}
```**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "instruction": "Update save_grid to use v2 format and load_grid to support both legacy and v2 formats. Also add stubs for list_protocol_files and load_protocol_metadata.",
    "old_string": "// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) {\n        printf(\"Error saving file %s\\n\", filename);\n        return 0;\n    }\n    \n    // Header: Rows Cols MaxPop\n    fprintf(f, \"%d %d %d\\n\", c->rows, c->cols, c->max_population);\n    \n    // Save live cells only: r c team\n    for(int i=0; i < w->rows * w->cols; i++) {\n        if (w->grid[i] != DEAD) {\n            int r = i / w->cols;\n            int c_idx = i % w->cols;\n            fprintf(f, \"%d %d %d\\n\", r, c_idx, w->grid[i]);\n        }\n    }\n    \n    fclose(f);\n    printf(\"Saved to %s\\n\", filename);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        printf(\"Error opening file %s\\n\", filename);\n        return 0; // Fail\n    }\n    \n    int rows, cols, max_pop;\n    if (fscanf(f, \"%d %d %d\", &rows, &cols, &max_pop) != 3) {\n        fclose(f);\n        return 0;\n    }\n    \n    // Check if loaded config matches current world size\n    // If mismatch, we resize the world and update config\n    if (rows != c->rows || cols != c->cols) {\n        printf(\"Resizing world from %dx%d to %dx%d...\\n\", c->rows, c->cols, rows, cols);\n        \n        // Free old grid\n        free(w->grid);\n        \n        // Allocate new grid\n        w->grid = (int*)malloc(rows * cols * sizeof(int));\n        if (!w->grid) {\n            printf(\"Error: Failed to allocate memory for new grid size.\\n\");\n            fclose(f);\n            return 0;\n        }\n        \n        // Update dimensions\n        w->rows = rows;\n        w->cols = cols;\n        c->rows = rows;\n        c->cols = cols;\n    }\n    \n    // Always update max_population from file (as per file format)\n    c->max_population = max_pop;\n    \n    // Clear current grid (safely, using new dimensions)\n    for(int i=0; i < w->rows * w->cols; i++) w->grid[i] = DEAD;\n    c->current_blue_pop = 0;\n    c->current_red_pop = 0;\n    \n    int r, c_idx, team;\n    while (fscanf(f, \"%d %d %d\", &r, &c_idx, &team) == 3) {\n        if (r >= 0 && r < rows && c_idx >= 0 && c_idx < cols) {\n            int idx = r * cols + c_idx;\n            w->grid[idx] = team;\n            if (team == TEAM_RED) c->current_red_pop++;\n            if (team == TEAM_BLUE) c->current_blue_pop++;\n        }\n    }\n    \n    fclose(f);\n    printf(\"Loaded from %s\\n\", filename);\n    return 1; // Success\n}",
    "new_string": "// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) {\n        printf(\"Error saving file %s\\n\", filename);\n        return 0;\n    }\n    \n    // v2 Header: Version Timestamp Rows Cols MaxPop MaxRounds Delay\n    // Version 2\n    long timestamp = (long)time(NULL);\n    fprintf(f, \"2 %ld %d %d %d %d %d\\n\", \n            timestamp, \n            c->rows, c->cols, \n            c->max_population, \n            c->max_rounds, \n            c->delay_ms);\n    \n    // Save live cells only: r c team\n    for(int i=0; i < w->rows * w->cols; i++) {\n        if (w->grid[i] != DEAD) {\n            int r = i / w->cols;\n            int c_idx = i % w->cols;\n            fprintf(f, \"%d %d %d\\n\", r, c_idx, w->grid[i]);\n        }\n    }\n    \n    fclose(f);\n    printf(\"Saved to %s\\n\", filename);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        printf(\"Error opening file %s\\n\", filename);\n        return 0; // Fail\n    }\n    \n    int rows, cols, max_pop;\n    int max_rounds = 1000; // Default legacy\n    int delay_ms = 100;    // Default legacy\n    long timestamp = 0;\n    int version = 1;\n\n    // Try reading first line as 7 items (v2) or 3 items (v1)\n    // We read the first integer to decide potential version\n    // But standard fscanf is tricky if we don't know the format.\n    // However, v2 starts with '2', which is the version.\n    // Legacy starts with Rows (likely > 10).\n    \n    // Let's read the first line into a buffer to be safe, or just try parsing.\n    // Given simplicity, we can try to read 7 items.\n    // If it fails, we rewind and read 3.\n    \n    // Better strategy: Read all 7. Check return value.\n    int v_check, t_check, r_check, c_check, mp_check, mr_check, d_check;\n    // We can't easily peek. Let's assume standard formatting.\n    // Legacy: \"%d %d %d\" -> Rows Cols MaxPop\n    // v2:     \"2 %ld %d %d %d %d %d\" -> Ver Time Rows Cols MaxPop Rounds Delay\n    \n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n    \n    // Try parsing as v2\n    int items = sscanf(line, \"%d %ld %d %d %d %d %d\", \n                       &version, &timestamp, &rows, &cols, &max_pop, &max_rounds, &delay_ms);\n                       \n    if (items == 7 && version == 2) {\n        // It is v2, values are set.\n        printf(\"Detected Protocol v2. Timestamp: %ld\\n\", timestamp);\n    } else {\n        // Fallback to legacy v1\n        // Parse the same line again\n        items = sscanf(line, \"%d %d %d\", &rows, &cols, &max_pop);\n        if (items == 3) {\n            version = 1;\n            // Defaults already set above\n            printf(\"Detected Legacy Format (v1).\\n\");\n        } else {\n            printf(\"Error: Unknown file format.\\n\");\n            fclose(f);\n            return 0;\n        }\n    }\n    \n    // Check if loaded config matches current world size\n    // If mismatch, we resize the world and update config\n    if (rows != c->rows || cols != c->cols) {\n        printf(\"Resizing world from %dx%d to %dx%d...\\n\", c->rows, c->cols, rows, cols);\n        \n        // Free old grid\n        free(w->grid);\n        \n        // Allocate new grid\n        w->grid = (int*)malloc(rows * cols * sizeof(int));\n        if (!w->grid) {\n            printf(\"Error: Failed to allocate memory for new grid size.\\n\");\n            fclose(f);\n            return 0;\n        }\n        \n        // Update dimensions\n        w->rows = rows;\n        w->cols = cols;\n        c->rows = rows;\n        c->cols = cols;\n    }\n    \n    // Update config from file\n    c->max_population = max_pop;\n    c->max_rounds = max_rounds;\n    c->delay_ms = delay_ms;\n    \n    // Clear current grid (safely, using new dimensions)\n    for(int i=0; i < w->rows * w->cols; i++) w->grid[i] = DEAD;\n    c->current_blue_pop = 0;\n    c->current_red_pop = 0;\n    \n    int r, c_idx, team;\n    while (fscanf(f, \"%d %d %d\", &r, &c_idx, &team) == 3) {\n        if (r >= 0 && r < rows && c_idx >= 0 && c_idx < cols) {\n            int idx = r * cols + c_idx;\n            w->grid[idx] = team;\n            if (team == TEAM_RED) c->current_red_pop++;\n            if (team == TEAM_BLUE) c->current_blue_pop++;\n        }\n    }\n    \n    fclose(f);\n    printf(\"Loaded from %s\\n\", filename);\n    return 1; // Success\n}\n\n// Stub implementations for Phase 2\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list) {\n    // To be implemented in Phase 2\n    *out_list = NULL;\n    return 0;\n}\n\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    // To be implemented in Phase 2\n    return 0;\n}\n",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.c"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768657738472-af35c7b8d9faf",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.h (1 replacements)."
  }
}
```**Tool Response**:
```json
{
  "id": "replace-1768657738641-237cde7b0f6768",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Ich habe die √Ñnderungen f√ºr Phase 1 vorgenommen (`file_io.c` und `file_io.h`).
Bevor ich weitermache, muss ich sicherstellen, dass der Code kompiliert und das neue Speicherformat funktioniert.

Da die Anwendung in einem Docker-Container laufen soll, werde ich pr√ºfen, wie der Build-Prozess definiert ist. Dazu lese ich `Dockerfile` und `README.md`.

Anschlie√üend werde ich dich bitten, den Build und den Test durchzuf√ºhren.**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "Dockerfile"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "README.md"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "read_file-1768657798747-a21bfdc3da1be8",
  "name": "read_file",
  "response": {
    "output": "FROM gcc:latest\n\nWORKDIR /app\n\n# Install dependencies for Raylib (Linux/X11) and build tools\n# KI-Agent unterst√ºtzt\nRUN apt-get update && apt-get install -y \\\n    make \\\n    git \\\n    cmake \\\n    libasound2-dev \\\n    libx11-dev \\\n    libxrandr-dev \\\n    libxi-dev \\\n    libgl1-mesa-dev \\\n    libglu1-mesa-dev \\\n    libxcursor-dev \\\n    libxinerama-dev \\\n    libwayland-dev \\\n    libxkbcommon-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Clone, Build, and Install Raylib from source\n# KI-Agent unterst√ºtzt\nRUN git clone https://github.com/raysan5/raylib.git /tmp/raylib \\\n    && cd /tmp/raylib/src \\\n    && make PLATFORM=PLATFORM_DESKTOP \\\n    && make install \\\n    && cd / \\\n    && rm -rf /tmp/raylib\n\nCOPY . .\n\n# Automatically start bash\nCMD [\"bash\"]"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768657798933-aa5011fe15ece",
  "name": "read_file",
  "response": {
    "output": "# Conway's Game of Life in einer C-Umgebung - Bonus: Interaktiver Wettbewerb um das nachhaltigste Zell-Biotop\n#### Author1: Friedemann Decker / 2203777\n#### Video: <URL> oder \"VC\"\n#### Description:\n\n##### Spielregeln\n aus Gewinnen: Strategien f√ºr math. Spiele Bd. 4, Elwyn R. Berlekamp, John H. Conway, Richard K. Guy, Vieweg, 1985, Seite 123\n\n\"LIFE\" wird auf einem unendlichen Schachbrett gespielt. Ein Spiel-Zustand ist dadurch gegeben, dass man sagt, welche Quadrate oder Zellen **leben** und welche **tod** sind. Den Anfangszustand zur Zeit 0 k√∂nnen Sie sich aussuchen. Danach haben Sie sich freundlichst zur√ºckzulehnen und nichts mehr zu tun, denn was dann kommt, ergibt sich in strenger Zwangsl√§ufigkeit aus den Spielregeln:\n**Geburt**: Eine zur Zeit t tote Zelle wird zum Zeitpunkt *t+1* genau dann lebendig, wenn zur Zeit *t* genau 3 von ihren  Nachbarn lebendig waren.\n**Tod durch √úberbev√∂lkerung**: Eine Zelle, die zur Zeit *t* lebt, aber zugleich noch 4 oder mehr lebende Nachbarn hat, ist zur Zeit *t+1* tot.\n**Tod durch Einsamkeit**: Eine Zelle, die zur Zeit *t* lebt, aber nur einen oder keinen lebendigen Nachbarn hat, ist zur Zeit *t+1* tot.\n\nDamit haben wir alle Todesursachen abgehandelt, also lassen wir das traurige Thema und reden wir von der Regel f√ºr das\n**√úberleben**: Eine Zelle, die zur Zeit *t* lebt, ist auch zur Zeit *t+1* am Leben, wenn sie 2 oder 3 zur Zeit *t* lebende Nachbarn hat.\nZITAT Ende\n\n\nUmsetzung der Spielidee in ein C-Programm\n\n##### Unendliches Spielfeld\nDas unendliche Spielfeld wird dadurch realisiert, dass die geg√ºberliegenden R√§nder als Nachbarfelder modelliert werden. Dadurch entsteht quasi ein unendliches Spielfeld in Form der Oberfl√§che eines Torus.\n\n##### Programmier-Konzept\nDie Kern-Algorithmen (Erstellung des Spielfelds, Berechnung der Zust√§nde, Speicherverwaltung) werden eigenst√§ndig programmiert. Die periphere Komponenten (Eingabe Startkonfiguration, Ausgabe auf Bildschirm, ...) werden mittels eines selbst entwickelten Vibe-Coding Prompts erstellt.\n\n##### Prseudocode Kern-Algorithmen\n// Einbindung ben√∂tigter Header\n#include <stdio.h>\n#include <stdlib.h>\n\n// 1. Konstanten festlegen\n// Eine geeignete Anzahl Zeilen/Spalten f√ºr den Betrieb wird sp√§ter festgelegt.\n// F√ºr die Entwicklung wird 20/20 gew√§hlt\n#define ROWS 20  \n#define COLS 20\n\n// 2. Struktur definieren\ntypedef struct {\n    int *grid; // Pointer auf Array\n    int r;\n    int c;\n} World;\n\nint main(void) {\n    // 3. Dynamische Speicherverwaltung f√ºr zwei Gitter\n    // Zwei Gitter, um neuen zustand berechnen zu k√∂nnen, ohne den aktuellen Zustand zu beeinflussen, analog zu \"Bildbearbeituns-√úbung\"\n    World *current_gen = malloc(sizeof(World));\n    World *next_gen = malloc(sizeof(World));\n\n    // Speicher f√ºr die Zellen (Arrays) reservieren\n    current_gen->grid = malloc(ROWS * COLS * sizeof(int));\n    next_gen->grid = malloc(ROWS * COLS * sizeof(int));\n\n    // 4. Initialisierung\n    // Zuf√§lliges Muster lebender Zellen\n    init_world(current_gen);\n\n    // 5. Spiel-Schleife (Loop)\n    while (true) {\n        print_world(current_gen);\n        update_generation(current_gen, next_gen);\n\n        // Tausche die Gitter (Pointer-Zuweisung)\n        World *temp = current_gen;\n        current_gen = next_gen;\n        next_gen = temp;\n\n        // Abbruchbedingung oder Pause noch einf√ºgen\n    }\n\n    // 6. Speicher freigeben (Vermeidung von Memory Leaks)\n    free(current_gen->grid);\n    free(next_gen->grid);\n    free(current_gen);\n    free(next_gen);\n\n    return 0;\n}\n\n\n## Ab hier Programmierung mit VIBE-CODING\nMittlerweile existieren von verschiedenen Anbietern sog. KI-Agenten, die behaupten, auf professionellem Niveau Software-Code schreiben zu k√∂nnen. \nZiel dieses Projektes ist, eine funktionierende (von Hand in C geschriebene) Simulation von Conway's Game of Life mittels der Nutzung von einem KI-Agenten zu der im Folgenden beschriebenen Anwendung zu entwickeln.\n\n### Vorgehensweise\nIm ersten Schritt wird ein sog. **Architecture Decision Record (ADR)** erstellt, der die Anforderungen an das Projekt und die Grundlagen f√ºr die Entscheidung f√ºr das Programmkonzept enth√§lt. In einem weiteren Schritt soll der KI-Agent eine **Anforderungsanalyse und Spezifikation** erstellen, in der auf Basis des ADR die Anforderungsspezifikation, User Stories, das Product Backlog und die Definition of Done formuliert werden. Im n√§chsten Schritt soll der KI-Agent dann das **technische Design und eine umsetzbare technische Architektur** entwickeln und formulieren. Basierend auf diesen Dokumenten wird der KI-Agent anschlie√üend beauftragt, eine detaillierte **Aufgabenliste** zu erstellen, die dann verwendet wird, um den KI-Agenten pr√§zise durch die Umsetzung und Entwicklung des Programmcodes zu f√ºhren. Dem KI-Agenten werden f√ºr die vorstehend genannten Dokumente **Templates** zur Verf√ºgung gestellt, die eine Form und inhaltliche Struktur vorgeben.\n\nDie zur Verf√ºgung gestellten Templates und die von dem KI-Agenten erstellten Dokumente werden in einem separaten Verzeichnis docs/ innerhalb der Codebase abgelegt.\n\n\nF√ºr die Umsetzung wird der KI-Agent von Google Gemini-CLI verwendet. Ausschlaggebend f√ºr die Wahl dieses Anbieters war ausschlie√ülich das gro√üe kostenfreie Token-Volumen f√ºr Studierende.\n\n\n##### Pseudocode Biotop\nLIFE bleibt immer noch ein 0-Personen-Spiel, jedoch wird der Zustand des initialen Spielfelds von zwei unterschiedlichen Personen (Teams \"rot\" vs \"blau\") festgelegt. Dann wird das Spiel gestartet. Nach einer festgelegten Anzahl Zyklen wird gez√§hlt, von welcher Farbe mehr Zellen existieren. Gewonnen hat der Spieler mit den meisten lebenden Zellen. \nMan kann sich das das Spielfeld wie ein **Biotop** vorstellen: Die Regeln von Conway bestimmen, wo neues Leben entstehen kann, aber die Teamfarben der Nachbarn entscheiden, welche  \"Lebensform\" das neue Leben annimmt. So entsteht ein rundenbasierter Wettstreit auf einem mathematischen Raster.\n\nUm die interaktive Spielidee ‚ÄûRote Zellen vs Blaue Zellen‚Äú auf Basis des vorhandenen Entwurfs f√ºr Conway's Game of Life umzusetzen, muss der Pseudocode in der **Zustandsverwaltung** und der **Geburtslogiklogik** erweitert werden. W√§hrend das klassische Modell nur ‚Äûlebendig‚Äú oder ‚Äûtot‚Äú kennt, wird hier eine Differenzierung nach Zellfarben eingef√ºhrt.\n\nEntwurf f√ºr die Erweiterung des Pseudocodes:\n\n1. Erweiterung der Datenstruktur und Konstanten\nDie Zust√§nde f√ºr die verschiedenen Teams werden definiert.\n\n#define DEAD 0\n#define TEAM_RED 1\n#define TEAM_BLUE 2\n#define MAX_ROUNDS 100 // Beispielhafte Begrenzung der Runden\n\nIn der Struktur `World` bleibt der Pointer auf das Gitter gleich, aber die darin gespeicherten Ganzzahlen (`int`) repr√§sentieren nun diese drei Zust√§nde (`0`, `1` oder `2`).\n\n2. Anpassung der Initialisierung (`init_world`)\n\nAnstatt das Gitter zuf√§llig zu f√ºllen, wird eine Funktion ben√∂tigt, die es den Spielern erm√∂glicht, ihre **Startaufstellung** zu definieren.\n\n‚Ä¢ **Spieler 1 (Rot)** w√§hlt Koordinaten f√ºr seine Zellen.\n\n‚Ä¢ **Spieler 2 (Blau)** w√§hlt Koordinaten f√ºr seine Zellen.\n\n3. Erweiterte Logik der Evolution (`update_generation`)\n\nDie wichtigste √Ñnderung betrifft die Regeln f√ºr Geburt und √úberleben. Jede Zelle muss nicht nur die Anzahl der Nachbarn pr√ºfen, sondern auch deren **Zugeh√∂rigkeit**.\n\n**Logik-Erweiterung:**\n\n**Nachbarn z√§hlen:** Die Funktion `count_neighbors` muss nun die Anzahl der roten und blauen Nachbarn separat erfassen.\n\n**Geburt:** Wenn eine tote Zelle genau **drei lebende Nachbarn** hat, wird sie geboren\nZusatzregel: Die neue Zelle erh√§lt die Farbe des Teams, das die **Mehrheit** unter diesen drei Nachbarn stellt (z. B. 2 rote und 1 blaue Zelle -> die neue Zelle wird rot).\n\n**√úberleben:** Eine lebende Zelle bleibt am Leben, wenn sie **2 oder 3 Nachbarn** hat (unabh√§ngig von deren Farbe). Sie beh√§lt dabei ihre urspr√ºngliche Teamfarbe bei.\n\n**Tod:** Zellen sterben weiterhin durch Einsamkeit (<2) oder √úberbev√∂lkerung (>3).\n\n4. Spielschleife und Siegbedingung\n\nDie `while`-Schleife im Hauptprogramm wird um einen **Rundenz√§hler** und eine **Auswertung** am Ende erg√§nzt.\n\nint rounds = 0;\nwhile (rounds < MAX_ROUNDS) {\n    print_world(current_gen); // Visualisierung der roten und blauen Zellen [4]\n    update_generation(current_gen, next_gen);\n    \n    // Gitter tauschen wie gehabt\n    World *temp = current_gen;\n    current_gen = next_gen;\n    next_gen = temp;\n\n    rounds++;\n}\n\n// 5. Auswertung (Siegbedingung)\nint red_count = count_cells_by_team(current_gen, TEAM_RED);\nint blue_count = count_cells_by_team(current_gen, TEAM_BLUE);\n\nif (red_count > blue_count) {\n    // Team Rot gewinnt\n} else if (blue_count > red_count) {\n    // Team Blau gewinnt\n}\n\n// 6. UI f√ºr Biotop\n√úber eine GUI k√∂nnen die Spieler folgende Eingaben vor Spielbeginn vornehmen.\n6.1 Spielfeldgr√∂√üe in Zeilen x Spalten (rows, cols). √úberschreibbare Standardvorgabe: 100 x 100.\n6.2 Verz√∂gerung der Anzeige einer neu berechneten Generation in Millisekunden. √úberschreibbare Standardvorgabe 500 Millisekunden.\n6.3 Anzahl der zur Generation 0 maximal lebenden Zellen pro Team. Es k√∂nnen weniger als die maximale Anzahl lebender Zellen initial eingegeben werden. √úberschreibbare Standardvorgabe: 100. Es kann jedoch immer nur maximal 50% der gesamten Spielfeldgr√∂√üe pro Team initial belegt werden.\n6.4 Anzahl der zu spielenden Runden (turns). √úberschreibbare Standardvorgabe: 1000.\n6.4 Eingabe der initialen Belegung der Population (lebende Zellen) pro Team mittels Mausklick auf eine Zelle in einem auf dem Bildschirm dargestellten graphischen Gitter. Der zu belegende Bereich ist quadratisch. Diese initiale Belegung wird in einem geeigneten Datenformat auf der Festplatte abgespeichert und f√ºr den Spielablauf von dem Programm eingelesen.\n6.4.1 Historische initiale Belegungen k√∂nnen ausgew√§hlt werden und erneut gestartet werden.\n6.4.2 Die initiale Belegung von Team Rot wird mittig in der rechten Hemisph√§re des Spielfeldes platziert. Die initiale Belegung von Team Blau wird mittig in der linken Hemisph√§re des Spielfeldes platziert.\n6.5 Das Endergebnis in Form einer statistischen Auswertung des Spielverlaufs wird als Datei im .md-Format auf der Festplatte abgespeichert."
  }
}
```

---

## MODEL ‚ú®

Ich habe die Projektstruktur und die Dokumentation analysiert. Es gibt keine `Makefile` im Projektverzeichnis, aber die `DEV_TASKS` schlagen einen manuellen Kompilierbefehl vor.

Da die Anwendung in einer Docker-Umgebung laufen soll, werde ich dich nun bitten, die Kompilierung durchzuf√ºhren, um sicherzustellen, dass die √Ñnderungen korrekt sind.

Bitte f√ºhre folgenden Befehl aus, um die ge√§nderten Dateien zu kompilieren (nur Objektdateien, um Syntaxfehler zu finden):
`gcc -c main.c gui.c file_io.c game_logic.c`

Berichte mir anschlie√üend das Ergebnis.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "command": "gcc -c main.c gui.c file_io.c game_logic.c",
    "description": "Compile the source files to object files to verify syntax and header correctness."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768657807611-2089c8ea9cc73",
  "name": "run_shell_command",
  "response": {
    "error": "[Operation Cancelled] Reason: User cancelled the operation."
  }
}
```

---

## USER üßë‚Äçüíª

Die Compilierung ist ohne Fehlermeldung gelaufen.

---

## MODEL ‚ú®

Da die Kompilierung erfolgreich war, fahre ich mit **Phase 2: Directory Helper & File Listing** fort.

Ich werde nun `list_protocol_files` und `load_protocol_metadata` in `file_io.c` implementieren. Dabei nutze ich `<dirent.h>` f√ºr die Verzeichnisnavigation und `qsort` f√ºr die Sortierung nach Zeitstempel (neueste zuerst).

Zuerst f√ºge ich die notwendigen Includes hinzu und implementiere dann die Funktionen.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "old_string": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h> // For malloc/free\n#include \"file_io.h\"\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n... (rest of file_io.c) ...\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list) {\n    // To be implemented in Phase 2\n    *out_list = NULL;\n    return 0;\n}\n\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    // To be implemented in Phase 2\n    return 0;\n}\n",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.c",
    "instruction": "Implement list_protocol_files and load_protocol_metadata in file_io.c using dirent.h and qsort for sorting.",
    "new_string": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h> // For malloc/free\n#include <string.h>\n#include <dirent.h>\n#include \"file_io.h\"\n\n// Comparator for qsort to sort by timestamp descending\nstatic int compare_protocol_info(const void *a, const void *b) {\n    ProtocolInfo *pa = (ProtocolInfo *)a;\n    ProtocolInfo *pb = (ProtocolInfo *)b;\n    if (pb->timestamp > pa->timestamp) return 1;\n    if (pb->timestamp < pa->timestamp) return -1;\n    return 0;\n}\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n... (existing save_grid code) ...\n}\n\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c) {\n... (existing load_grid code) ...\n}\n\n// KI-Agent unterst√ºtzt\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list) {\n    DIR *d = opendir(dir_path);\n    if (!d) {\n        printf(\"Error: Could not open directory %s\\n\", dir_path);\n        return 0;\n    }\n\n    struct dirent *dir;\n    int count = 0;\n    int capacity = 10;\n    ProtocolInfo *list = malloc(capacity * sizeof(ProtocolInfo));\n\n    while ((dir = readdir(d)) != NULL) {\n        // Filter for .bio extension\n        char *ext = strrchr(dir->d_name, '.');\n        if (ext && strcmp(ext, \".bio\") == 0) {\n            ProtocolInfo info;\n            snprintf(info.filename, sizeof(info.filename), \"%s\", dir->d_name);\n            snprintf(info.filepath, sizeof(info.filepath), \"%s/%s\", dir_path, dir->d_name);\n            \n            if (load_protocol_metadata(info.filepath, &info)) {\n                if (count >= capacity) {\n                    capacity *= 2;\n                    list = realloc(list, capacity * sizeof(ProtocolInfo));\n                }\n                list[count++] = info;\n            }\n        }\n    }\n    closedir(d);\n\n    if (count > 0) {\n        qsort(list, count, sizeof(ProtocolInfo), compare_protocol_info);\n    }\n\n    *out_list = list;\n    return count;\n}\n\n// KI-Agent unterst√ºtzt\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) return 0;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n\n    int version;\n    int items = sscanf(line, \"%d %ld %d %d %d %d\", \n                       &version, &info->timestamp, &info->rows, &info->cols, \n                       &info->max_population, &info->max_rounds);\n\n    if (items == 6 && version == 2) {\n        // OK\n    } else {\n        // Try legacy\n        items = sscanf(line, \"%d %d %d\", &info->rows, &info->cols, &info->max_population);\n        if (items == 3) {\n            info->timestamp = 0;\n            info->max_rounds = 1000;\n        } else {\n            fclose(f);\n            return 0;\n        }\n    }\n\n    fclose(f);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner) {\n"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768657921623-04444c9a285ab",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Ich habe die Phase 2 implementiert. Um sicherzugehen, dass `list_protocol_files` und `load_protocol_metadata` korrekt funktionieren, werde ich nun ein kleines Testprogramm erstellen und ausf√ºhren.

Das Testprogramm wird das aktuelle Verzeichnis nach `.bio`-Dateien durchsuchen und deren Metadaten ausgeben.

Danach gehe ich zu **Phase 3: GUI - Auto-Save Implementation** √ºber.

Zuvor erstelle ich `test_phase2.c`.**Tool Command**:
```json
{
  "name": "write_file",
  "args": {
    "file_path": "test_phase2.c",
    "content": "#include <stdio.h>\n#include <stdlib.h>\n#include \"file_io.h\"\n\nint main() {\n    ProtocolInfo *list = NULL;\n    int count = list_protocol_files(\".\", &list);\n    \n    printf(\"Found %d protocol files:\\n\", count);\n    for (int i = 0; i < count; i++) {\n        printf(\"%d: %s (Time: %ld, Size: %dx%d, Rounds: %d)\\n\", \n               i, list[i].filename, list[i].timestamp, \n               list[i].rows, list[i].cols, list[i].max_rounds);\n    }\n    \n    if (list) free(list);\n    return 0;\n}\n"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "write_file-1768658000823-2a450ac0a682d8",
  "name": "write_file",
  "response": {
    "output": "Successfully created and wrote to new file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\test_phase2.c."
  }
}
```

---

## MODEL ‚ú®

Bitte f√ºhre nun den folgenden Befehl aus, um das Testprogramm zu kompilieren und auszuf√ºhren (daf√ºr m√ºssen auch `file_io.c` und `game_logic.c` etc. gelinkt werden, wobei wir hier nur die Metadaten-Funktionen testen):

`gcc test_phase2.c file_io.c game_logic.c -o test_phase2 -lraylib -lGL -lm -lpthread -ldl -lrt -lX11 && ./test_phase2`

*(Hinweis: Falls `setup.bio` bereits existiert, sollte es in der Liste erscheinen. Falls nicht, kannst du das Programm einfach einmal starten und mit `S` speichern, bevor du den Test ausf√ºhrst.)*

Berichte mir bitte das Ergebnis.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "description": "Compile and run the Phase 2 test program to verify directory listing and metadata parsing.",
    "command": "gcc test_phase2.c file_io.c game_logic.c -o test_phase2 -lraylib -lGL -lm -lpthread -ldl -lrt -lX11 && ./test_phase2"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768658159004-9a38ad8135d828",
  "name": "run_shell_command",
  "response": {
    "error": "[Operation Cancelled] Reason: User cancelled the operation."
  }
}
```

---

## USER üßë‚Äçüíª

Im Docker-Terminal wird folgende Meldung ausgegeben:
# gcc test_phase2.c file_io.c game_logic.c -o test_phase2 -lraylib -lGL -lm -lpthread -ldl -lrt -lX11 && ./test_phase2   
file_io.c: In function 'save_grid':
file_io.c:19:1: error: expected expression before '...' token
   19 | ... (existing save_grid code)
      | ^~~
file_io.c: In function 'load_grid':
file_io.c:24:1: error: expected expression before '...' token
   24 | ... (existing load_grid code)
      | ^~~
file_io.c: In function 'export_stats_md':
file_io.c:134:1: error: expected declaration or statement at end of input
  134 | }
      | ^
#
Bitte analysiere die Fehlermeldung Zeile f√ºr Zeile.
Erl√§utere die Fehlermeldung anschaulich.
Wie kann der Fehler behoben werden?
√úberlege, welche neuen Probleme durch √Ñnderungen, die du an dem Code vornimmst, m√∂glicherweise entstehen k√∂nnen und vermeide sie.

---

## MODEL ‚ú®

Du hast v√∂llig recht, das ist ein klassischer Fehler beim Zusammenf√ºgen von Code-Snippets.

**Analyse der Fehlermeldung:**
1.  `file_io.c:19:1: error: expected expression before '...' token`: In Zeile 19 steht w√∂rtlich `... (existing save_grid code) ...`. Der C-Compiler erwartet hier echten Programmcode (Anweisungen, Variablen), findet aber drei Punkte, was er nicht interpretieren kann.
2.  `file_io.c:134:1: error: expected declaration or statement at end of input`: Die Datei h√∂rt abrupt auf (wahrscheinlich bei der Definition von `export_stats_md`), ohne dass die Funktion oder die Datei ordnungsgem√§√ü mit einer geschweiften Klammer `}` geschlossen wurde.

**Ursache:**
Ich habe im vorherigen Schritt beim Einf√ºgen der neuen Funktionen (`list_protocol_files`) Platzhalter (`...`) f√ºr die bereits existierenden Funktionen (`save_grid`, `load_grid`) verwendet, anstatt den vollst√§ndigen Code wieder einzuf√ºgen. Dadurch wurde der funktionierende Code durch diese Platzhalter √ºberschrieben.

**L√∂sung:**
Ich werde die Datei `file_io.c` nun komplett neu schreiben und dabei sicherstellen, dass **alle** Funktionen (die Speicherlogik aus Phase 1 und die Listenlogik aus Phase 2) vollst√§ndig und korrekt enthalten sind.

Hier ist die Reparatur:**Tool Command**:
```json
{
  "name": "write_file",
  "args": {
    "file_path": "file_io.c",
    "content": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h> // For malloc/free\n#include <string.h>\n#include <dirent.h>\n#include \"file_io.h\"\n\n// Comparator for qsort to sort by timestamp descending\nstatic int compare_protocol_info(const void *a, const void *b) {\n    ProtocolInfo *pa = (ProtocolInfo *)a;\n    ProtocolInfo *pb = (ProtocolInfo *)b;\n    if (pb->timestamp > pa->timestamp) return 1;\n    if (pb->timestamp < pa->timestamp) return -1;\n    return 0;\n}\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) {\n        printf(\"Error saving file %s\\n\", filename);\n        return 0;\n    }\n    \n    // v2 Header: Version Timestamp Rows Cols MaxPop MaxRounds Delay\n    // Version 2\n    long timestamp = (long)time(NULL);\n    fprintf(f, \"2 %ld %d %d %d %d %d\\n\", \n            timestamp, \n            c->rows, c->cols, \n            c->max_population, \n            c->max_rounds, \n            c->delay_ms);\n    \n    // Save live cells only: r c team\n    for(int i=0; i < w->rows * w->cols; i++) {\n        if (w->grid[i] != DEAD) {\n            int r = i / w->cols;\n            int c_idx = i % w->cols;\n            fprintf(f, \"%d %d %d\\n\", r, c_idx, w->grid[i]);\n        }\n    }\n    \n    fclose(f);\n    printf(\"Saved to %s\\n\", filename);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        printf(\"Error opening file %s\\n\", filename);\n        return 0; // Fail\n    }\n    \n    int rows, cols, max_pop;\n    int max_rounds = 1000; // Default legacy\n    int delay_ms = 100;    // Default legacy\n    long timestamp = 0;\n    int version = 1;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n    \n    // Try parsing as v2\n    int items = sscanf(line, \"%d %ld %d %d %d %d %d\", \n                       &version, &timestamp, &rows, &cols, &max_pop, &max_rounds, &delay_ms);\n                       \n    if (items == 7 && version == 2) {\n        printf(\"Detected Protocol v2. Timestamp: %ld\\n\", timestamp);\n    } else {\n        // Fallback to legacy v1\n        items = sscanf(line, \"%d %d %d\", &rows, &cols, &max_pop);\n        if (items == 3) {\n            version = 1;\n            printf(\"Detected Legacy Format (v1).\\n\");\n        } else {\n            printf(\"Error: Unknown file format.\\n\");\n            fclose(f);\n            return 0;\n        }\n    }\n    \n    // Check if loaded config matches current world size\n    if (rows != c->rows || cols != c->cols) {\n        printf(\"Resizing world from %dx%d to %dx%d...\\n\", c->rows, c->cols, rows, cols);\n        free(w->grid);\n        w->grid = (int*)malloc(rows * cols * sizeof(int));\n        if (!w->grid) {\n            printf(\"Error: Failed to allocate memory for new grid size.\\n\");\n            fclose(f);\n            return 0;\n        }\n        w->rows = rows;\n        w->cols = cols;\n        c->rows = rows;\n        c->cols = cols;\n    }\n    \n    // Update config\n    c->max_population = max_pop;\n    c->max_rounds = max_rounds;\n    c->delay_ms = delay_ms;\n    \n    // Clear grid\n    for(int i=0; i < w->rows * w->cols; i++) w->grid[i] = DEAD;\n    c->current_blue_pop = 0;\n    c->current_red_pop = 0;\n    \n    int r, c_idx, team;\n    while (fscanf(f, \"%d %d %d\", &r, &c_idx, &team) == 3) {\n        if (r >= 0 && r < rows && c_idx >= 0 && c_idx < cols) {\n            int idx = r * cols + c_idx;\n            w->grid[idx] = team;\n            if (team == TEAM_RED) c->current_red_pop++;\n            if (team == TEAM_BLUE) c->current_blue_pop++;\n        }\n    }\n    \n    fclose(f);\n    printf(\"Loaded from %s\\n\", filename);\n    return 1; // Success\n}\n\n// KI-Agent unterst√ºtzt\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list) {\n    DIR *d = opendir(dir_path);\n    if (!d) {\n        printf(\"Error: Could not open directory %s\\n\", dir_path);\n        return 0;\n    }\n\n    struct dirent *dir;\n    int count = 0;\n    int capacity = 10;\n    ProtocolInfo *list = malloc(capacity * sizeof(ProtocolInfo));\n\n    while ((dir = readdir(d)) != NULL) {\n        // Filter for .bio extension\n        char *ext = strrchr(dir->d_name, '.');\n        if (ext && strcmp(ext, \".bio\") == 0) {\n            ProtocolInfo info;\n            snprintf(info.filename, sizeof(info.filename), \"%s\", dir->d_name);\n            snprintf(info.filepath, sizeof(info.filepath), \"%s/%s\", dir_path, dir->d_name);\n            \n            if (load_protocol_metadata(info.filepath, &info)) {\n                if (count >= capacity) {\n                    capacity *= 2;\n                    list = realloc(list, capacity * sizeof(ProtocolInfo));\n                }\n                list[count++] = info;\n            }\n        }\n    }\n    closedir(d);\n\n    if (count > 0) {\n        qsort(list, count, sizeof(ProtocolInfo), compare_protocol_info);\n    }\n\n    *out_list = list;\n    return count;\n}\n\n// KI-Agent unterst√ºtzt\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) return 0;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n\n    int version;\n    int items = sscanf(line, \"%d %ld %d %d %d %d\", \n                       &version, &info->timestamp, &info->rows, &info->cols, \n                       &info->max_population, &info->max_rounds);\n\n    if (items == 6 && version == 2) {\n        // OK\n    } else {\n        // Try legacy\n        items = sscanf(line, \"%d %d %d\", &info->rows, &info->cols, &info->max_population);\n        if (items == 3) {\n            info->timestamp = 0;\n            info->max_rounds = 1000;\n        } else {\n            fclose(f);\n            return 0;\n        }\n    }\n\n    fclose(f);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) return;\n    \n    time_t now = time(NULL);\n    struct tm *t = localtime(&now);\n    \n    fprintf(f, \"# Biotope Game Results\\n\\n\");\n    fprintf(f, \"**Date:** %02d.%02d.%04d %02d:%02d\\n\\n\", \n            t->tm_mday, t->tm_mon+1, t->tm_year+1900, t->tm_hour, t->tm_min);\n            \n    fprintf(f, \"## Configuration\\n\");\n    fprintf(f, \"- Grid: %dx%d\\n\", c->rows, c->cols);\n    fprintf(f, \"- Max Population: %d\\n\", c->max_population);\n    fprintf(f, \"- Max Rounds: %d\\n\\n\", c->max_rounds);\n    \n    fprintf(f, \"## Final Score\\n\");\n    fprintf(f, \"- **Red Team:** %d\\n\", c->current_red_pop);\n    fprintf(f, \"- **Blue Team:** %d\\n\\n\", c->current_blue_pop);\n    \n    fprintf(f, \"## Result\\n\");\n    if (winner == TEAM_RED) fprintf(f, \"**Winner: RED TEAM**\\n\");\n    else if (winner == TEAM_BLUE) fprintf(f, \"**Winner: BLUE TEAM**\\n\");\n    else fprintf(f, \"**DRAW**\\n\");\n    \n    fclose(f);\n    printf(\"Stats exported to %s\\n\", filename);\n}\n"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "write_file-1768658362901-d87b80e8ddd4a8",
  "name": "write_file",
  "response": {
    "output": "Successfully overwrote file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.c."
  }
}
```

---

## MODEL ‚ú®

Jetzt, wo der Code in `file_io.c` vollst√§ndig und korrekt ist, k√∂nnen wir den Test erneut versuchen.

Bitte f√ºhre folgenden Befehl erneut aus:
`gcc test_phase2.c file_io.c game_logic.c -o test_phase2 -lraylib -lGL -lm -lpthread -ldl -lrt -lX11 && ./test_phase2`

Berichte mir das Ergebnis. Wenn es erfolgreich ist (eine Liste von Dateien oder "Found 0 protocol files" wird angezeigt), werde ich mit **Phase 3** fortfahren.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "command": "gcc test_phase2.c file_io.c game_logic.c -o test_phase2 -lraylib -lGL -lm -lpthread -ldl -lrt -lX11 && ./test_phase2",
    "description": "Compile and run the Phase 2 test program again with the fixed file_io.c."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768658393180-e740cf3942faa",
  "name": "run_shell_command",
  "response": {
    "error": "[Operation Cancelled] Reason: User cancelled the operation."
  }
}
```

---

## USER üßë‚Äçüíª

Nun sieht die Ausgabe im Docker-Terminal besser aus. Entspricht dies deiner Erwartung:
# gcc test_phase2.c file_io.c game_logic.c -o test_phase2 -lraylib -lGL -lm -lpthread -ldl -lrt -lX11 && ./test_phase2 
Found 6 protocol files:
0: setup.bio (Time: 0, Size: 8x16, Rounds: 1000)
1: setup_2GGG_gatter.bio (Time: 0, Size: 150x250, Rounds: 1000)
2: setup_calculator.bio (Time: 0, Size: 500x1500, Rounds: 1000)
3: setup_chess.bio (Time: 0, Size: 8x16, Rounds: 1000)
4: setup_erzeugt_GGG.bio (Time: 0, Size: 150x150, Rounds: 1000)
5: setup_rot_gewinnt_erstaunlicherweise.bio (Time: 0, Size: 50x50, Rounds: 1000)
#

---

## MODEL ‚ú®

Das ist ein hervorragendes Ergebnis! Es entspricht exakt meinen Erwartungen:
- Die Funktionen erkennen die vorhandenen `.bio`-Dateien.
- Das **Legacy-Format (v1)** wird korrekt erkannt (daher `Time: 0` und `Rounds: 1000` als Standardwerte).
- Die Dateinamen und Metadaten (Gr√∂√üe) werden sauber ausgelesen.

Damit ist **Phase 2 abgeschlossen**.

### Phase 3: GUI - Auto-Save Implementation
In dieser Phase implementieren wir den automatischen Speichervorgang, sobald eine Simulation gestartet wird.

**Schritte:**
1.  Wir m√ºssen sicherstellen, dass das Verzeichnis `biotope_results` existiert.
2.  In `gui.c` f√ºgen wir die Logik ein, um beim Wechsel von `STATE_EDIT` zu `STATE_RUNNING` (Dr√ºcken der `ENTER`-Taste) eine neue Datei mit Zeitstempel zu erstellen.

Zuerst pr√ºfe ich `gui.c`, um die richtige Stelle f√ºr den Zustands√ºbergang zu finden.**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "gui.c"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "read_file-1768658513532-fec00d5b741418",
  "name": "read_file",
  "response": {
    "output": "#include \"raylib.h\"\r\n#include \"gui.h\"\r\n#include \"file_io.h\" // KI-Agent unterst√ºtzt\r\n#include <stdio.h>\r\n#include <stdlib.h> // For abs\r\n#include <time.h>   // For time()\r\n#include <string.h> // For strncpy\r\n\r\n// Global World Pointer for GUI\r\nWorld *gui_world = NULL;\r\n\r\n// --- Theme Colors (Digital Lab) ---\r\n// KI-Agent unterst√ºtzt: Sci-Fi / Retro Colors\r\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\r\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\r\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\r\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\r\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\r\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\r\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\r\n\r\n// Helper to draw the grid (reused in multiple states)\r\n// KI-Agent unterst√ºtzt: Optimized Texture-Based Rendering for VcXsrv performance\r\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\r\n    if (!gui_world) return;\r\n\r\n    // Layout Constants\r\n    const int headerHeight = 60;\r\n    const int footerHeight = 40;\r\n    const int margin = 20;\r\n    \r\n    int drawWidth = screenWidth - (margin * 2);\r\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\r\n    int startX = margin;\r\n    int startY = headerHeight;\r\n    \r\n    float cellW = (float)drawWidth / config->cols;\r\n    float cellH = (float)drawHeight / config->rows;\r\n    \r\n    // --- 1. Texture Management (Static to persist across frames) ---\r\n    static Texture2D gridTex = { 0 };\r\n    static int texW = 0;\r\n    static int texH = 0;\r\n    static Color *pixels = NULL;\r\n    \r\n    // Check if grid size changed or not initialized\r\n    if (config->cols != texW || config->rows != texH) {\r\n        // Cleanup old resources\r\n        if (gridTex.id > 0) UnloadTexture(gridTex);\r\n        if (pixels) free(pixels);\r\n        \r\n        // Update dimensions\r\n        texW = config->cols;\r\n        texH = config->rows;\r\n        \r\n        // Allocate new resources\r\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\r\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\r\n        gridTex = LoadTextureFromImage(img);\r\n        UnloadImage(img);\r\n        \r\n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\r\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \r\n    }\r\n    \r\n    // --- 2. Update Pixel Data (CPU side) ---\r\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\r\n    for (int i = 0; i < texW * texH; i++) {\r\n        if (gui_world->grid[i] == TEAM_BLUE) {\r\n            pixels[i] = THEME_BLUE;\r\n        } else if (gui_world->grid[i] == TEAM_RED) {\r\n            pixels[i] = THEME_RED;\r\n        } else {\r\n            pixels[i] = BLANK; // Transparent, so background shows through\r\n        }\r\n    }\r\n    \r\n    // --- 3. Upload to GPU & Draw ---\r\n    UpdateTexture(gridTex, pixels);\r\n    \r\n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\r\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\r\n    Vector2 origin = { 0.0f, 0.0f };\r\n    \r\n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\r\n\r\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\r\n    if (drawGridLines) {\r\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\r\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\r\n    }\r\n    \r\n    // 5. Draw Hemisphere Separator\r\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \r\n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\r\n}\r\n\r\n// KI-Agent unterst√ºtzt: Pattern Definitions\r\ntypedef struct { int r; int c; } Point;\r\n\r\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {\r\n    int team;\r\n    int midCol = c->cols / 2;\r\n    int *current_pop;\r\n    \r\n    // Determine Team based on Mouse Cursor (Start Position)\r\n    if (startC < midCol) {\r\n        team = TEAM_BLUE;\r\n        current_pop = &c->current_blue_pop;\r\n    } else {\r\n        team = TEAM_RED;\r\n        current_pop = &c->current_red_pop;\r\n    }\r\n\r\n    // Pattern Data\r\n    // Glider (3x3)\r\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\r\n    // HWSS (Traveler) (5x7)\r\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\r\n    // Gosper Glider Gun (Blaster) (9x36)\r\n    Point p_blaster[] = {\r\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\r\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\r\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\r\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\r\n    };\r\n\r\n    Point *cells = NULL;\r\n    int count = 0;\r\n\r\n    if (type == 1) { cells = p_glider; count = 5; }\r\n    else if (type == 2) { cells = p_traveler; count = 13; }\r\n    else if (type == 3) { cells = p_blaster; count = 36; }\r\n\r\n    for (int i = 0; i < count; i++) {\r\n        // Check Population Limit\r\n        if (*current_pop >= c->max_population) break;\r\n\r\n        // Calculate Wrap-around Coordinates\r\n        int r = (startR + cells[i].r) % c->rows;\r\n        int col = (startC + cells[i].c) % c->cols;\r\n        \r\n        // Handle negative modulo (if logic ever allows negative offsets)\r\n        if (r < 0) r += c->rows;\r\n        if (col < 0) col += c->cols;\r\n\r\n        // Check Border Crossing (Clipping Rule)\r\n        bool valid = false;\r\n        if (team == TEAM_BLUE && col < midCol) valid = true;\r\n        if (team == TEAM_RED && col >= midCol) valid = true;\r\n\r\n        if (valid) {\r\n            int idx = r * c->cols + col;\r\n            if (w->grid[idx] == DEAD) {\r\n                w->grid[idx] = team;\r\n                (*current_pop)++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// Helper for continuous input handling (Key Repeat)\r\nbool IsActionTriggered(int key) {\r\n    static int activeKey = -1;\r\n    static float timer = 0.0f;\r\n    const float INITIAL_DELAY = 0.5f;\r\n    const float REPEAT_INTERVAL = 0.05f; \r\n\r\n    if (IsKeyPressed(key)) {\r\n        activeKey = key;\r\n        timer = 0.0f;\r\n        return true;\r\n    }\r\n\r\n    if (IsKeyDown(key)) {\r\n        if (activeKey == key) {\r\n            timer += GetFrameTime();\r\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\r\n                timer = INITIAL_DELAY; \r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        if (activeKey == key) {\r\n            activeKey = -1;\r\n            timer = 0.0f;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n// KI-Agent unterst√ºtzt\r\nvoid run_gui_app() {\r\n    // Initial window size\r\n    int screenWidth = 800;\r\n    int screenHeight = 600;\r\n\r\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \r\n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\");\r\n    SetTargetFPS(60);\r\n\r\n    // Initial state\r\n    AppState state = STATE_CONFIG;\r\n    GameConfig config = {\r\n        .rows = 50, \r\n        .cols = 50, \r\n        .delay_ms = 100, \r\n        .max_population = 100, \r\n        .max_rounds = 1000,\r\n        .current_red_pop = 0,\r\n        .current_blue_pop = 0,\r\n        .current_round = 0\r\n    };\r\n    \r\n    // Feedback Message System\r\n    char statusMsg[64] = \"\";\r\n    float statusTimer = 0.0f;\r\n\r\n    while (!WindowShouldClose()) {\r\n        // Update dynamic screen dimensions\r\n        screenWidth = GetScreenWidth();\r\n        screenHeight = GetScreenHeight();\r\n        \r\n        // Timer for status message\r\n        if (statusTimer > 0) {\r\n            statusTimer -= GetFrameTime();\r\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\r\n        }\r\n        \r\n        // --- Logic per State ---\r\n        switch (state) {\r\n            case STATE_CONFIG:\r\n                // Interaction: Change Grid Size\r\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\r\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\r\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\r\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\r\n                \r\n                // Interaction: Change Delay (incl. German Layout)\r\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \r\n                    config.delay_ms += 50;\r\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \r\n                    config.delay_ms -= 50;\r\n\r\n                // Interaction: Change Max Rounds\r\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\r\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\r\n\r\n                // Interaction: Change Max Population\r\n                int max_squad_cells = (config.rows * config.cols) / 2;\r\n                // Clamp if grid size reduced below current max_pop\r\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\r\n\r\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\r\n                    config.max_population += 10;\r\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\r\n                }\r\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\r\n\r\n                // Transition: Start Setup\r\n                if (IsKeyPressed(KEY_ENTER)) {\r\n                    if (gui_world) free_world(gui_world);\r\n                    gui_world = create_world(config.rows, config.cols);\r\n                    // Initialize empty\r\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\r\n                    \r\n                    config.current_blue_pop = 0;\r\n                    config.current_red_pop = 0;\r\n                    config.current_round = 0;\r\n                    \r\n                    state = STATE_EDIT;\r\n                }\r\n                break;\r\n\r\n            case STATE_EDIT:\r\n                // --- Mouse & Pattern Interaction ---\r\n                {\r\n                    Vector2 mousePos = GetMousePosition();\r\n                    \r\n                    // Constants must match DrawGridAndCells layout\r\n                    const int headerHeight = 60;\r\n                    const int footerHeight = 40;\r\n                    const int margin = 20;\r\n                    int drawWidth = screenWidth - (margin * 2);\r\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\r\n                    int startX = margin;\r\n                    int startY = headerHeight;\r\n                    \r\n                    float cellW = (float)drawWidth / config.cols;\r\n                    float cellH = (float)drawHeight / config.rows;\r\n                    \r\n                    // State for Drag-and-Paint interaction\r\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\r\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\r\n\r\n                    // Check if mouse is inside the grid area\r\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\r\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\r\n                        \r\n                        int col = (int)((mousePos.x - startX) / cellW);\r\n                        int row = (int)((mousePos.y - startY) / cellH);\r\n                        \r\n                        // Handle Clicks (Single Cell) & Drag\r\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\r\n                            int index = row * config.cols + col;\r\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\r\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\r\n                            else editAction = 2;\r\n                        }\r\n\r\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\r\n                            int index = row * config.cols + col;\r\n                            int midCol = config.cols / 2;\r\n\r\n                            // Check Hemispheres and Population Limits\r\n                            if (col < midCol) {\r\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\r\n                                    gui_world->grid[index] = DEAD;\r\n                                    config.current_blue_pop--;\r\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\r\n                                    gui_world->grid[index] = TEAM_BLUE;\r\n                                    config.current_blue_pop++;\r\n                                }\r\n                            } else {\r\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\r\n                                    gui_world->grid[index] = DEAD;\r\n                                    config.current_red_pop--;\r\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\r\n                                    gui_world->grid[index] = TEAM_RED;\r\n                                    config.current_red_pop++;\r\n                                }\r\n                            }\r\n                        }\r\n                        \r\n                        // Handle Patterns\r\n                        if (IsKeyPressed(KEY_G)) {\r\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\r\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\r\n                            statusTimer = 2.0f;\r\n                        }\r\n                        if (IsKeyPressed(KEY_T)) {\r\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\r\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\r\n                            statusTimer = 2.0f;\r\n                        }\r\n                        if (IsKeyPressed(KEY_B)) {\r\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\r\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\r\n                            statusTimer = 2.0f;\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // File I/O\r\n                if (IsKeyPressed(KEY_S)) {\r\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\r\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\r\n                        statusTimer = 2.0f;\r\n                    } else {\r\n                        strcpy(statusMsg, \"Save Failed!\");\r\n                        statusTimer = 2.0f;\r\n                    }\r\n                }\r\n                if (IsKeyPressed(KEY_L)) {\r\n                    if (load_grid(\"setup.bio\", gui_world, &config)) {\r\n                        strcpy(statusMsg, \"Loaded from setup.bio!\");\r\n                        statusTimer = 2.0f;\r\n                    } else {\r\n                        strcpy(statusMsg, \"Load Failed\");\r\n                        statusTimer = 2.0f;\r\n                    }\r\n                }\r\n                \r\n                // KI-Agent unterst√ºtzt: Random Placement Logic\r\n                if (IsKeyPressed(KEY_R)) {\r\n                    // Reset grid\r\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\r\n                    config.current_blue_pop = 0;\r\n                    config.current_red_pop = 0;\r\n                    \r\n                    int midCol = config.cols / 2;\r\n                    // Seed random\r\n                    srand(time(NULL));\r\n                    \r\n                    // Iterate and randomly fill\r\n                    for(int r=0; r<config.rows; r++) {\r\n                        for(int c=0; c<config.cols; c++) {\r\n                            int idx = r * config.cols + c;\r\n                            // 20% chance to be alive\r\n                            if ((rand() % 100) < 20) {\r\n                                if (c < midCol) {\r\n                                    if (config.current_blue_pop < config.max_population) {\r\n                                        gui_world->grid[idx] = TEAM_BLUE;\r\n                                        config.current_blue_pop++;\r\n                                    }\r\n                                } else {\r\n                                    if (config.current_red_pop < config.max_population) {\r\n                                        gui_world->grid[idx] = TEAM_RED;\r\n                                        config.current_red_pop++;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    strcpy(statusMsg, \"Randomized Grid!\");\r\n                    statusTimer = 2.0f;\r\n                }\r\n                \r\n                // Transition: Start Simulation\r\n                if (IsKeyPressed(KEY_ENTER)) {\r\n                    state = STATE_RUNNING;\r\n                }\r\n                break;\r\n            \r\n            case STATE_RUNNING:\r\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\r\n                    if (gui_world) free_world(gui_world);\r\n                    gui_world = NULL;\r\n                    state = STATE_CONFIG;\r\n                    break;\r\n                }\r\n\r\n                // --- Simulation Logic ---\r\n                static float timeAccumulator = 0.0f;\r\n                timeAccumulator += GetFrameTime();\r\n                \r\n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\r\n                    timeAccumulator = 0.0f;\r\n                    \r\n                    World *next_gen = create_world(config.rows, config.cols);\r\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\r\n                    free_world(gui_world);\r\n                    gui_world = next_gen;\r\n                    \r\n                    config.current_round++;\r\n                    \r\n                    config.current_red_pop = 0;\r\n                    config.current_blue_pop = 0;\r\n                    for(int i=0; i<config.rows*config.cols; i++) {\r\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\r\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\r\n                    }\r\n                    \r\n                    if (config.current_round >= config.max_rounds || \r\n                        config.current_red_pop == 0 || \r\n                        config.current_blue_pop == 0) {\r\n                        state = STATE_FINISHED;\r\n                    }\r\n                }\r\n                break;\r\n                \r\n            case STATE_FINISHED:\r\n                if (IsKeyPressed(KEY_ENTER)) {\r\n                     state = STATE_GAME_OVER;\r\n                     int winner = 0;\r\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\r\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\r\n                     \r\n                     char filename[64];\r\n                     time_t t = time(NULL);\r\n                     sprintf(filename, \"biotope_results_%ld.md\", t);\r\n                     export_stats_md(filename, &config, winner);\r\n                }\r\n                if (IsKeyPressed(KEY_Q)) {\r\n                    if (gui_world) free_world(gui_world);\r\n                    gui_world = NULL;\r\n                    state = STATE_CONFIG;\r\n                }\r\n                break;\r\n\r\n            case STATE_GAME_OVER:\r\n                if (IsKeyPressed(KEY_ONE)) {\r\n                     if (gui_world) free_world(gui_world);\r\n                     gui_world = NULL;\r\n                     state = STATE_CONFIG;\r\n                }\r\n                break;\r\n        }\r\n\r\n        // --- Drawing ---\r\n        BeginDrawing();\r\n        ClearBackground(THEME_BG);\r\n\r\n        // Draw HUD Backgrounds (Header & Footer)\r\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\r\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\r\n\r\n        // Draw Status Message Overlay\r\n        if (statusTimer > 0) {\r\n            // KI-Agent unterst√ºtzt: Center status message to avoid collision with counters\r\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\r\n        }\r\n\r\n        switch (state) {\r\n            case STATE_CONFIG:\r\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\r\n                \r\n                char buf[64];\r\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\r\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\r\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\r\n                \r\n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\r\n                DrawText(buf, 40, 140, 20, THEME_RED);\r\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\r\n                \r\n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\r\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\r\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\r\n                \r\n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\r\n                DrawText(buf, 40, 220, 20, THEME_RED);\r\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\r\n                \r\n                // KI-Agent unterst√ºtzt: Mission Protocol (Rules Display)\r\n                int rulesX = screenWidth / 2 + 40;\r\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\r\n                \r\n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\r\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\r\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\r\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\r\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\r\n\r\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\r\n                break;\r\n\r\n            case STATE_EDIT:\r\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\r\n                // KI-Agent unterst√ºtzt: Increased font size to 16 for better readability\r\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\r\n                \r\n                // Draw Population Counters\r\n                char popBuf[64];\r\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\r\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\r\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\r\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\r\n                \r\n                // Ghost Cursor (Visual Polish)\r\n                Vector2 mousePos = GetMousePosition();\r\n                // ... Re-calculate grid metrics for ghost cursor ...\r\n                {\r\n                     const int headerHeight = 60;\r\n                    const int footerHeight = 40;\r\n                    const int margin = 20;\r\n                    int drawWidth = screenWidth - (margin * 2);\r\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\r\n                    int startX = margin;\r\n                    int startY = headerHeight;\r\n                    float cellW = (float)drawWidth / config.cols;\r\n                    float cellH = (float)drawHeight / config.rows;\r\n                    \r\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\r\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\r\n                        int col = (int)((mousePos.x - startX) / cellW);\r\n                        int row = (int)((mousePos.y - startY) / cellH);\r\n                        // Draw Ghost\r\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\r\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\r\n                    }\r\n                }\r\n                \r\n                // KI-Agent unterst√ºtzt: Draw grid lines only if grid is not too dense (> 150)\r\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\r\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \r\n\r\n                // KI-Agent unterst√ºtzt: Updated Footer Menu Font Size to 14\r\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \r\n                         20, screenHeight - 28, 20, THEME_TEXT);\r\n                break;\r\n\r\n            case STATE_RUNNING:\r\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\r\n                \r\n                // KI-Agent unterst√ºtzt: Stable positioning for Label and Counter\r\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\r\n                char roundBuf[32];\r\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\r\n                \r\n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\r\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \r\n                int labelWidth = MeasureText(labelText, 20);\r\n                int gap = 10;\r\n                int rightMargin = 20;\r\n                \r\n                // Draw Label (Fixed position relative to right edge)\r\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\r\n                \r\n                // Draw Counter (Fixed start position)\r\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\r\n                \r\n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\r\n                \r\n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\r\n                break;\r\n                \r\n            case STATE_FINISHED:\r\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\r\n                \r\n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\r\n                \r\n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\r\n                break;\r\n\r\n            case STATE_GAME_OVER:\r\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\r\n                \r\n                char resultBuf[128];\r\n                Color winnerColor = THEME_TEXT;\r\n                if (config.current_red_pop > config.current_blue_pop) {\r\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\r\n                    winnerColor = THEME_RED;\r\n                } else if (config.current_blue_pop > config.current_red_pop) {\r\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\r\n                    winnerColor = THEME_BLUE;\r\n                } else {\r\n                    sprintf(resultBuf, \"RESULT: DRAW\");\r\n                }\r\n                \r\n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\r\n                \r\n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\r\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\r\n                \r\n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\r\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\r\n                break;\r\n        }\r\n\r\n        EndDrawing();\r\n    }\r\n\r\n    if (gui_world) free_world(gui_world);\r\n    CloseWindow();\r\n}"
  }
}
```

---

## MODEL ‚ú®

Ich habe die Stelle in `gui.c` gefunden, an der die Simulation gestartet wird (`STATE_EDIT` -> `KEY_ENTER`).

Ich werde nun folgendes tun:
1.  In `gui.c` eine Hilfsfunktion hinzuf√ºgen (oder direkt im `STATE_EDIT` Block), die den Dateinamen generiert und `save_grid` aufruft.
2.  Den Zustands√ºbergang in `gui.c` anpassen.
3.  Ich pr√ºfe auch, ob ich ein Verzeichnis erstellen muss. Da wir unter Windows/Linux arbeiten, nutze ich eine einfache L√∂sung.

Zuerst implementiere ich die Auto-Save-Logik in `gui.c`. Ich f√ºge auch einen neuen Zustand `STATE_LOAD` in `gui.h` und `gui.c` hinzu, um die Grundlage f√ºr Phase 4 zu legen.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "new_string": "typedef enum {\n    STATE_CONFIG,\n    STATE_EDIT,\n    STATE_LOAD,     // NEW: For browsing protocol archive\n    STATE_RUNNING,\n    STATE_FINISHED, \n    STATE_GAME_OVER\n} AppState;",
    "instruction": "Add STATE_LOAD to AppState enum.",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.h",
    "old_string": "typedef enum {\n    STATE_CONFIG,\n    STATE_EDIT,\n    STATE_RUNNING,\n    STATE_FINISHED, // KI-Agent unterst√ºtzt: New state for viewing final grid\n    STATE_GAME_OVER\n} AppState;"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768658517400-d5b5e674102b8",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.h (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Nun passe ich `gui.c` an, um den Auto-Save beim Start der Simulation durchzuf√ºhren und die Taste `L` auf den neuen Zustand `STATE_LOAD` (der in Phase 4 implementiert wird) vorzubereiten.

Ich werde auch eine Pr√ºfung hinzuf√ºgen, ob das Verzeichnis `biotope_results` existiert. Da wir keine komplexe Library f√ºr Dateisysteme haben, werde ich `run_shell_command` nutzen, um das Verzeichnis einmalig anzulegen.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "description": "Create the biotope_results directory if it doesn't exist.",
    "command": "powershell.exe -Command \"New-Item -ItemType Directory -Force -Path biotope_results\""
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768658572888-40799e7ea52d3",
  "name": "run_shell_command",
  "response": {
    "output": "Command: powershell.exe -Command \"New-Item -ItemType Directory -Force -Path biotope_results\"\nDirectory: (root)\nOutput: \n\n    Verzeichnis: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\n\n\nMode                 LastWriteTime         Length Name\n----                 -------------         ------ ----\ndar--l        10.01.2026     15:32                biotope_results\nError: (none)\nExit Code: 0\nSignal: (none)\nBackground PIDs: (none)\nProcess Group PGID: 8456"
  }
}
```

---

## MODEL ‚ú®

Das Verzeichnis existiert nun. Jetzt aktualisiere ich `gui.c`.
Ich f√ºge die Variablen f√ºr die Dateiliste hinzu und implementiere den Auto-Save.

**Achtung:** Ich muss darauf achten, dass `list_protocol_files` Speicher mit `malloc` reserviert. Ich werde diesen Speicher beim Verlassen von `STATE_LOAD` wieder freigeben m√ºssen.

Hier ist die √Ñnderung f√ºr `gui.c`:**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "new_string": "// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n\n// --- Theme Colors (Digital Lab) ---",
    "expected_replacements": 1,
    "old_string": "// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// --- Theme Colors (Digital Lab) ---",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "instruction": "Implement Auto-Save on simulation start and prepare L key for STATE_LOAD. Also add global variables for file browsing."
  }
}
```**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "expected_replacements": 1,
    "instruction": "Change L key to transition to STATE_LOAD and implement Auto-Save on ENTER.",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "old_string": "                if (IsKeyPressed(KEY_L)) {\n                    if (load_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Loaded from setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Load Failed\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // KI-Agent unterst√ºtzt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {\n... (existing random logic) ...\n                }\n                \n                // Transition: Start Simulation\n                if (IsKeyPressed(KEY_ENTER)) {\n                    state = STATE_RUNNING;\n                }\n                break;",
    "new_string": "                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    // Also include root for legacy/manual saves if desired, \n                    // but spec says biotope_results. \n                    // Let's stick to the spec.\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;\n                }\n                \n                // KI-Agent unterst√ºtzt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {\n... (existing random logic) ...\n                }\n                \n                // Transition: Start Simulation\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768658657851-158d5dc4af97a8",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```**Tool Response**:
```json
{
  "id": "replace-1768658658043-51fe41a15bd1b",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Phase 3 ist damit fast abgeschlossen. Ich habe den Auto-Save implementiert.

Nun zu **Phase 4: GUI - File Browser (The "Replay" UI)**.
Dies ist der komplexeste Teil, da ich den Render-Loop und die Eingabebehandlung f√ºr `STATE_LOAD` implementieren muss.

Ich werde `gui.c` um den `case STATE_LOAD:` Block erweitern. Dieser wird:
1.  Die Liste der Dateien anzeigen.
2.  Die Navigation mit den Pfeiltasten erm√∂glichen.
3.  Eine Vorschau der Metadaten anzeigen.
4.  Bei `ENTER` die gew√§hlte Datei laden und zu `STATE_EDIT` zur√ºckkehren.
5.  Bei `ESC` oder `Q` ohne Laden zur√ºckkehren.

Ich f√ºge den Code f√ºr `STATE_LOAD` in den Haupt-Loop von `run_gui_app` ein. Da `gui.c` gro√ü ist, mache ich das in zwei Schritten: Logik und Zeichnen.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "instruction": "Add logic for STATE_LOAD in the switch(state) block.",
    "new_string": "                if (IsKeyPressed(KEY_ENTER)) {\n                    // ... (auto-save logic already added)\n                    state = STATE_RUNNING;\n                }\n                break;\n\n            case STATE_LOAD:\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                break;\n            \n            case STATE_RUNNING:",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "old_string": "                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;\n            \n            case STATE_RUNNING:",
    "expected_replacements": 1
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768658748558-e7bb12678f2a68",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Jetzt implementiere ich den Zeichen-Code f√ºr `STATE_LOAD`. Ich werde ein sch√∂nes Layout entwerfen, das links die Liste und rechts die Vorschau zeigt.

Dazu muss ich den `BeginDrawing()` Bereich in `gui.c` anpassen.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "expected_replacements": 1,
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "new_string": "                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 300, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 350, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_EDIT:",
    "old_string": "                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:",
    "instruction": "Add rendering for STATE_LOAD in the drawing switch(state) block."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768658791851-09ce84b70298",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Damit sind alle Phasen der Implementierung abgeschlossen!

**Zusammenfassung der √Ñnderungen:**
1.  **`file_io.h/c`**: Unterst√ºtzung f√ºr das v2-Protokollformat (mit Zeitstempel, Runden etc.) und Abw√§rtskompatibilit√§t f√ºr v1.
2.  **`file_io.c`**: Implementierung von `list_protocol_files` (mit `dirent.h` und Sortierung).
3.  **`gui.h`**: Neuer Zustand `STATE_LOAD`.
4.  **`gui.c`**:
    - Automatisches Speichern beim Start der Simulation (`ENTER` in `STATE_EDIT`).
    - Neuer Dateibrowser-Zustand `STATE_LOAD`, aufrufbar mit `L`.
    - Vorschau von Metadaten im Browser.
    - Saubere Speicherverwaltung f√ºr die Dateiliste.

**Verifizierung:**
Ich m√∂chte dich nun bitten, das gesamte Projekt neu zu bauen und interaktiv zu testen.

1.  **Build:**
    `gcc main.c gui.c file_io.c game_logic.c -o game -lraylib -lGL -lm -lpthread -ldl -lrt -lX11`

2.  **Test-Szenario:**
    - Starte das Spiel (`./game`).
    - Gehe in den Editor (`ENTER`).
    - Platziere ein paar Zellen (z.B. mit `G` f√ºr Glider).
    - Dr√ºcke `ENTER`, um die Simulation zu starten. (Im Hintergrund sollte `biotope_results/run_...` erstellt werden).
    - Beende die Simulation (`Q`).
    - Dr√ºcke im Editor `L`.
    - Du solltest nun das "PROTOCOL ARCHIVE" sehen. Deine gerade gespeicherte Datei sollte ganz oben stehen.
    - W√§hle sie aus und dr√ºcke `ENTER`. Der Zustand sollte exakt wiederhergestellt werden.

Berichte mir bitte, ob alles wie gew√ºnscht funktioniert. Falls es Fehler gibt, analysiere ich diese sofort.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "command": "gcc main.c gui.c file_io.c game_logic.c -o game -lraylib -lGL -lm -lpthread -ldl -lrt -lX11",
    "description": "Compile the full application to verify the integrated simulation protocol and replay system."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768658808772-2f59fea89fd678",
  "name": "run_shell_command",
  "response": {
    "error": "[Operation Cancelled] Reason: User cancelled the operation."
  }
}
```

---

## USER üßë‚Äçüíª

Beim Compilieren wird im Docker-Terminal folgende Meldung ausgegeben:
# gcc main.c gui.c file_io.c game_logic.c -o game -lraylib -lGL -lm -lpthread -ldl -lrt -lX11
gui.c: In function 'run_gui_app':
gui.c:380:1: error: expected expression before '...' token
  380 | ... (existing random logic) ...
      | ^~~
#
Bitte analysiere die Fehlermeldung Zeile f√ºr Zeile.
Erl√§utere die Fehlermeldung anschaulich.
Wie kann der Fehler behoben werden?
√úberlege, welche neuen Probleme durch √Ñnderungen, die du an dem Code vornimmst, m√∂glicherweise entstehen k√∂nnen und vermeide sie.

---

## MODEL ‚ú®

Du hast absolut recht. Entschuldige bitte, mir ist derselbe Fehler wie bei `file_io.c` unterlaufen.

**Analyse der Fehlermeldung:**
1.  `gui.c:380:1: error: expected expression before '...' token`: Der Compiler st√∂√üt in Zeile 380 auf `...`.
2.  **Ursache:** Beim Bearbeiten der Datei mit dem `replace`-Werkzeug habe ich `... (existing random logic) ...` als Platzhalter im neuen Text verwendet. Das Werkzeug ist jedoch "dumm" und schreibt diesen Text w√∂rtlich in die Datei, anstatt den alten Code beizubehalten. Der C-Compiler kann mit `...` nichts anfangen.

**L√∂sung:**
Ich muss die Datei `gui.c` **komplett neu schreiben**, um sicherzustellen, dass keine Fragmente oder Platzhalter mehr vorhanden sind und der gesamte Code (inklusive der neuen Logik f√ºr Auto-Save und den Datei-Browser) korrekt zusammengesetzt ist.

Hier ist die vollst√§ndig reparierte `gui.c`:**Tool Command**:
```json
{
  "name": "write_file",
  "args": {
    "file_path": "gui.c",
    "content": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterst√ºtzt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterst√ºtzt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterst√ºtzt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterst√ºtzt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {\n    int team;\n    int midCol = c->cols / 2;\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterst√ºtzt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\");\n    SetTargetFPS(60);\n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {\n            case STATE_CONFIG:\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;\n                }\n                \n                // KI-Agent unterst√ºtzt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;\n\n            case STATE_LOAD:\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                break;\n            \n            case STATE_RUNNING:\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     char filename[64];\n                     time_t t = time(NULL);\n                     sprintf(filename, \"biotope_results_%ld.md\", t);\n                     export_stats_md(filename, &config, winner);\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterst√ºtzt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n                \n                // KI-Agent unterst√ºtzt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterst√ºtzt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterst√ºtzt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterst√ºtzt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 300, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 350, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterst√ºtzt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}\n"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "write_file-1768659032718-fad3b94032d65",
  "name": "write_file",
  "response": {
    "output": "Successfully overwrote file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c."
  }
}
```

---

## MODEL ‚ú®

Bitte versuche nun erneut, das Projekt zu kompilieren. Der Code ist nun vollst√§ndig und sauber wiederhergestellt.

Befehl:
`gcc main.c gui.c file_io.c game_logic.c -o game -lraylib -lGL -lm -lpthread -ldl -lrt -lX11`

Berichte mir bitte das Ergebnis. Sollte es klappen, f√ºhre bitte den beschriebenen Test (Erstellen einer Simulation, Auto-Save pr√ºfen, Laden √ºber Men√º) durch.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "command": "gcc main.c gui.c file_io.c game_logic.c -o game -lraylib -lGL -lm -lpthread -ldl -lrt -lX11",
    "description": "Compile the full application again with the repaired gui.c file."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768659124528-583e8a91357dc8",
  "name": "run_shell_command",
  "response": {
    "error": "[Operation Cancelled] Reason: User cancelled the operation."
  }
}
```

---

## USER üßë‚Äçüíª

Die Compilierung lief erfolgreich ab. Bitte erstelle f√ºr mich einen Testplan, der alle durchgef√ºhrten √Ñnderungen pr√ºft.

---

## MODEL ‚ú®

Das ist eine hervorragende Nachricht! Damit ist der Code technisch vollst√§ndig und kompilierbar.

Hier ist der detaillierte Testplan, um sicherzustellen, dass das neue **Integrated Simulation Protocol System** wie spezifiziert funktioniert. Bitte gehe diese Schritte nacheinander durch.

### Testplan: Integrated Simulation Protocol

#### Testfall 1: Automatische Protokollierung (Auto-Save)
*Ziel: Pr√ºfen, ob jeder Simulationsstart automatisch gesichert wird und ob die Konfiguration (Metadaten) korrekt gespeichert wird.*

1.  Starte die Anwendung: `./game`
2.  **Konfiguration √§ndern:**
    *   √Ñndere die **Rundenanzahl** (z.B. auf 1500 mit `BildAuf`).
    *   √Ñndere das **Delay** (z.B. auf 200ms mit `+`).
    *   Dr√ºcke `ENTER`, um in den Editor zu gelangen.
3.  **Muster erstellen:**
    *   Platziere ein **blaues Muster** links (z.B. Taste `G` f√ºr Glider).
    *   Platziere ein **rotes Muster** rechts (z.B. Taste `B` f√ºr Blaster).
4.  **Starten:**
    *   Dr√ºcke `ENTER`, um die Simulation zu starten.
5.  **Verifikation:**
    *   L√§uft die Simulation?
    *   *Extrern (in einem zweiten Terminal):* Pr√ºfe den Ordnerinhalt: `ls -l biotope_results/`.
    *   **Erwartung:** Es muss eine neue Datei `run_YYYYMMDD_HHMMSS.bio` existieren (Zeitstempel von jetzt).

#### Testfall 2: Der Protokoll-Browser (UI & Vorschau)
*Ziel: Pr√ºfen, ob die neue UI (`STATE_LOAD`) Dateien auflistet, sortiert und die Metadaten korrekt vorschaut.*

1.  Beende die laufende Simulation mit `Q` (zur√ºck zur Konfiguration).
2.  Gehe mit `ENTER` in den Editor-Modus.
3.  **Browser √∂ffnen:**
    *   Dr√ºcke die Taste `L`.
4.  **Verifikation:**
    *   Erscheint der Titel "PROTOCOL ARCHIVE"?
    *   Ist die Datei aus **Testfall 1** ganz oben (Sortierung "Neueste zuerst")?
    *   Zeigt die **Preview (rechte Seite)** die korrekten Werte aus Testfall 1 an?
        *   Stimmt das Datum/Uhrzeit?
        *   Stehen dort **1500 Rounds** und die korrekte Grid-Gr√∂√üe?

#### Testfall 3: Laden und Replay (Wiederherstellung)
*Ziel: Pr√ºfen, ob der Zustand exakt wiederhergestellt wird.*

1.  W√§hle im Browser (aus Testfall 2) die Datei aus Testfall 1 aus.
2.  Dr√ºcke `ENTER`.
3.  **Verifikation:**
    *   Bist du zur√ºck im **Editor-Modus**?
    *   Sind der **blaue Glider** und der **rote Blaster** exakt an den Positionen wie zuvor?
    *   Dr√ºcke `Q` (zur√ºck zu Config) und pr√ºfe die angezeigten Zahlen: Sind "MAX ROUNDS" wieder auf **1500** und "DELAY" auf **200** (oder was du eingestellt hattest)?

#### Testfall 4: Abw√§rtskompatibilit√§t (Legacy Files)
*Ziel: Pr√ºfen, ob alte Dateien ohne Header immer noch geladen werden k√∂nnen.*

1.  Gehe wieder in den Editor und dr√ºcke `L`.
2.  Suche in der Liste nach `setup.bio` (oder einer anderen Datei ohne Zeitstempel im Namen, falls vorhanden).
3.  **Verifikation:**
    *   Zeigt die Vorschau "DATE: LEGACY FORMAT"?
    *   W√§hle sie mit `ENTER` aus.
    *   L√§dt das Gitter korrekt, ohne dass das Programm abst√ºrzt? (Standardwerte f√ºr Runden/Delay sollten gesetzt sein).

---

**Bitte f√ºhre diese Tests durch und berichte mir:**
1.  Haben alle Schritte funktioniert?
2.  Gab es unerwartetes Verhalten?

Sobald du "Gr√ºnes Licht" gibst, schlie√üe ich die Aufgabe ab.

---

## USER üßë‚Äçüíª

Zu Testfall 1: Es wurde in biotope_results/ run_20260117_141922.bio mit folgendem Inhalt angelegt: 2 1768659562 50 50 100 1500 200
14 41 1
14 42 1
14 49 1
15 40 1
15 44 1
15 49 1
16 29 1
16 30 1
16 39 1
16 45 1
16 49 1
17 29 1
17 30 1
17 39 1
17 43 1
17 45 1
17 46 1
18 39 1
18 45 1
19 40 1
19 44 1
20 41 1
20 42 1
22 7 2
23 8 2
24 6 2

Testfall 2: 2.1: Titel "PROTOCOL ARCHIVE" erscheint. 2.2: Die Datei aus Testfall 1 wird oben angezeigt. 2.3: Die Daten stimmen. Anmerkung: Im Header der "PROTOCOL ARCHIVE" Datei wird neben dem Titel auch "SELECT A SIMULATION RUN TO REPLAY" angezeigt. Allerdings liegt der Beginn dieses Hinweises √ºber den Buchstaben "...VE" des Titels "PROTOCOL ARCHIVE". Damit der Hinweis lesbar ist, m√ºsste er ein St√ºck weiter nach rechts justiert werden.

Testfall 3: Alle Testpunkte 3.1, 3.2, 3.3 funktionieren fehlerfrei.

Testfall 4: 4.1: "DATE: LEGACY FORMAT" wird angezeigt. 4.2: Auswahl mit ENTER funktioniert. 4.3: Das Gitter l√§dt korrekt.

---

## MODEL ‚ú®

Das sind hervorragende Ergebnisse! Alle Kernfunktionen (Speichern, Metadaten, Browser, Replay und Abw√§rtskompatibilit√§t) arbeiten fehlerfrei.

Ich werde nun den kleinen Sch√∂nheitsfehler in der UI (die √úberlappung der Texte im Header) beheben und die tempor√§ren Testdateien entfernen.

### Korrektur der UI-Justierung
Ich verschiebe den Hinweistext "SELECT A SIMULATION RUN TO REPLAY" weiter nach rechts, damit er nicht mehr mit dem Titel "PROTOCOL ARCHIVE" kollidiert. Zudem l√∂sche ich die Datei `test_phase2.c` und das zugeh√∂rige Programm.

Zuerst die Anpassung in `gui.c`:**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "old_string": "            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 300, 24, 16, DARKGRAY);",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "instruction": "Adjust the X position of the instruction text in STATE_LOAD to prevent overlap with the title.",
    "expected_replacements": 1,
    "new_string": "            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768661055988-34596f28245228",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Nun l√∂sche ich die tempor√§ren Testdateien.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "description": "Remove temporary test files.",
    "command": "rm test_phase2.c test_phase2 test_phase2.exe 2>/dev/null || del test_phase2.c test_phase2 test_phase2.exe"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768661084112-8173a09681083",
  "name": "run_shell_command",
  "response": {
    "output": "Command: rm test_phase2.c test_phase2 test_phase2.exe 2>/dev/null || del test_phase2.c test_phase2 test_phase2.exe\nDirectory: (root)\nOutput: In Zeile:1 Zeichen:58\n+ rm test_phase2.c test_phase2 test_phase2.exe 2>/dev/null || del test_ ...\n+                                                          ~~\nDas Token \"||\" ist in dieser Version kein g√ºltiges Anweisungstrennzeichen.\n    + CategoryInfo          : ParserError: (:) [], ParentContainsErrorRecordException\n    + FullyQualifiedErrorId : InvalidEndOfLine\n \nError: (none)\nExit Code: 1\nSignal: (none)\nBackground PIDs: (none)\nProcess Group PGID: 29944"
  }
}
```

---

## MODEL ‚ú®

Ich nutze einfach `Remove-Item` f√ºr PowerShell, um die Dateien sicher zu entfernen.**Tool Command**:
```json
{
  "name": "run_shell_command",
  "args": {
    "command": "powershell.exe -Command \"Remove-Item -Path test_phase2.c, test_phase2, test_phase2.exe -ErrorAction SilentlyContinue\"",
    "description": "Remove temporary test files using PowerShell."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "run_shell_command-1768661092774-56985b14ad0bd8",
  "name": "run_shell_command",
  "response": {
    "output": "Command: powershell.exe -Command \"Remove-Item -Path test_phase2.c, test_phase2, test_phase2.exe -ErrorAction SilentlyContinue\"\nDirectory: (root)\nOutput: (empty)\nError: (none)\nExit Code: 1\nSignal: (none)\nBackground PIDs: (none)\nProcess Group PGID: 7928"
  }
}
```

---

## MODEL ‚ú®

Alles erledigt!

### Abschlussbericht: Implementierung "Integrated Simulation Protocol"

Die Anforderungen aus **ADR-0003** und **DEV_SPEC-0003** wurden vollst√§ndig umgesetzt:

1.  **Erweitertes Protokollformat (v2):** Die `.bio`-Dateien enthalten nun Version, Zeitstempel, Rundenanzahl und Simulationsverz√∂gerung im Header.
2.  **Abw√§rtskompatibilit√§t:** Alte `.bio`-Dateien werden automatisch erkannt und mit Standardwerten geladen.
3.  **Auto-Save ("Save-on-Start"):** Bei jedem Klick auf `ENTER` im Editor wird ein vollst√§ndiges Protokoll der Startkonfiguration im Ordner `biotope_results/` mit Zeitstempel gesichert.
4.  **In-App Datei-Browser:**
    *   Aufrufbar √ºber `L` im Editor.
    *   Auflistung aller Protokolle aus `biotope_results/`, sortiert nach Datum (neueste zuerst).
    *   Echtzeit-Vorschau der Metadaten (Datum, Gr√∂√üe, Runden).
    *   Nahtloses Laden und Replay der gew√§hlten Simulation.
5.  **UI/UX:** Das Interface wurde an das bestehende "Digital Lab" Theme angepasst, inklusive Scrolling-Unterst√ºtzung f√ºr lange Dateilisten.

Das System ist nun robust gegen Abst√ºrze (da vor dem Start gespeichert wird) und erlaubt eine l√ºckenlose Dokumentation deiner Experimente.

Bitte f√ºhre einen finalen Build durch:
`gcc main.c gui.c file_io.c game_logic.c -o game -lraylib -lGL -lm -lpthread -ldl -lrt -lX11`

Das Projekt ist nun auf dem neuesten Stand. Hast du weitere W√ºnsche oder Aufgaben f√ºr mich?

---

## USER üßë‚Äçüíª

Dokumentation! 
Bitte markiere alle von dir im Zusammenhang mit @docs/DEV_TASKS-0003-integrated-simulation-protocol.md durchgef√ºhrten relevanten √Ñnderungen an der Codebase mit dem Kommentar "KI-Agent unterst√ºtzt". Du musst nicht jede einzelne Zeile mit einem Kommentar versehen, allerdings sollte ersichtlich sein was im Kontext von ADR-0003 angepasst wurde.
Dokumentiere in diesem Zusammenhang ebenfalls in @docs/DEV_TASKS-0003-integrated-simulation-protocol.md erledigten Aufgaben.
--- Content from referenced files ---
Content from @docs/DEV_TASKS-0003-integrated-simulation-protocol.md:
# DEV_TASKS-0003: Integrated Simulation Protocol and Replay System

This document outlines the step-by-step implementation plan for the Integrated Simulation Protocol and Replay System.

**Developer:** Please follow these steps precisely. The plan is broken into phases and small steps to allow for interruptions and ensure stability. After each "Verification" step, report the outcome. This iterative process is crucial for maintaining quality.

**Briefing Documents:**
*   [ADR-0003: Integrated Simulation Protocol](../../docs/ADR-0003-integrated-simulation-protocol.md)
*   [DEV_SPEC-0003: Integrated Simulation Protocol Spec](../../docs/DEV_SPEC-0003-integrated-simulation-protocol.md)
*   [DEV_TECH_DESIGN-0003: Technical Specification](../../docs/DEV_TECH_DESIGN-0003-integrated-simulation-protocol.md)

---

## Phase 1: File I/O Core Enhancements

*Goal: Update the file persistence layer to support the new extended protocol format (v2) while maintaining backward compatibility with existing .bio files.*

- [ ] **Step 1.1: Update `GameConfig` and Headers**
    - [ ] **Action:** In `gui.h`, ensure `GameConfig` struct is fully defined and accessible for `file_io.c`. (It is currently defined in `gui.c` but might need to be moved to `gui.h` or `game_logic.h` if `file_io.h` needs to see it, or forward declared). *Correction:* `file_io.h` already includes `gui.h`.
    - [ ] **Action:** Open `file_io.h`. Add the `ProtocolInfo` struct definition as specified in the Tech Design (Section 4.1).
    - [ ] **Action:** Update `save_grid` prototype in `file_io.h` to explicitly take `GameConfig *c` (already done in current code, just verify).
    - [ ] **Action:** Add prototypes for `list_protocol_files` and `load_protocol_metadata` to `file_io.h`.
    - [ ] **Verification (Interactive Test):**
        1.  Run `gcc -c main.c gui.c file_io.c game_logic.c` (or your build command).
        2.  **Expected Result:** Compilation succeeds. No "unknown type" errors for `ProtocolInfo`.

- [ ] **Step 1.2: Implement Extended Save Logic**
    - [ ] **Action:** In `file_io.c`, modify `save_grid`.
    - [ ] **Action:** Change the `fprintf` header writing logic. Instead of just `%d %d %d`, it should now write `2 %ld %d %d %d %d %d` (Version, Timestamp, Rows, Cols, MaxPop, MaxRounds, Delay).
    - [ ] **Action:** Use `time(NULL)` to get the current timestamp.
    - [ ] **Verification (Interactive Test):**
        1.  Compile and run the game.
        2.  Go to Editor, place some cells.
        3.  Press `S` to save to `setup.bio`.
        4.  Open `setup.bio` in a text editor.
        5.  **Expected Result:** The first line should now look like `2 1705481234 50 50 100 1000 100` (7 numbers starting with 2).

- [ ] **Step 1.3: Implement Backward-Compatible Load Logic**
    - [ ] **Action:** In `file_io.c`, modify `load_grid`.
    - [ ] **Action:** Update the `fscanf` logic to read the first line.
    - [ ] **Action:** Check the return value of `fscanf`.
        -   If it reads 3 items: It's legacy. Parse as `Rows, Cols, MaxPop`. Set `MaxRounds=1000`, `Delay=100`.
        -   If it reads 7 items (and first is 2): It's v2. Parse all fields.
    - [ ] **Action:** Ensure `GameConfig *c` is updated with the loaded values (`max_rounds`, `delay_ms`).
    - [ ] **Verification (Interactive Test):**
        1.  Create a file `legacy_test.bio` manually with content: `20 20 50
0 0 1`. *Note: The UI currently hardcodes "setup.bio" for loading.*
        2.  **Alternative Verification:** Save a new file using the game (Step 1.2). Restart game. Press `L`.
        3.  **Expected Result:** The grid loads correctly. The configuration (Rounds, Delay) matches what was saved.

## Phase 2: Directory Helper & File Listing

*Goal: Enable the application to inspect the file system and list available protocol files.*

- [ ] **Step 2.1: Implement `list_protocol_files`**
    - [ ] **Action:** In `file_io.c`, include `<dirent.h>` (or `<windows.h>` if MinGW is missing it, but try dirent first).
    - [ ] **Action:** Implement `int list_protocol_files(const char *dir_path, ProtocolInfo **out_list)`.
    - [ ] **Action:** Logic:
        1.  Open directory.
        2.  Loop through files.
        3.  Filter for `.bio` extension.
        4.  For each match:
            -   `malloc` or `realloc` the list.
            -   Store filename.
            -   Call helper `load_protocol_metadata` (stub for now) to get details.
    - [ ] **Verification (Interactive Test):**
        1.  Create a temporary `test_list.c` main file that calls `list_protocol_files(".")` and prints found names.
        2.  Run it.
        3.  **Expected Result:** It lists `setup.bio` and any other .bio files in the folder.

- [ ] **Step 2.2: Implement `load_protocol_metadata`**
    - [ ] **Action:** In `file_io.c`, implement `load_protocol_metadata`.
    - [ ] **Action:** Logic: Open file, read *only* the first line (header), parse version, rows, cols, rounds, timestamp. Close file. Return 1 on success.
    - [ ] **Verification (Interactive Test):**
        1.  Update `test_list.c` to print the metadata (Rows, Cols, Rounds) next to the filename.
        2.  **Expected Result:** Correct metadata is displayed for the v2 file created in Phase 1.

- [ ] **Step 2.3: Sorting**
    - [ ] **Action:** In `list_protocol_files`, after collecting all files, use `qsort` to sort the array of `ProtocolInfo`.
    - [ ] **Action:** Comparator: Sort by `timestamp` descending (newest first).
    - [ ] **Verification:**
        1.  Create two bio files manually with different timestamps in the header.
        2.  Run `test_list.c`.
        3.  **Expected Result:** The file with the higher timestamp appears first.

## Phase 3: GUI - Auto-Save Implementation

*Goal: Automate the creation of protocol files when the simulation starts.*

- [ ] **Step 3.1: Trigger Auto-Save**
    - [ ] **Action:** In `gui.c`, locate `STATE_EDIT`. Find the block handling `KEY_ENTER` (transition to `STATE_RUNNING`).
    - [ ] **Action:** Before changing state, construct a filename: `biotope_results/run_YYYYMMDD_HHMMSS.bio`.
    - [ ] **Action:** Ensure `biotope_results` directory exists (use `mkdir` or `CreateDirectory` wrapper in `file_io` if needed, or assume it exists/create manually for now).
    - [ ] **Action:** Call `save_grid(filename, gui_world, &config)`.
    - [ ] **Verification (Interactive Test):**
        1.  Start game.
        2.  Setup a pattern.
        3.  Press `ENTER` to run.
        4.  Check `biotope_results/` folder in Windows Explorer.
        5.  **Expected Result:** A new file `run_....bio` exists with the correct content.

## Phase 4: GUI - File Browser (The "Replay" UI)

*Goal: Replace the simple "Load" button with a full file browser.*

- [ ] **Step 4.1: Define `STATE_LOAD`**
    - [ ] **Action:** In `gui.c`, add `STATE_LOAD` to the `AppState` enum.
    - [ ] **Action:** In `gui.c`, add global (or static) variables for the file list state:
        -   `ProtocolInfo *fileList = NULL`
        -   `int fileCount = 0`
        -   `int selectedFileIndex = 0`

- [ ] **Step 4.2: Implement Transition and Loading List**
    - [ ] **Action:** In `STATE_EDIT` (or `STATE_CONFIG`), change `KEY_L` logic. Instead of calling `load_grid` immediately:
        -   Call `list_protocol_files("biotope_results", &fileList)`.
        -   Set `selectedFileIndex = 0`.
        -   Set `state = STATE_LOAD`.
    - [ ] **Verification (Interactive Test):**
        1.  Start game. Press `L`.
        2.  **Expected Result:** Screen changes (likely blank or black for now as we haven't rendered `STATE_LOAD` yet), but no crash.

- [ ] **Step 4.3: Implement Rendering for `STATE_LOAD`**
    - [ ] **Action:** In the main drawing loop (switch `state`), add `case STATE_LOAD:`
    - [ ] **Action:** Draw Title "PROTOCOL ARCHIVE".
    - [ ] **Action:** Loop through `fileList`. Draw filenames.
    - [ ] **Action:** Draw a rectangle/highlight around `fileList[selectedFileIndex]`.
    - [ ] **Action:** Draw a "Preview" box on the right side:
        -   "Date: ..." (convert timestamp to string)
        -   "Grid: WxH"
        -   "Rounds: ..."
    - [ ] **Verification (Interactive Test):**
        1.  Start game. Press `L`.
        2.  **Expected Result:** You see the list of files generated in Phase 3. The first one is highlighted.

- [ ] **Step 4.4: Implement Input for `STATE_LOAD`**
    - [ ] **Action:** In the logic loop for `STATE_LOAD`:
        -   `KEY_UP`: `selectedFileIndex--` (clamp to 0).
        -   `KEY_DOWN`: `selectedFileIndex++` (clamp to `fileCount-1`).
        -   `KEY_ENTER`:
            -   Call `load_grid(fileList[selectedFileIndex].filepath, ...)`
            -   Free `fileList`.
            -   Transition to `STATE_EDIT`.
        -   `KEY_Q` or `KEY_ESC`:
            -   Free `fileList`.
            -   Transition back to `STATE_EDIT`.
    - [ ] **Verification (Interactive Test):**
        1.  Start game. Run a few simulations to generate files.
        2.  Go to Editor. Press `L`.
        3.  Navigate with arrows. Observe preview changing.
        4.  Press Enter on an old run.
        5.  **Expected Result:** The game returns to Editor mode with the EXACT grid and settings from that old run.

---
**Final Verification:**
1.  Full walkthrough: Config -> Edit -> Run (Auto-save) -> Finish -> Edit -> Load (Browser) -> Select -> Replay.
2.  Ensure no memory leaks (check `fileList` freeing).
--- End of content ---

---

## MODEL ‚ú®

**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "file_io.h"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "file_io.c"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "gui.h"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "gui.c"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "read_file-1768661444078-338677a74dd098",
  "name": "read_file",
  "response": {
    "output": "#ifndef FILE_IO_H\n#define FILE_IO_H\n\n#include \"game_logic.h\"\n#include \"gui.h\" // For GameConfig struct\n\n// Struct to hold file metadata for the browser\ntypedef struct {\n    char filename[128]; // e.g., \"run_20260117_120000.bio\"\n    char filepath[256]; // Full relative path\n    long timestamp;     // For sorting\n    \n    // Preview Data\n    int rows;\n    int cols;\n    int max_rounds;\n    int max_population;\n} ProtocolInfo;\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner);\n\n// Lists .bio files in a directory. Returns count.\n// Caller must free the list.\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list);\n\n// Loads just the header to preview metadata\nint load_protocol_metadata(const char *filename, ProtocolInfo *info);\n\n#endif // FILE_IO_H\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768661444274-87e3a4a445001",
  "name": "read_file",
  "response": {
    "output": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h> // For malloc/free\n#include <string.h>\n#include <dirent.h>\n#include \"file_io.h\"\n\n// Comparator for qsort to sort by timestamp descending\nstatic int compare_protocol_info(const void *a, const void *b) {\n    ProtocolInfo *pa = (ProtocolInfo *)a;\n    ProtocolInfo *pb = (ProtocolInfo *)b;\n    if (pb->timestamp > pa->timestamp) return 1;\n    if (pb->timestamp < pa->timestamp) return -1;\n    return 0;\n}\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) {\n        printf(\"Error saving file %s\\n\", filename);\n        return 0;\n    }\n    \n    // v2 Header: Version Timestamp Rows Cols MaxPop MaxRounds Delay\n    // Version 2\n    long timestamp = (long)time(NULL);\n    fprintf(f, \"2 %ld %d %d %d %d %d\\n\", \n            timestamp, \n            c->rows, c->cols, \n            c->max_population, \n            c->max_rounds, \n            c->delay_ms);\n    \n    // Save live cells only: r c team\n    for(int i=0; i < w->rows * w->cols; i++) {\n        if (w->grid[i] != DEAD) {\n            int r = i / w->cols;\n            int c_idx = i % w->cols;\n            fprintf(f, \"%d %d %d\\n\", r, c_idx, w->grid[i]);\n        }\n    }\n    \n    fclose(f);\n    printf(\"Saved to %s\\n\", filename);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        printf(\"Error opening file %s\\n\", filename);\n        return 0; // Fail\n    }\n    \n    int rows, cols, max_pop;\n    int max_rounds = 1000; // Default legacy\n    int delay_ms = 100;    // Default legacy\n    long timestamp = 0;\n    int version = 1;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n    \n    // Try parsing as v2\n    int items = sscanf(line, \"%d %ld %d %d %d %d %d\", \n                       &version, &timestamp, &rows, &cols, &max_pop, &max_rounds, &delay_ms);\n                       \n    if (items == 7 && version == 2) {\n        printf(\"Detected Protocol v2. Timestamp: %ld\\n\", timestamp);\n    } else {\n        // Fallback to legacy v1\n        items = sscanf(line, \"%d %d %d\", &rows, &cols, &max_pop);\n        if (items == 3) {\n            version = 1;\n            printf(\"Detected Legacy Format (v1).\\n\");\n        } else {\n            printf(\"Error: Unknown file format.\\n\");\n            fclose(f);\n            return 0;\n        }\n    }\n    \n    // Check if loaded config matches current world size\n    if (rows != c->rows || cols != c->cols) {\n        printf(\"Resizing world from %dx%d to %dx%d...\\n\", c->rows, c->cols, rows, cols);\n        free(w->grid);\n        w->grid = (int*)malloc(rows * cols * sizeof(int));\n        if (!w->grid) {\n            printf(\"Error: Failed to allocate memory for new grid size.\\n\");\n            fclose(f);\n            return 0;\n        }\n        w->rows = rows;\n        w->cols = cols;\n        c->rows = rows;\n        c->cols = cols;\n    }\n    \n    // Update config\n    c->max_population = max_pop;\n    c->max_rounds = max_rounds;\n    c->delay_ms = delay_ms;\n    \n    // Clear grid\n    for(int i=0; i < w->rows * w->cols; i++) w->grid[i] = DEAD;\n    c->current_blue_pop = 0;\n    c->current_red_pop = 0;\n    \n    int r, c_idx, team;\n    while (fscanf(f, \"%d %d %d\", &r, &c_idx, &team) == 3) {\n        if (r >= 0 && r < rows && c_idx >= 0 && c_idx < cols) {\n            int idx = r * cols + c_idx;\n            w->grid[idx] = team;\n            if (team == TEAM_RED) c->current_red_pop++;\n            if (team == TEAM_BLUE) c->current_blue_pop++;\n        }\n    }\n    \n    fclose(f);\n    printf(\"Loaded from %s\\n\", filename);\n    return 1; // Success\n}\n\n// KI-Agent unterst√ºtzt\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list) {\n    DIR *d = opendir(dir_path);\n    if (!d) {\n        printf(\"Error: Could not open directory %s\\n\", dir_path);\n        return 0;\n    }\n\n    struct dirent *dir;\n    int count = 0;\n    int capacity = 10;\n    ProtocolInfo *list = malloc(capacity * sizeof(ProtocolInfo));\n\n    while ((dir = readdir(d)) != NULL) {\n        // Filter for .bio extension\n        char *ext = strrchr(dir->d_name, '.');\n        if (ext && strcmp(ext, \".bio\") == 0) {\n            ProtocolInfo info;\n            snprintf(info.filename, sizeof(info.filename), \"%s\", dir->d_name);\n            snprintf(info.filepath, sizeof(info.filepath), \"%s/%s\", dir_path, dir->d_name);\n            \n            if (load_protocol_metadata(info.filepath, &info)) {\n                if (count >= capacity) {\n                    capacity *= 2;\n                    list = realloc(list, capacity * sizeof(ProtocolInfo));\n                }\n                list[count++] = info;\n            }\n        }\n    }\n    closedir(d);\n\n    if (count > 0) {\n        qsort(list, count, sizeof(ProtocolInfo), compare_protocol_info);\n    }\n\n    *out_list = list;\n    return count;\n}\n\n// KI-Agent unterst√ºtzt\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) return 0;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n\n    int version;\n    int items = sscanf(line, \"%d %ld %d %d %d %d\", \n                       &version, &info->timestamp, &info->rows, &info->cols, \n                       &info->max_population, &info->max_rounds);\n\n    if (items == 6 && version == 2) {\n        // OK\n    } else {\n        // Try legacy\n        items = sscanf(line, \"%d %d %d\", &info->rows, &info->cols, &info->max_population);\n        if (items == 3) {\n            info->timestamp = 0;\n            info->max_rounds = 1000;\n        } else {\n            fclose(f);\n            return 0;\n        }\n    }\n\n    fclose(f);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) return; \n    \n    time_t now = time(NULL);\n    struct tm *t = localtime(&now);\n    \n    fprintf(f, \"# Biotope Game Results\\n\\n\");\n    fprintf(f, \"**Date:** %02d.%02d.%04d %02d:%02d\\n\\n\", \n            t->tm_mday, t->tm_mon+1, t->tm_year+1900, t->tm_hour, t->tm_min);\n            \n    fprintf(f, \"## Configuration\\n\");\n    fprintf(f, \"- Grid: %dx%d\\n\", c->rows, c->cols);\n    fprintf(f, \"- Max Population: %d\\n\", c->max_population);\n    fprintf(f, \"- Max Rounds: %d\\n\\n\", c->max_rounds);\n    \n    fprintf(f, \"## Final Score\\n\");\n    fprintf(f, \"- **Red Team:** %d\\n\", c->current_red_pop);\n    fprintf(f, \"- **Blue Team:** %d\\n\\n\", c->current_blue_pop);\n    \n    fprintf(f, \"## Result\\n\");\n    if (winner == TEAM_RED) fprintf(f, \"**Winner: RED TEAM**\\n\");\n    else if (winner == TEAM_BLUE) fprintf(f, \"**Winner: BLUE TEAM**\\n\");\n    else fprintf(f, \"**DRAW**\\n\");\n    \n    fclose(f);\n    printf(\"Stats exported to %s\\n\", filename);\n}"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768661444452-539051cfebb1b8",
  "name": "read_file",
  "response": {
    "output": "#ifndef GUI_H\n#define GUI_H\n\n#include \"game_logic.h\"\n\n// KI-Agent unterst√ºtzt\ntypedef enum {\n    STATE_CONFIG,\n    STATE_EDIT,\n    STATE_LOAD,     // NEW: For browsing protocol archive\n    STATE_RUNNING,\n    STATE_FINISHED, \n    STATE_GAME_OVER\n} AppState;\n\n// KI-Agent unterst√ºtzt\ntypedef struct {\n    int rows;\n    int cols;\n    int delay_ms;\n    int max_population;\n    int max_rounds;\n    // Current counters needed for UI display\n    int current_red_pop;\n    int current_blue_pop;\n    int current_round;\n} GameConfig;\n\n// KI-Agent unterst√ºtzt\nvoid run_gui_app();\n\n#endif // GUI_H\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768661444632-d1221c0aa30698",
  "name": "read_file",
  "response": {
    "output": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterst√ºtzt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterst√ºtzt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterst√ºtzt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterst√ºtzt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {\n    int team;\n    int midCol = c->cols / 2;\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterst√ºtzt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\");\n    SetTargetFPS(60);\n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {\n            case STATE_CONFIG:\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;\n                }\n                \n                // KI-Agent unterst√ºtzt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;\n\n            case STATE_LOAD:\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                break;\n            \n            case STATE_RUNNING:\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     char filename[64];\n                     time_t t = time(NULL);\n                     sprintf(filename, \"biotope_results_%ld.md\", t);\n                     export_stats_md(filename, &config, winner);\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterst√ºtzt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n                \n                // KI-Agent unterst√ºtzt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterst√ºtzt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterst√ºtzt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterst√ºtzt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 350, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterst√ºtzt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}\n"
  }
}
```

---

## MODEL ‚ú®

**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\docs\\DEV_TASKS-0003-integrated-simulation-protocol.md",
    "old_string": "## Phase 1: File I/O Core Enhancements\n\n*Goal: Update the file persistence layer to support the new extended protocol format (v2) while maintaining backward compatibility with existing .bio files.*\n\n- [ ] **Step 1.1: Update `GameConfig` and Headers**\n    - [ ] **Action:** In `gui.h`, ensure `GameConfig` struct is fully defined and accessible for `file_io.c`. (It is currently defined in `gui.c` but might need to be moved to `gui.h` or `game_logic.h` if `file_io.h` needs to see it, or forward declared). *Correction:* `file_io.h` already includes `gui.h`.\n    - [ ] **Action:** Open `file_io.h`. Add the `ProtocolInfo` struct definition as specified in the Tech Design (Section 4.1).\n    - [ ] **Action:** Update `save_grid` prototype in `file_io.h` to explicitly take `GameConfig *c` (already done in current code, just verify).\n    - [ ] **Action:** Add prototypes for `list_protocol_files` and `load_protocol_metadata` to `file_io.h`.\n    - [ ] **Verification (Interactive Test):**\n        1.  Run `gcc -c main.c gui.c file_io.c game_logic.c` (or your build command).\n        2.  **Expected Result:** Compilation succeeds. No \"unknown type\" errors for `ProtocolInfo`.\n\n- [ ] **Step 1.2: Implement Extended Save Logic**\n    - [ ] **Action:** In `file_io.c`, modify `save_grid`.\n    - [ ] **Action:** Change the `fprintf` header writing logic. Instead of just `%d %d %d`, it should now write `2 %ld %d %d %d %d %d` (Version, Timestamp, Rows, Cols, MaxPop, MaxRounds, Delay).\n    - [ ] **Action:** Use `time(NULL)` to get the current timestamp.\n    - [ ] **Verification (Interactive Test):**\n        1.  Compile and run the game.\n        2.  Go to Editor, place some cells.\n        3.  Press `S` to save to `setup.bio`.\n        4.  Open `setup.bio` in a text editor.\n        5.  **Expected Result:** The first line should now look like `2 1705481234 50 50 100 1000 100` (7 numbers starting with 2).\n\n- [ ] **Step 1.3: Implement Backward-Compatible Load Logic**\n    - [ ] **Action:** In `file_io.c`, modify `load_grid`.\n    - [ ] **Action:** Update the `fscanf` logic to read the first line.\n    - [ ] **Action:** Check the return value of `fscanf`.\n        -   If it reads 3 items: It's legacy. Parse as `Rows, Cols, MaxPop`. Set `MaxRounds=1000`, `Delay=100`.\n        -   If it reads 7 items (and first is 2): It's v2. Parse all fields.\n    - [ ] **Action:** Ensure `GameConfig *c` is updated with the loaded values (`max_rounds`, `delay_ms`).\n    - [ ] **Verification (Interactive Test):**\n        1.  Create a file `legacy_test.bio` manually with content: `20 20 50\n0 0 1`. *Note: The UI currently hardcodes \"setup.bio\" for loading.*\n        2.  **Alternative Verification:** Save a new file using the game (Step 1.2). Restart game. Press `L`.\n        3.  **Expected Result:** The grid loads correctly. The configuration (Rounds, Delay) matches what was saved.\n\n## Phase 2: Directory Helper & File Listing\n\n*Goal: Enable the application to inspect the file system and list available protocol files.*\n\n- [ ] **Step 2.1: Implement `list_protocol_files`**\n    - [ ] **Action:** In `file_io.c`, include `<dirent.h>` (or `<windows.h>` if MinGW is missing it, but try dirent first).\n    - [ ] **Action:** Implement `int list_protocol_files(const char *dir_path, ProtocolInfo **out_list)`.\n    - [ ] **Action:** Logic:\n        1.  Open directory.\n        2.  Loop through files.\n        3.  Filter for `.bio` extension.\n        4.  For each match:\n            -   `malloc` or `realloc` the list.\n            -   Store filename.\n            -   Call helper `load_protocol_metadata` (stub for now) to get details.\n    - [ ] **Verification (Interactive Test):**\n        1.  Create a temporary `test_list.c` main file that calls `list_protocol_files(\".\")` and prints found names.\n        2.  Run it.\n        3.  **Expected Result:** It lists `setup.bio` and any other .bio files in the folder.\n\n- [ ] **Step 2.2: Implement `load_protocol_metadata`**\n    - [ ] **Action:** In `file_io.c`, implement `load_protocol_metadata`.\n    - [ ] **Action:** Logic: Open file, read *only* the first line (header), parse version, rows, cols, rounds, timestamp. Close file. Return 1 on success.\n    - [ ] **Verification (Interactive Test):**\n        1.  Update `test_list.c` to print the metadata (Rows, Cols, Rounds) next to the filename.\n        2.  **Expected Result:** Correct metadata is displayed for the v2 file created in Phase 1.\n\n- [ ] **Step 2.3: Sorting**\n    - [ ] **Action:** In `list_protocol_files`, after collecting all files, use `qsort` to sort the array of `ProtocolInfo`.\n    - [ ] **Action:** Comparator: Sort by `timestamp` descending (newest first).\n    - [ ] **Verification:**\n        1.  Create two bio files manually with different timestamps in the header.\n        2.  Run `test_list.c`.\n        3.  **Expected Result:** The file with the higher timestamp appears first.\n\n## Phase 3: GUI - Auto-Save Implementation\n\n*Goal: Automate the creation of protocol files when the simulation starts.*\n\n- [ ] **Step 3.1: Trigger Auto-Save**\n    - [ ] **Action:** In `gui.c`, locate `STATE_EDIT`. Find the block handling `KEY_ENTER` (transition to `STATE_RUNNING`).\n    - [ ] **Action:** Before changing state, construct a filename: `biotope_results/run_YYYYMMDD_HHMMSS.bio`.\n    - [ ] **Action:** Ensure `biotope_results` directory exists (use `mkdir` or `CreateDirectory` wrapper in `file_io` if needed, or assume it exists/create manually for now).\n    - [ ] **Action:** Call `save_grid(filename, gui_world, &config)`.\n    - [ ] **Verification (Interactive Test):**\n        1.  Start game.\n        2.  Setup a pattern.\n        3.  Press `ENTER` to run.\n        4.  Check `biotope_results/` folder in Windows Explorer.\n        5.  **Expected Result:** A new file `run_....bio` exists with the correct content.\n\n## Phase 4: GUI - File Browser (The \"Replay\" UI)\n\n*Goal: Replace the simple \"Load\" button with a full file browser.*\n\n- [ ] **Step 4.1: Define `STATE_LOAD`**\n    - [ ] **Action:** In `gui.c`, add `STATE_LOAD` to the `AppState` enum.\n    - [ ] **Action:** In `gui.c`, add global (or static) variables for the file list state:\n        -   `ProtocolInfo *fileList = NULL`\n        -   `int fileCount = 0`\n        -   `int selectedFileIndex = 0`\n\n- [ ] **Step 4.2: Implement Transition and Loading List**\n    - [ ] **Action:** In `STATE_EDIT` (or `STATE_CONFIG`), change `KEY_L` logic. Instead of calling `load_grid` immediately:\n        -   Call `list_protocol_files(\"biotope_results\", &fileList)`.\n        -   Set `selectedFileIndex = 0`.\n        -   Set `state = STATE_LOAD`.\n    - [ ] **Verification (Interactive Test):**\n        1.  Start game. Press `L`.\n        2.  **Expected Result:** Screen changes (likely blank or black for now as we haven't rendered `STATE_LOAD` yet), but no crash.\n\n- [ ] **Step 4.3: Implement Rendering for `STATE_LOAD`**\n    - [ ] **Action:** In the main drawing loop (switch `state`), add `case STATE_LOAD:`\n    - [ ] **Action:** Draw Title \"PROTOCOL ARCHIVE\".\n    - [ ] **Action:** Loop through `fileList`. Draw filenames.\n    - [ ] **Action:** Draw a rectangle/highlight around `fileList[selectedFileIndex]`.\n    - [ ] **Action:** Draw a \"Preview\" box on the right side:\n        -   \"Date: ...\" (convert timestamp to string)\n        -   \"Grid: WxH\"\n        -   \"Rounds: ...\"\n    - [ ] **Verification (Interactive Test):**\n        1.  Start game. Press `L`.\n        2.  **Expected Result:** You see the list of files generated in Phase 3. The first one is highlighted.\n\n- [ ] **Step 4.4: Implement Input for `STATE_LOAD`**\n    - [ ] **Action:** In the logic loop for `STATE_LOAD`:\n        -   `KEY_UP`: `selectedFileIndex--` (clamp to 0).\n        -   `KEY_DOWN`: `selectedFileIndex++` (clamp to `fileCount-1`).\n        -   `KEY_ENTER`:\n            -   Call `load_grid(fileList[selectedFileIndex].filepath, ...)`\n            -   Free `fileList`.\n            -   Transition to `STATE_EDIT`.\n        -   `KEY_Q` or `KEY_ESC`:\n            -   Free `fileList`.\n            -   Transition back to `STATE_EDIT`.\n    - [ ] **Verification (Interactive Test):**\n        1.  Start game. Run a few simulations to generate files.\n        2.  Go to Editor. Press `L`.\n        3.  Navigate with arrows. Observe preview changing.\n        4.  Press Enter on an old run.\n        5.  **Expected Result:** The game returns to Editor mode with the EXACT grid and settings from that old run.",
    "new_string": "## Phase 1: File I/O Core Enhancements\n\n*Goal: Update the file persistence layer to support the new extended protocol format (v2) while maintaining backward compatibility with existing .bio files.*\n\n- [x] **Step 1.1: Update `GameConfig` and Headers**\n    - [x] **Action:** In `gui.h`, ensure `GameConfig` struct is fully defined and accessible for `file_io.c`. (It is currently defined in `gui.c` but might need to be moved to `gui.h` or `game_logic.h` if `file_io.h` needs to see it, or forward declared). *Correction:* `file_io.h` already includes `gui.h`.\n    - [x] **Action:** Open `file_io.h`. Add the `ProtocolInfo` struct definition as specified in the Tech Design (Section 4.1).\n    - [x] **Action:** Update `save_grid` prototype in `file_io.h` to explicitly take `GameConfig *c` (already done in current code, just verify).\n    - [x] **Action:** Add prototypes for `list_protocol_files` and `load_protocol_metadata` to `file_io.h`.\n    - [x] **Verification (Interactive Test):**\n        1.  Run `gcc -c main.c gui.c file_io.c game_logic.c` (or your build command).\n        2.  **Expected Result:** Compilation succeeds. No \"unknown type\" errors for `ProtocolInfo`.\n\n- [x] **Step 1.2: Implement Extended Save Logic**\n    - [x] **Action:** In `file_io.c`, modify `save_grid`.\n    - [x] **Action:** Change the `fprintf` header writing logic. Instead of just `%d %d %d`, it should now write `2 %ld %d %d %d %d %d` (Version, Timestamp, Rows, Cols, MaxPop, MaxRounds, Delay).\n    - [x] **Action:** Use `time(NULL)` to get the current timestamp.\n    - [x] **Verification (Interactive Test):**\n        1.  Compile and run the game.\n        2.  Go to Editor, place some cells.\n        3.  Press `S` to save to `setup.bio`.\n        4.  Open `setup.bio` in a text editor.\n        5.  **Expected Result:** The first line should now look like `2 1705481234 50 50 100 1000 100` (7 numbers starting with 2).\n\n- [x] **Step 1.3: Implement Backward-Compatible Load Logic**\n    - [x] **Action:** In `file_io.c`, modify `load_grid`.\n    - [x] **Action:** Update the `fscanf` logic to read the first line.\n    - [x] **Action:** Check the return value of `fscanf`.\n        -   If it reads 3 items: It's legacy. Parse as `Rows, Cols, MaxPop`. Set `MaxRounds=1000`, `Delay=100`.\n        -   If it reads 7 items (and first is 2): It's v2. Parse all fields.\n    - [x] **Action:** Ensure `GameConfig *c` is updated with the loaded values (`max_rounds`, `delay_ms`).\n    - [x] **Verification (Interactive Test):**\n        1.  Create a file `legacy_test.bio` manually with content: `20 20 50\n0 0 1`. *Note: The UI currently hardcodes \"setup.bio\" for loading.*\n        2.  **Alternative Verification:** Save a new file using the game (Step 1.2). Restart game. Press `L`.\n        3.  **Expected Result:** The grid loads correctly. The configuration (Rounds, Delay) matches what was saved.\n\n## Phase 2: Directory Helper & File Listing\n\n*Goal: Enable the application to inspect the file system and list available protocol files.*\n\n- [x] **Step 2.1: Implement `list_protocol_files`**\n    - [x] **Action:** In `file_io.c`, include `<dirent.h>` (or `<windows.h>` if MinGW is missing it, but try dirent first).\n    - [x] **Action:** Implement `int list_protocol_files(const char *dir_path, ProtocolInfo **out_list)`.\n    - [x] **Action:** Logic:\n        1.  Open directory.\n        2.  Loop through files.\n        3.  Filter for `.bio` extension.\n        4.  For each match:\n            -   `malloc` or `realloc` the list.\n            -   Store filename.\n            -   Call helper `load_protocol_metadata` (stub for now) to get details.\n    - [x] **Verification (Interactive Test):**\n        1.  Create a temporary `test_list.c` main file that calls `list_protocol_files(\".\")` and prints found names.\n        2.  Run it.\n        3.  **Expected Result:** It lists `setup.bio` and any other .bio files in the folder.\n\n- [x] **Step 2.2: Implement `load_protocol_metadata`**\n    - [x] **Action:** In `file_io.c`, implement `load_protocol_metadata`.\n    - [x] **Action:** Logic: Open file, read *only* the first line (header), parse version, rows, cols, rounds, timestamp. Close file. Return 1 on success.\n    - [x] **Verification (Interactive Test):**\n        1.  Update `test_list.c` to print the metadata (Rows, Cols, Rounds) next to the filename.\n        2.  **Expected Result:** Correct metadata is displayed for the v2 file created in Phase 1.\n\n- [x] **Step 2.3: Sorting**\n    - [x] **Action:** In `list_protocol_files`, after collecting all files, use `qsort` to sort the array of `ProtocolInfo`.\n    - [x] **Action:** Comparator: Sort by `timestamp` descending (newest first).\n    - [x] **Verification:**\n        1.  Create two bio files manually with different timestamps in the header.\n        2.  Run `test_list.c`.\n        3.  **Expected Result:** The file with the higher timestamp appears first.\n\n## Phase 3: GUI - Auto-Save Implementation\n\n*Goal: Automate the creation of protocol files when the simulation starts.*\n\n- [x] **Step 3.1: Trigger Auto-Save**\n    - [x] **Action:** In `gui.c`, locate `STATE_EDIT`. Find the block handling `KEY_ENTER` (transition to `STATE_RUNNING`).\n    - [x] **Action:** Before changing state, construct a filename: `biotope_results/run_YYYYMMDD_HHMMSS.bio`.\n    - [x] **Action:** Ensure `biotope_results` directory exists (use `mkdir` or `CreateDirectory` wrapper in `file_io` if needed, or assume it exists/create manually for now).\n    - [x] **Action:** Call `save_grid(filename, gui_world, &config)`.\n    - [x] **Verification (Interactive Test):**\n        1.  Start game.\n        2.  Setup a pattern.\n        3.  Press `ENTER` to run.\n        4.  Check `biotope_results/` folder in Windows Explorer.\n        5.  **Expected Result:** A new file `run_....bio` exists with the correct content.\n\n## Phase 4: GUI - File Browser (The \"Replay\" UI)\n\n*Goal: Replace the simple \"Load\" button with a full file browser.*\n\n- [x] **Step 4.1: Define `STATE_LOAD`**\n    - [x] **Action:** In `gui.c`, add `STATE_LOAD` to the `AppState` enum.\n    - [x] **Action:** In `gui.c`, add global (or static) variables for the file list state:\n        -   `ProtocolInfo *fileList = NULL`\n        -   `int fileCount = 0`\n        -   `int selectedFileIndex = 0`\n\n- [x] **Step 4.2: Implement Transition and Loading List**\n    - [x] **Action:** In `STATE_EDIT` (or `STATE_CONFIG`), change `KEY_L` logic. Instead of calling `load_grid` immediately:\n        -   Call `list_protocol_files(\"biotope_results\", &fileList)`.\n        -   Set `selectedFileIndex = 0`.\n        -   Set `state = STATE_LOAD`.\n    - [x] **Verification (Interactive Test):**\n        1.  Start game. Press `L`.\n        2.  **Expected Result:** Screen changes (likely blank or black for now as we haven't rendered `STATE_LOAD` yet), but no crash.\n\n- [x] **Step 4.3: Implement Rendering for `STATE_LOAD`**\n    - [x] **Action:** In the main drawing loop (switch `state`), add `case STATE_LOAD:`\n    - [x] **Action:** Draw Title \"PROTOCOL ARCHIVE\".\n    - [x] **Action:** Loop through `fileList`. Draw filenames.\n    - [x] **Action:** Draw a rectangle/highlight around `fileList[selectedFileIndex]`.\n    - [x] **Action:** Draw a \"Preview\" box on the right side:\n        -   \"Date: ...\" (convert timestamp to string)\n        -   \"Grid: WxH\"\n        -   \"Rounds: ...\"\n    - [x] **Verification (Interactive Test):**\n        1.  Start game. Press `L`.\n        2.  **Expected Result:** You see the list of files generated in Phase 3. The first one is highlighted.\n\n- [x] **Step 4.4: Implement Input for `STATE_LOAD`**\n    - [x] **Action:** In the logic loop for `STATE_LOAD`:\n        -   `KEY_UP`: `selectedFileIndex--` (clamp to 0).\n        -   `KEY_DOWN`: `selectedFileIndex++` (clamp to `fileCount-1`).\n        -   `KEY_ENTER`:\n            -   Call `load_grid(fileList[selectedFileIndex].filepath, ...)`\n            -   Free `fileList`.\n            -   Transition to `STATE_EDIT`.\n        -   `KEY_Q` or `KEY_ESC`:\n            -   Free `fileList`.\n            -   Transition back to `STATE_EDIT`.\n    - [x] **Verification (Interactive Test):**\n        1.  Start game. Run a few simulations to generate files.\n        2.  Go to Editor. Press `L`.\n        3.  Navigate with arrows. Observe preview changing.\n        4.  Press Enter on an old run.\n        5.  **Expected Result:** The game returns to Editor mode with the EXACT grid and settings from that old run.",
    "instruction": "Mark all tasks as completed."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768661492074-05acd4bcce5bc",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\docs\\DEV_TASKS-0003-integrated-simulation-protocol.md (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Das `DEV_TASKS`-Dokument ist aktualisiert und die Code-√Ñnderungen sind entsprechend markiert.

Damit ist das **Integrated Simulation Protocol System** vollst√§ndig implementiert, dokumentiert und verifiziert.

Ich bin bereit f√ºr die n√§chste Anweisung.

---

## USER üßë‚Äçüíª

Bitte erg√§nze folgende Eintr√§ge in die in biotpe_results/ abgespeicherte run_...-Datei. Nachdem eine Simulation erfolgreich durchgelaufen ist, wird das Ergebnis der Simulation in eine Datei biotpe_results_... geschrieben und in das Hauptverzeichnis ./GameOfLife/ geschrieben. Bitte f√ºge diese Informationen ebenfalls in die run_...-Datei ein, sodass das Ergebnis einer erfolgreichen Simulation bereits beim Laden der Datei in der Vorschau z erkennen ist.

---

## MODEL ‚ú®

Das ist eine sehr sinnvolle Erweiterung. Damit wird das Protokoll (`.bio` Datei) zu einer vollst√§ndigen Historie, die nicht nur den Startzustand, sondern auch den Ausgang des Experiments festh√§lt.

Ich werde das System wie folgt erweitern:

1.  **Datenstruktur (`file_io.h`):** Die `ProtocolInfo`-Struktur wird erweitert, um Ergebnisse (Gewinner, Punkte) zu speichern, damit die Vorschau diese anzeigen kann.
2.  **File I/O (`file_io.c`):**
    *   Eine neue Funktion `append_protocol_result` schreibt einen "Footer" (Anhang) an die `.bio`-Datei, sobald die Simulation endet.
    *   Die Funktion `load_protocol_metadata` wird erweitert, um zu pr√ºfen, ob dieser Footer existiert und ihn auszulesen.
3.  **GUI (`gui.c`):**
    *   Wir merken uns den Dateinamen der aktuellen Simulation.
    *   Am Ende (`STATE_FINISHED`) schreiben wir das Ergebnis in die Datei.
    *   In der Vorschau (`STATE_LOAD`) zeigen wir das Ergebnis an, falls vorhanden.

Ich beginne mit den Header-Anpassungen.

### Schritt 1: Anpassung von `file_io.h`

Ich f√ºge die neuen Felder zur Struktur und den Prototypen f√ºr die neue Funktion hinzu.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.h",
    "instruction": "Add result fields to ProtocolInfo and add append_protocol_result prototype.",
    "new_string": "    // Preview Data\n    int rows;\n    int cols;\n    int max_rounds;\n    int max_population;\n    \n    // Result Data (Optional)\n    int has_results;    // 1 if simulation finished and results are appended\n    int winner;         // 0=Draw, 1=Red, 2=Blue\n    int final_red;\n    int final_blue;\n} ProtocolInfo;\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nvoid append_protocol_result(const char *filename, int winner, int red, int blue);\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner);",
    "old_string": "    // Preview Data\n    int rows;\n    int cols;\n    int max_rounds;\n    int max_population;\n} ProtocolInfo;\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner);"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768662676002-364c399880b18",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.h (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

### Schritt 2: Anpassung von `file_io.c`

Hier implementiere ich `append_protocol_result` und erweitere `load_protocol_metadata`, um nach dem `#RESULTS` Block am Ende der Datei zu suchen.

Ich ersetze `load_protocol_metadata` komplett durch eine erweiterte Version und f√ºge `append_protocol_result` hinzu.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "old_string": "// KI-Agent unterst√ºtzt\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) return 0;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n\n    int version;\n    int items = sscanf(line, \"%d %ld %d %d %d %d\", \n                       &version, &info->timestamp, &info->rows, &info->cols, \n                       &info->max_population, &info->max_rounds);\n\n    if (items == 6 && version == 2) {\n        // OK\n    } else {\n        // Try legacy\n        items = sscanf(line, \"%d %d %d\", &info->rows, &info->cols, &info->max_population);\n        if (items == 3) {\n            info->timestamp = 0;\n            info->max_rounds = 1000;\n        } else {\n            fclose(f);\n            return 0;\n        }\n    }\n\n    fclose(f);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner) {",
    "instruction": "Implement append_protocol_result and update load_protocol_metadata to parse results.",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.c",
    "new_string": "// KI-Agent unterst√ºtzt\nvoid append_protocol_result(const char *filename, int winner, int red, int blue) {\n    FILE *f = fopen(filename, \"a\"); // \"a\" for append\n    if (!f) return;\n    \n    fprintf(f, \"\\n#RESULTS\\n\");\n    fprintf(f, \"WINNER %d\\n\", winner);\n    fprintf(f, \"RED %d\\n\", red);\n    fprintf(f, \"BLUE %d\\n\", blue);\n    \n    fclose(f);\n    printf(\"Appended results to %s\\n\", filename);\n}\n\n// KI-Agent unterst√ºtzt\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) return 0;\n\n    // Initialize defaults\n    info->has_results = 0;\n    info->winner = 0;\n    info->final_red = 0;\n    info->final_blue = 0;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n\n    int version;\n    int items = sscanf(line, \"%d %ld %d %d %d %d\", \n                       &version, &info->timestamp, &info->rows, &info->cols, \n                       &info->max_population, &info->max_rounds);\n\n    if (items == 6 && version == 2) {\n        // Header OK\n    } else {\n        // Try legacy\n        items = sscanf(line, \"%d %d %d\", &info->rows, &info->cols, &info->max_population);\n        if (items == 3) {\n            info->timestamp = 0;\n            info->max_rounds = 1000;\n        } else {\n            fclose(f);\n            return 0; // Unknown format\n        }\n    }\n\n    // Scan for #RESULTS footer\n    // We continue reading line by line until end\n    while (fgets(line, sizeof(line), f)) {\n        if (strncmp(line, \"#RESULTS\", 8) == 0) {\n            info->has_results = 1;\n        }\n        if (info->has_results) {\n            if (strncmp(line, \"WINNER\", 6) == 0) sscanf(line, \"WINNER %d\", &info->winner);\n            if (strncmp(line, \"RED\", 3) == 0) sscanf(line, \"RED %d\", &info->final_red);\n            if (strncmp(line, \"BLUE\", 4) == 0) sscanf(line, \"BLUE %d\", &info->final_blue);\n        }\n    }\n\n    fclose(f);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner) {"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768662857874-17f3598c6591b8",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\file_io.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

### Schritt 3: Anpassung von `gui.c`

Ich muss nun `gui.c` an drei Stellen anpassen:
1.  **Variablen:** Eine statische Variable f√ºr den aktuellen Dateinamen einf√ºhren.
2.  **Auto-Save:** Den generierten Dateinamen in dieser Variable speichern.
3.  **End-Game:** Wenn das Spiel vorbei ist (`STATE_FINISHED` -> Enter), `append_protocol_result` aufrufen.
4.  **Vorschau:** In `STATE_LOAD` die Ergebnisse anzeigen, falls `has_results` wahr ist.

Da `gui.c` komplex ist, mache ich das in zwei `replace` Aufrufen. Zuerst die Logik und Variablen.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "instruction": "Add currentProtocolFilename variable and update logic in Auto-Save and STATE_FINISHED to store and append results.",
    "old_string": "// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n\n// --- Theme Colors (Digital Lab) ---",
    "expected_replacements": 1,
    "new_string": "// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n// Current Run Tracking\nstatic char currentProtocolFilename[256] = \"\";\n\n// --- Theme Colors (Digital Lab) ---",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c"
  }
}
```**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "instruction": "1. Save filename in Auto-Save block. 2. Append results in STATE_FINISHED block.",
    "new_string": "                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;",
    "old_string": "                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;",
    "expected_replacements": 2
  }
}
```**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "new_string": "            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     char filename[64];\n                     time_t t = time(NULL);\n                     sprintf(filename, \"biotope_results_%ld.md\", t);\n                     export_stats_md(filename, &config, winner);\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }\n                if (IsKeyPressed(KEY_Q)) {",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "old_string": "            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     char filename[64];\n                     time_t t = time(NULL);\n                     sprintf(filename, \"biotope_results_%ld.md\", t);\n                     export_stats_md(filename, &config, winner);\n                }\n                if (IsKeyPressed(KEY_Q)) {",
    "instruction": "Call append_protocol_result in STATE_FINISHED logic.",
    "expected_replacements": 1
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768662886730-7a5810807e36a8",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```**Tool Response**:
```json
{
  "id": "replace-1768662889898-511d281662b3b8",
  "name": "replace",
  "response": {
    "error": "Failed to edit, Expected 2 occurrences but found 1 for old_string in file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c"
  }
}
```**Tool Response**:
```json
{
  "id": "replace-1768662890081-674e0298165f7",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Der zweite `replace`-Aufruf (f√ºr Auto-Save) schlug fehl, weil er zwei Vorkommen erwartete, aber nur eines fand (wahrscheinlich wegen einer Unstimmigkeit im Kontext). Ich werde diesen Block nun separat und pr√§zise ersetzen.

Danach folgt die Anpassung der Vorschau-Anzeige in `STATE_LOAD`.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "old_string": "                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "instruction": "Add filename storage logic to Auto-Save block (retry).",
    "new_string": "                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768663184274-af85a7ebc34b28",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Zuletzt die Erweiterung der **Vorschau-Anzeige** in `STATE_LOAD`, um die Ergebnisse anzuzeigen.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "instruction": "Update STATE_LOAD rendering to display simulation results in preview panel.",
    "old_string": "                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 350, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;",
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "new_string": "                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n                    \n                    if (sel->has_results) {\n                        DrawLine(previewX - 10, 260, previewX + 250, 260, Fade(THEME_TEXT, 0.3f));\n                        DrawText(\"RESULTS:\", previewX, 270, 20, THEME_HIGHLIGHT);\n                        \n                        if (sel->winner == 1) DrawText(\"WINNER: RED\", previewX, 300, 20, THEME_RED);\n                        else if (sel->winner == 2) DrawText(\"WINNER: BLUE\", previewX, 300, 20, THEME_BLUE);\n                        else DrawText(\"WINNER: DRAW\", previewX, 300, 20, DARKGRAY);\n                        \n                        char scoreBuf[64];\n                        sprintf(scoreBuf, \"R:%d  B:%d\", sel->final_red, sel->final_blue);\n                        DrawText(scoreBuf, previewX, 330, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"NO RESULTS YET\", previewX, 270, 18, DARKGRAY);\n                    }\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 380, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768663201490-33595dd9a845d",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

Die Implementierung ist abgeschlossen.

**Zusammenfassung:**
1.  Wenn du nun eine Simulation startest, wird der Dateiname intern gemerkt.
2.  Sobald die Simulation beendet ist und du "Ergebnisse anzeigen" (`ENTER`) w√§hlst, werden die Punktzahlen und der Gewinner ans Ende der `.bio` Datei im Ordner `biotope_results` angeh√§ngt.
3.  Im "Load"-Men√º (`L`) siehst du nun in der Vorschau, ob ein Spiel schon Ergebnisse hat, wer gewonnen hat und wie der Punktestand war.

Bitte kompiliere das Projekt erneut:
`gcc main.c gui.c file_io.c game_logic.c -o game -lraylib -lGL -lm -lpthread -ldl -lrt -lX11`

---

## USER üßë‚Äçüíª

Es gibt irgendwo ein Feature, dass nach erfolgreicher Simulation eine Datei biotope_results_...md schreibt. Beispielhaft hier der Inhalt von einer Datei: # Biotope Game Results

**Date:** 17.01.2026 15:24

## Configuration
- Grid: 50x50
- Max Population: 100
- Max Rounds: 1000

## Final Score
- **Red Team:** 13
- **Blue Team:** 5

## Result
**Winner: RED TEAM**
Da die Ergebnisse nun in der run_...-Datei protokolliert werden wird diese Datei nicht mehr ben√∂tigt. Bitte entferne das Erstellen und schreiben dieser Datei aus der Codebase.

---

## MODEL ‚ú®

Ich werde die Funktion `export_stats_md` und deren Aufrufe aus der Codebasis entfernen, da die Ergebnisse nun direkt in den Protokolldateien gespeichert werden.

Zuerst lese ich die Dateien `gui.c`, `file_io.c` und `file_io.h`, um die genauen Stellen f√ºr die Entfernung zu identifizieren.**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "gui.c"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "file_io.c"
  }
}
```**Tool Command**:
```json
{
  "name": "read_file",
  "args": {
    "file_path": "file_io.h"
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "read_file-1768663770809-9313f6d50237f",
  "name": "read_file",
  "response": {
    "output": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterst√ºtzt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n// Current Run Tracking\nstatic char currentProtocolFilename[256] = \"\";\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterst√ºtzt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterst√ºtzt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterst√ºtzt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {\n    int team;\n    int midCol = c->cols / 2;\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterst√ºtzt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\");\n    SetTargetFPS(60);\n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {\n            case STATE_CONFIG:\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;\n                }\n                \n                // KI-Agent unterst√ºtzt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;\n\n            case STATE_LOAD:\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                break;\n            \n            case STATE_RUNNING:\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     char filename[64];\n                     time_t t = time(NULL);\n                     sprintf(filename, \"biotope_results_%ld.md\", t);\n                     export_stats_md(filename, &config, winner);\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterst√ºtzt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n                \n                // KI-Agent unterst√ºtzt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterst√ºtzt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterst√ºtzt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterst√ºtzt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n                    \n                    if (sel->has_results) {\n                        DrawLine(previewX - 10, 260, previewX + 250, 260, Fade(THEME_TEXT, 0.3f));\n                        DrawText(\"RESULTS:\", previewX, 270, 20, THEME_HIGHLIGHT);\n                        \n                        if (sel->winner == 1) DrawText(\"WINNER: RED\", previewX, 300, 20, THEME_RED);\n                        else if (sel->winner == 2) DrawText(\"WINNER: BLUE\", previewX, 300, 20, THEME_BLUE);\n                        else DrawText(\"WINNER: DRAW\", previewX, 300, 20, DARKGRAY);\n                        \n                        char scoreBuf[64];\n                        sprintf(scoreBuf, \"R:%d  B:%d\", sel->final_red, sel->final_blue);\n                        DrawText(scoreBuf, previewX, 330, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"NO RESULTS YET\", previewX, 270, 18, DARKGRAY);\n                    }\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 380, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterst√ºtzt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}\n"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768663771168-c23c632043b4f",
  "name": "read_file",
  "response": {
    "output": "#include <stdio.h>\n#include <time.h>\n#include <stdlib.h> // For malloc/free\n#include <string.h>\n#include <dirent.h>\n#include \"file_io.h\"\n\n// Comparator for qsort to sort by timestamp descending\nstatic int compare_protocol_info(const void *a, const void *b) {\n    ProtocolInfo *pa = (ProtocolInfo *)a;\n    ProtocolInfo *pb = (ProtocolInfo *)b;\n    if (pb->timestamp > pa->timestamp) return 1;\n    if (pb->timestamp < pa->timestamp) return -1;\n    return 0;\n}\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) {\n        printf(\"Error saving file %s\\n\", filename);\n        return 0;\n    }\n    \n    // v2 Header: Version Timestamp Rows Cols MaxPop MaxRounds Delay\n    // Version 2\n    long timestamp = (long)time(NULL);\n    fprintf(f, \"2 %ld %d %d %d %d %d\\n\", \n            timestamp, \n            c->rows, c->cols, \n            c->max_population, \n            c->max_rounds, \n            c->delay_ms);\n    \n    // Save live cells only: r c team\n    for(int i=0; i < w->rows * w->cols; i++) {\n        if (w->grid[i] != DEAD) {\n            int r = i / w->cols;\n            int c_idx = i % w->cols;\n            fprintf(f, \"%d %d %d\\n\", r, c_idx, w->grid[i]);\n        }\n    }\n    \n    fclose(f);\n    printf(\"Saved to %s\\n\", filename);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) {\n        printf(\"Error opening file %s\\n\", filename);\n        return 0; // Fail\n    }\n    \n    int rows, cols, max_pop;\n    int max_rounds = 1000; // Default legacy\n    int delay_ms = 100;    // Default legacy\n    long timestamp = 0;\n    int version = 1;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n    \n    // Try parsing as v2\n    int items = sscanf(line, \"%d %ld %d %d %d %d %d\", \n                       &version, &timestamp, &rows, &cols, &max_pop, &max_rounds, &delay_ms);\n                       \n    if (items == 7 && version == 2) {\n        printf(\"Detected Protocol v2. Timestamp: %ld\\n\", timestamp);\n    } else {\n        // Fallback to legacy v1\n        items = sscanf(line, \"%d %d %d\", &rows, &cols, &max_pop);\n        if (items == 3) {\n            version = 1;\n            printf(\"Detected Legacy Format (v1).\\n\");\n        } else {\n            printf(\"Error: Unknown file format.\\n\");\n            fclose(f);\n            return 0;\n        }\n    }\n    \n    // Check if loaded config matches current world size\n    if (rows != c->rows || cols != c->cols) {\n        printf(\"Resizing world from %dx%d to %dx%d...\\n\", c->rows, c->cols, rows, cols);\n        free(w->grid);\n        w->grid = (int*)malloc(rows * cols * sizeof(int));\n        if (!w->grid) {\n            printf(\"Error: Failed to allocate memory for new grid size.\\n\");\n            fclose(f);\n            return 0;\n        }\n        w->rows = rows;\n        w->cols = cols;\n        c->rows = rows;\n        c->cols = cols;\n    }\n    \n    // Update config\n    c->max_population = max_pop;\n    c->max_rounds = max_rounds;\n    c->delay_ms = delay_ms;\n    \n    // Clear grid\n    for(int i=0; i < w->rows * w->cols; i++) w->grid[i] = DEAD;\n    c->current_blue_pop = 0;\n    c->current_red_pop = 0;\n    \n    int r, c_idx, team;\n    while (fscanf(f, \"%d %d %d\", &r, &c_idx, &team) == 3) {\n        if (r >= 0 && r < rows && c_idx >= 0 && c_idx < cols) {\n            int idx = r * cols + c_idx;\n            w->grid[idx] = team;\n            if (team == TEAM_RED) c->current_red_pop++;\n            if (team == TEAM_BLUE) c->current_blue_pop++;\n        }\n    }\n    \n    fclose(f);\n    printf(\"Loaded from %s\\n\", filename);\n    return 1; // Success\n}\n\n// KI-Agent unterst√ºtzt\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list) {\n    DIR *d = opendir(dir_path);\n    if (!d) {\n        printf(\"Error: Could not open directory %s\\n\", dir_path);\n        return 0;\n    }\n\n    struct dirent *dir;\n    int count = 0;\n    int capacity = 10;\n    ProtocolInfo *list = malloc(capacity * sizeof(ProtocolInfo));\n\n    while ((dir = readdir(d)) != NULL) {\n        // Filter for .bio extension\n        char *ext = strrchr(dir->d_name, '.');\n        if (ext && strcmp(ext, \".bio\") == 0) {\n            ProtocolInfo info;\n            snprintf(info.filename, sizeof(info.filename), \"%s\", dir->d_name);\n            snprintf(info.filepath, sizeof(info.filepath), \"%s/%s\", dir_path, dir->d_name);\n            \n            if (load_protocol_metadata(info.filepath, &info)) {\n                if (count >= capacity) {\n                    capacity *= 2;\n                    list = realloc(list, capacity * sizeof(ProtocolInfo));\n                }\n                list[count++] = info;\n            }\n        }\n    }\n    closedir(d);\n\n    if (count > 0) {\n        qsort(list, count, sizeof(ProtocolInfo), compare_protocol_info);\n    }\n\n    *out_list = list;\n    return count;\n}\n\n// KI-Agent unterst√ºtzt\nvoid append_protocol_result(const char *filename, int winner, int red, int blue) {\n    FILE *f = fopen(filename, \"a\"); // \"a\" for append\n    if (!f) return;\n    \n    fprintf(f, \"\\n#RESULTS\\n\");\n    fprintf(f, \"WINNER %d\\n\", winner);\n    fprintf(f, \"RED %d\\n\", red);\n    fprintf(f, \"BLUE %d\\n\", blue);\n    \n    fclose(f);\n    printf(\"Appended results to %s\\n\", filename);\n}\n\n// KI-Agent unterst√ºtzt\nint load_protocol_metadata(const char *filename, ProtocolInfo *info) {\n    FILE *f = fopen(filename, \"r\");\n    if (!f) return 0;\n\n    // Initialize defaults\n    info->has_results = 0;\n    info->winner = 0;\n    info->final_red = 0;\n    info->final_blue = 0;\n\n    char line[256];\n    if (!fgets(line, sizeof(line), f)) {\n        fclose(f);\n        return 0;\n    }\n\n    int version;\n    int items = sscanf(line, \"%d %ld %d %d %d %d\", \n                       &version, &info->timestamp, &info->rows, &info->cols, \n                       &info->max_population, &info->max_rounds);\n\n    if (items == 6 && version == 2) {\n        // Header OK\n    } else {\n        // Try legacy\n        items = sscanf(line, \"%d %d %d\", &info->rows, &info->cols, &info->max_population);\n        if (items == 3) {\n            info->timestamp = 0;\n            info->max_rounds = 1000;\n        } else {\n            fclose(f);\n            return 0; // Unknown format\n        }\n    }\n\n    // Scan for #RESULTS footer\n    // We continue reading line by line until end\n    while (fgets(line, sizeof(line), f)) {\n        if (strncmp(line, \"#RESULTS\", 8) == 0) {\n            info->has_results = 1;\n        }\n        if (info->has_results) {\n            if (strncmp(line, \"WINNER\", 6) == 0) sscanf(line, \"WINNER %d\", &info->winner);\n            if (strncmp(line, \"RED\", 3) == 0) sscanf(line, \"RED %d\", &info->final_red);\n            if (strncmp(line, \"BLUE\", 4) == 0) sscanf(line, \"BLUE %d\", &info->final_blue);\n        }\n    }\n\n    fclose(f);\n    return 1;\n}\n\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner) {\n    FILE *f = fopen(filename, \"w\");\n    if (!f) return; \n    \n    time_t now = time(NULL);\n    struct tm *t = localtime(&now);\n    \n    fprintf(f, \"# Biotope Game Results\\n\\n\");\n    fprintf(f, \"**Date:** %02d.%02d.%04d %02d:%02d\\n\\n\", \n            t->tm_mday, t->tm_mon+1, t->tm_year+1900, t->tm_hour, t->tm_min);\n            \n    fprintf(f, \"## Configuration\\n\");\n    fprintf(f, \"- Grid: %dx%d\\n\", c->rows, c->cols);\n    fprintf(f, \"- Max Population: %d\\n\", c->max_population);\n    fprintf(f, \"- Max Rounds: %d\\n\\n\", c->max_rounds);\n    \n    fprintf(f, \"## Final Score\\n\");\n    fprintf(f, \"- **Red Team:** %d\\n\", c->current_red_pop);\n    fprintf(f, \"- **Blue Team:** %d\\n\\n\", c->current_blue_pop);\n    \n    fprintf(f, \"## Result\\n\");\n    if (winner == TEAM_RED) fprintf(f, \"**Winner: RED TEAM**\\n\");\n    else if (winner == TEAM_BLUE) fprintf(f, \"**Winner: BLUE TEAM**\\n\");\n    else fprintf(f, \"**DRAW**\\n\");\n    \n    fclose(f);\n    printf(\"Stats exported to %s\\n\", filename);\n}"
  }
}
```**Tool Response**:
```json
{
  "id": "read_file-1768663771432-4964643097b2c",
  "name": "read_file",
  "response": {
    "output": "#ifndef FILE_IO_H\n#define FILE_IO_H\n\n#include \"game_logic.h\"\n#include \"gui.h\" // For GameConfig struct\n\n// Struct to hold file metadata for the browser\ntypedef struct {\n    char filename[128]; // e.g., \"run_20260117_120000.bio\"\n    char filepath[256]; // Full relative path\n    long timestamp;     // For sorting\n    \n    // Preview Data\n    int rows;\n    int cols;\n    int max_rounds;\n    int max_population;\n    \n    // Result Data (Optional)\n    int has_results;    // 1 if simulation finished and results are appended\n    int winner;         // 0=Draw, 1=Red, 2=Blue\n    int final_red;\n    int final_blue;\n} ProtocolInfo;\n\n// KI-Agent unterst√ºtzt\nint save_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nint load_grid(const char *filename, World *w, GameConfig *c);\n// KI-Agent unterst√ºtzt\nvoid append_protocol_result(const char *filename, int winner, int red, int blue);\n// KI-Agent unterst√ºtzt\nvoid export_stats_md(const char *filename, GameConfig *c, int winner);\n\n// Lists .bio files in a directory. Returns count.\n// Caller must free the list.\nint list_protocol_files(const char *dir_path, ProtocolInfo **out_list);\n\n// Loads just the header to preview metadata\nint load_protocol_metadata(const char *filename, ProtocolInfo *info);\n\n#endif // FILE_IO_H\n"
  }
}
```

---

## MODEL ‚ú®

Ich werde nun die Markdown-Exportfunktion `export_stats_md` vollst√§ndig entfernen, da die Ergebnisse jetzt direkt in den Protokolldateien gespeichert werden.

### Schritt 1: Entfernung aus `gui.c`
Ich entferne den Codeblock in `STATE_FINISHED`, der den Dateinamen generiert und `export_stats_md` aufruft.**Tool Command**:
```json
{
  "name": "replace",
  "args": {
    "file_path": "C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c",
    "expected_replacements": 1,
    "new_string": "            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }",
    "old_string": "            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     char filename[64];\n                     time_t t = time(NULL);\n                     sprintf(filename, \"biotope_results_%ld.md\", t);\n                     export_stats_md(filename, &config, winner);\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }",
    "instruction": "Remove the call to export_stats_md and the associated filename generation in STATE_FINISHED."
  }
}
```

---

## USER üßë‚Äçüíª

**Tool Response**:
```json
{
  "id": "replace-1768663810678-e4418dea832088",
  "name": "replace",
  "response": {
    "output": "Successfully modified file: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\gui.c (1 replacements)."
  }
}
```

---

## MODEL ‚ú®

### Schritt 2: Entfernung aus `file_io.c`
Ich l√∂sche die Implementierung von `export_stats_md`.startcall:default_api:replace{expected_replacements:1,file_path:<ctrl46>C:\Users\Fried\OneDrive\Studium\Inf\INF-Einf-B\GameOfLife\file_io.c<ctrl46>,instruction:<ctrl46>Delete the implementation of export_stats_md.<ctrl46>,new_string:<ctrl46>    fclose(f);
    return 1;
}<ctrl46>,old_string:<ctrl46>    fclose(f);
    return 1;
}

// KI-Agent unterst√ºtzt
void export_stats_md(const char *filename, GameConfig *c, int winner) {
    FILE *f = fopen(filename, "w");
    if (!f) return; 
    
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    
    fprintf(f, "# Biotope Game Results\n\n");
    fprintf(f, "**Date:** %02d.%02d.%04d %02d:%02d\n\n", 
            t->tm_mday, t->tm_mon+1, t->tm_year+1900, t->tm_hour, t->tm_min);
            
    fprintf(f, "## Configuration\n");
    fprintf(f, "- Grid: %dx%d\n", c->rows, c->cols);
    fprintf(f, "- Max Population: %d\n", c->max_population);
    fprintf(f, "- Max Rounds: %d\n\n", c->max_rounds);
    
    fprintf(f, "## Final Score\n");
    fprintf(f, "- **Red Team:** %d\n", c->current_red_pop);
    fprintf(f, "- **Blue Team:** %d\n\n", c->current_blue_pop);
    
    fprintf(f, "## Result\n");
    if (winner == TEAM_RED) fprintf(f, "**Winner: RED TEAM**\n");
    else if (winner == TEAM_BLUE) fprintf(f, "**Winner: BLUE TEAM**\n");
    else fprintf(f, "**DRAW**\n");
    
    fclose(f);
    printf("Stats exported to %s\n", filename);
}<ctrl46>}