[
  {
    "role": "user",
    "parts": [
      {
        "text": "This is the Gemini CLI. We are setting up the context for our chat.\nToday's date is Freitag, 23. Januar 2026 (formatted according to the user's locale).\nMy operating system is: win32\nThe project's temporary directory is: C:\\Users\\Fried\\.gemini\\tmp\\e28ee0484ec4cae024692ec5e73476d86df6b49984f53c9f0519d586dbfc0130\nI'm currently working in the directory: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\nHere is the folder structure of the current working directories:\n\nShowing up to 200 items (files + folders). Folders or files indicated with ... contain more items not shown, were ignored, or the display limit (200 items) was reached.\n\nC:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\\n├───.gitignore\n├───config.xlaunch\n├───docker-compose.yml\n├───Dockerfile\n├───file_io.c\n├───file_io.h\n├───game_logic.c\n├───game_logic.h\n├───gemini.md\n├───generate_setup_2von3.py\n├───generate_setup.py\n├───gui.c\n├───gui.h\n├───main.c\n├───project-logfile.md\n├───README.md\n├───setup_bio_readme.md\n├───setup.bio\n├───test_logic.c\n├───.git\\...\n├───biotope_results\\\n├───docs\\\n│   ├───ADR-0000-template.md\n│   ├───ADR-0001-competitive-biotope-mode.md\n│   ├───ADR-0002-biotope-ui-system.md\n│   ├───ADR-0003-integrated-simulation-protocol.md\n│   ├───DEV_SPEC-0000-template.md\n│   ├───DEV_SPEC-0001-competitive-biotope-mode.md\n│   ├───DEV_SPEC-0002-biotope-ui-system.md\n│   ├───DEV_SPEC-0003-integrated-simulation-protocol.md\n│   ├───DEV_TASKS-0000-template.md\n│   ├───DEV_TASKS-0001-competitive-biotope-mode.md\n│   ├───DEV_TASKS-0002-biotope-ui-system.md\n│   ├───DEV_TASKS-0003-integrated-simulation-protocol.md\n│   ├───DEV_TECH_DESIGN-0000-template.md\n│   ├───DEV_TECH_DESIGN-0001-competitive-biotope-mode.md\n│   ├───DEV_TECH_DESIGN-0002-biotope-ui-system.md\n│   ├───DEV_TECH_DESIGN-0003-integrated-simulation-protocol.md\n│   ├───PERFORMANCE_REPORT_UI.md\n│   └───gemini_protocol\\\n│       ├───biotop_260108.md\n│       ├───biotop_260109.md\n│       ├───biotop_260109a.md\n│       ├───biotop_260109b.json\n│       ├───biotop_260109b.md\n│       ├───biotop_260109c.json\n│       ├───biotop_260109c.md\n│       ├───biotop_260117.json\n│       └───biotop_260117.md\n└───utilities\\\n\nReminder: Do not return an empty response when a tool call is required.\n\nMy setup is complete. I will provide my first command in the next turn."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "@game_logic.c Bitte erkläre     #define COUNT_NEIGHBOR(idx) \\\n        if (current_gen->grid[idx] == TEAM_RED) red_neighbors++; \\\n        else if (current_gen->grid[idx] == TEAM_BLUE) blue_neighbors++;"
      },
      {
        "text": "\n--- Content from referenced files ---"
      },
      {
        "text": "\nContent from @game_logic.c:\n"
      },
      {
        "text": "#include <stdlib.h>\n#include <time.h>\n#include \"game_logic.h\"\n\n// KI-Agent unterstützt\nWorld* create_world(int rows, int cols) {\n    World *w = malloc(sizeof(World));\n    w->rows = rows;\n    w->cols = cols;\n    w->grid = malloc(rows * cols * sizeof(int));\n    return w;\n}\n\n// KI-Agent unterstützt\nvoid free_world(World *w) {\n    if (w) {\n        if (w->grid) free(w->grid);\n        free(w);\n    }\n}\n\n// KI-Agent unterstützt\nvoid init_world(World *current_gen, int rows, int cols) {\n    // Initialisiere den Zufallszahlengenerator mit der aktuellen Zeit\n    srand(time(NULL));\n    for (int i = 0; i < (rows * cols); i++) {\n        int val = rand() % 100;\n        if (val < 10) {\n            current_gen->grid[i] = TEAM_RED;\n        } else if (val < 20) {\n            current_gen->grid[i] = TEAM_BLUE;\n        } else {\n            current_gen->grid[i] = DEAD;\n        }\n    }\n}\n\n// KI-Agent unterstützt\nvoid update_generation(World *current_gen, World *next_gen, int rows, int cols) {\n    // Macro to check a neighbor index and increment counters\n    // Using a macro avoids function call overhead in the tight loop\n    #define COUNT_NEIGHBOR(idx) \\\n        if (current_gen->grid[idx] == TEAM_RED) red_neighbors++; \\\n        else if (current_gen->grid[idx] == TEAM_BLUE) blue_neighbors++;\n\n    for (int i = 0; i < (rows * cols); i++) {\n        int red_neighbors = 0;\n        int blue_neighbors = 0;\n\n        // --- Neighbor Counting (Unrolled for Edges) ---\n\n        // Sonderfall: i = Eckzelle oben, links\n        if (i == 0) {\n            COUNT_NEIGHBOR(i + (cols * rows) - 1);           // oberhalb, links\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)));         // oberhalb, mittig\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) + 1);     // oberhalb, rechts\n            COUNT_NEIGHBOR(i + cols - 1);                    // links\n            COUNT_NEIGHBOR(i + 1);                           // rechts\n            COUNT_NEIGHBOR(i + cols + cols - 1);             // unterhalb, links\n            COUNT_NEIGHBOR(i + cols);                        // unterhalb, mittig\n            COUNT_NEIGHBOR(i + cols + 1);                    // unterhalb, rechts\n        }\n        // Sonderfall: i = Eckzelle oben, rechts\n        else if (i == (cols - 1)) {\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) - 1);     // oberhalb, links\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)));         // oberhalb, mittig\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) - cols + 1); // oberhalb, rechts\n            COUNT_NEIGHBOR(i - 1);                           // links\n            COUNT_NEIGHBOR(i - (cols - 1));                  // rechts\n            COUNT_NEIGHBOR(i + cols - 1);                    // unterhalb, links\n            COUNT_NEIGHBOR(i + cols);                        // unterhalb, mittig\n            COUNT_NEIGHBOR(i + 1);                           // unterhalb, rechts\n        }\n        // Sonderfall i = Eckzelle unten, rechts\n        else if (i == (cols * rows - 1)) {\n            COUNT_NEIGHBOR(i - cols - 1);                    // oberhalb, links\n            COUNT_NEIGHBOR(i - cols);                        // oberhalb, mittig\n            COUNT_NEIGHBOR(i - cols - (cols - 1));           // oberhalb, rechts\n            COUNT_NEIGHBOR(i - 1);                           // links\n            COUNT_NEIGHBOR(i - (cols - 1));                  // rechts\n            COUNT_NEIGHBOR(i - (cols * (rows - 1)) - 1);     // unterhalb, links\n            COUNT_NEIGHBOR(i - (cols * (rows - 1)));         // unterhalb, mittig\n            COUNT_NEIGHBOR(i - (cols * (rows)) + 1);         // unterhalb, rechts\n        }\n        // Sonderfall: i = Eckzelle unten, links\n        else if (i == (cols * (rows - 1))) {\n            COUNT_NEIGHBOR(i - 1);                           // oberhalb, links\n            COUNT_NEIGHBOR(i - cols);                        // oberhalb, mittig\n            COUNT_NEIGHBOR(i - cols + 1);                    // oberhalb, rechts\n            COUNT_NEIGHBOR(i + (cols - 1));                  // links\n            COUNT_NEIGHBOR(i + 1);                           // rechts\n            COUNT_NEIGHBOR(i - (cols * (rows - 2)) - 1);     // unterhalb, links\n            COUNT_NEIGHBOR(i - (cols * (rows - 1)));         // unterhalb, mittig\n            COUNT_NEIGHBOR(i - (cols * (rows -1)) + 1);      // unterhalb, rechts\n        }\n        // Sonderfall: i = Zelle am oberen Rand\n        else if (i > 0 && i < cols) {\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) - 1);\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)));\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) + 1);\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1);\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1);\n        }\n        // Sonderfall: i = Zelle am unteren Rand\n        else if (i > (cols * (rows - 1))) {\n            // Nachbarn OBEN (ganz normal)\n            COUNT_NEIGHBOR(i - cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1);\n            \n            // Nachbarn SEITE\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1);\n            \n            // Nachbarn UNTEN (Wrap to Top Row)\n            int top_row_idx = i - (cols * (rows - 1));\n            COUNT_NEIGHBOR(top_row_idx - 1);\n            COUNT_NEIGHBOR(top_row_idx);\n            COUNT_NEIGHBOR(top_row_idx + 1);\n        }\n        // Sonderfall: i = Zelle am linken Rand\n        else if (i != 0 && i % cols == 0) {\n            COUNT_NEIGHBOR(i - cols + cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1);\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + 1);\n            COUNT_NEIGHBOR(i + cols + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1);\n        }\n        // Sonderfall: i = Zelle am rechten Rand\n        else if ((i + 1) % cols == 0) {\n            COUNT_NEIGHBOR(i - cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1 - (cols));\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1 - (cols));\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1 - (cols));\n        }\n        // Zellen innerhalb Spielfeld\n        else {\n            COUNT_NEIGHBOR(i - cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1);\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1);\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1);\n        }\n\n        // --- Evolution Rules ---\n        int total_neighbors = red_neighbors + blue_neighbors;\n        int current_cell = current_gen->grid[i];\n        \n        if (current_cell != DEAD) {\n            // SURVIVAL: 2 or 3 neighbors -> stay alive\n            if (total_neighbors == 2 || total_neighbors == 3) {\n                next_gen->grid[i] = current_cell;\n            } else {\n                next_gen->grid[i] = DEAD;\n            }\n        }\n        else {\n            // BIRTH: exactly 3 neighbors -> become alive\n            if (total_neighbors == 3) {\n                // Determine color by majority\n                if (red_neighbors > blue_neighbors) {\n                    next_gen->grid[i] = TEAM_RED;\n                } else {\n                    next_gen->grid[i] = TEAM_BLUE;\n                }\n            } else {\n                next_gen->grid[i] = DEAD;\n            }\n        }\n    }\n    #undef COUNT_NEIGHBOR\n}"
      },
      {
        "text": "\n--- End of content ---"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "text": "Dieser Code-Ausschnitt definiert ein Makro für den C-Präprozessor, das als Hilfsfunktion zur Nachbarschaftsanalyse in einer \"Game of Life\"-Simulation dient.\n\n**1. Was macht der Code?**\nDas Makro `COUNT_NEIGHBOR` prüft den Zustand einer Zelle an einer bestimmten Position (`idx`) im Spielfeld. Wenn die Zelle zum roten Team gehört, wird ein Zähler für rote Nachbarn erhöht; gehört sie zum blauen Team, wird der Zähler für blaue Nachbarn erhöht. Es automatisiert also das Zählen von Nachbarn unterschiedlicher Fraktionen für eine einzelne Position.\n\n**2. Welche Schlüsselworte/Anweisungen enthält der Code?**\n*   **`#define`**: Eine Präprozessor-Direktive, die dem Compiler sagt: \"Ersetze überall im folgenden Code `COUNT_NEIGHBOR(idx)` durch diesen Textblock\".\n*   **`if` / `else if`**: Bedingte Anweisungen, die entscheiden, welcher Zähler erhöht wird.\n*   **`==`**: Der Vergleichsoperator, um den Inhalt der Gitterzelle mit den Team-Konstanten zu vergleichen.\n*   **`++`**: Der Inkrement-Operator, der den Wert der Zählvariablen um 1 erhöht.\n*   **`\\` (Backslash)**: Ein Zeilenfortsetzungszeichen. Da Makros normalerweise in einer Zeile stehen müssen, erlaubt der Backslash eine übersichtliche Schreibweise über mehrere Zeilen.\n\n**3. Welche Struktur besitzt der Code?**\nEs handelt sich um ein **parametrisiertes Makro**. Es ähnelt einer Funktion, wird aber vor der eigentlichen Kompilierung direkt als Text in den Quellcode kopiert (\"Inlining\"). Innerhalb des Makros befindet sich eine einfache zweiseitige Auswahl (if-else-Struktur).\n\n**4. Was gibt es zu den Variablen zu sagen?**\n*   **`idx`**: Der Platzhalter (Parameter) für den Index im Spielfeld-Array. Er wird beim Aufruf des Makros durch den tatsächlichen Wert ersetzt.\n*   **`current_gen->grid[idx]`**: Greift auf das Array `grid` innerhalb der Struktur `current_gen` zu. Hier wird der aktuelle Zustand (TEAM_RED, TEAM_BLUE oder DEAD) der Zelle an Position `idx` gelesen.\n*   **`red_neighbors` / `blue_neighbors`**: Diese Variablen müssen an der Stelle, an der das Makro aufgerufen wird, bereits deklariert sein. Das Makro geht davon aus, dass diese Zähler existieren und verändert sie direkt (Seiteneffekt).\n*   **`TEAM_RED` / `TEAM_BLUE`**: Dies sind symbolische Konstanten (wahrscheinlich per `#define` oder `enum` definiert), die für bestimmte Zahlenwerte stehen.\n\n**5. Was sonst noch zu erwähnen wäre ...**\n*   **Effizienz**: Die Verwendung eines Makros spart hier den \"Overhead\" eines Funktionsaufrufs (Speichern von Registern, Sprungbefehle). Da dieser Code innerhalb einer Schleife für jede Zelle achtmal aufgerufen wird, ist dies eine gängige Optimierung.\n*   **Gefahr**: Makros haben keinen eigenen Gültigkeitsbereich (Scope). Wenn die Variablen `red_neighbors` oder `blue_neighbors` am Aufort nicht existieren, meldet der Compiler einen Fehler.\n*   **Wartbarkeit**: Am Ende der Funktion `update_generation` wird das Makro mit `#undef COUNT_NEIGHBOR` wieder gelöscht, damit es in anderen Teilen des Programms nicht versehentlich zu Namenskonflikten führt."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "In der Codebase gibt es folgende Dateien.\nfile_io.c file_io.h\ngame_logic.c game_logic.h\ngui.c gui.h\ntest_logic.c main.c\nWie hängen diese Dateien zusammen und bilden letztendlich das Programm in C? Gibt es für die Ausführung obsolete Dateien? Was ist der Unterschied zwischen einer .c und einer .h Datei?"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "thoughtSignature": "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",
        "text": "Gerne, das erkläre ich dir für einen Studenten im 1. Semester:\n\n### Wie die Dateien zusammenhängen und das Programm bilden\n\nIn C-Projekten ist es üblich, den Code in mehrere `.c`-Dateien und `.h`-Dateien aufzuteilen. Jede `.c`-Datei (Quelldatei) implementiert bestimmte Funktionen, und die zugehörige `.h`-Datei (Header-Datei) deklariert diese Funktionen und Datenstrukturen.\n\nSo wirken deine Dateien zusammen, um das \"Game of Life\"-Programm zu bilden:\n\n1.  **`main.c`**:\n    *   Dies ist der Startpunkt deines Programms. Wenn du das Programm ausführst, beginnt die Ausführung in der `main`-Funktion in dieser Datei.\n    *   `main.c` wird andere Header-Dateien wie `game_logic.h`, `file_io.h` und `gui.h` inkludieren (`#include`), um deren Funktionen nutzen zu können. Es ist der \"Dirigent\", der die verschiedenen Teile des Programms aufruft.\n\n2.  **`game_logic.c` und `game_logic.h`**:\n    *   **`game_logic.h`**: Deklariert alle Funktionen und Datenstrukturen, die die Spielregeln des \"Game of Life\" betreffen (z.B. wie eine neue Welt erstellt, initialisiert oder die nächste Generation berechnet wird).\n    *   **`game_logic.c`**: Enthält die tatsächliche Implementierung (den \"Code\") dieser deklarierten Funktionen. Hier steht, *wie* die Spielregeln umgesetzt werden.\n    *   `main.c` (und eventuell `gui.c`, wenn die GUI direkt auf Spiellogik zugreifen muss) wird `game_logic.h` einbinden, um die Logikfunktionen aufrufen zu können.\n\n3.  **`file_io.c` und `file_io.h`**:\n    *   **`file_io.h`**: Deklariert Funktionen für alle Dateioperationen (Input/Output). Das könnte das Laden eines Start-Setups für das Spielfeld aus einer Datei oder das Speichern des aktuellen Zustands sein.\n    *   **`file_io.c`**: Implementiert diese Dateioperationsfunktionen.\n    *   `main.c` oder `game_logic.c` könnten `file_io.h` einbinden, um Daten zu lesen oder zu schreiben.\n\n4.  **`gui.c` und `gui.h`**:\n    *   **`gui.h`**: Deklariert Funktionen, die für die grafische Benutzeroberfläche (Graphical User Interface) verantwortlich sind. Das beinhaltet zum Beispiel Funktionen zum Zeichnen des Spielfelds auf dem Bildschirm, zum Verarbeiten von Maus- oder Tastatureingaben.\n    *   **`gui.c`**: Implementiert die eigentliche Grafikdarstellung und Interaktion.\n    *   `main.c` wird `gui.h` einbinden, um die Spielwelt darzustellen und Benutzereingaben zu verarbeiten.\n\n5.  **`test_logic.c`**:\n    *   Diese Datei enthält wahrscheinlich Testfälle für die Spiellogik, die in `game_logic.c` implementiert ist. Sie wird `game_logic.h` einbinden, um die Spiellogikfunktionen zu testen.\n    *   **Zusammenfassung der Programmbildung:**\n        1.  Du schreibst den Code in `.c`-Dateien und deren Deklarationen in `.h`-Dateien.\n        2.  Ein **Compiler** übersetzt jede `.c`-Datei einzeln in eine Objektdatei (`.o` oder `.obj`). Dabei werden die `#include`-Anweisungen im Grunde durch den Inhalt der Header-Dateien ersetzt.\n        3.  Ein **Linker** nimmt alle Objektdateien und die notwendigen Bibliotheken (wie für Grafik oder Dateizugriff) und fügt sie zu einem einzigen ausführbaren Programm (`.exe` unter Windows) zusammen.\n\n### Gibt es für die Ausführung obsolete Dateien?\n\nJa, für die *normale Ausführung* des fertigen \"Game of Life\"-Programms ist die Datei **`test_logic.c`** im Allgemeinen nicht notwendig.\n\n*   `test_logic.c` wird verwendet, um sicherzustellen, dass die Spiellogik korrekt funktioniert, d.h. während der Entwicklung. Du würdest diese Datei kompilieren und ausführen, um Tests durchzuführen.\n*   Das Endprodukt, das der Benutzer spielt, wird typischerweise ohne die Testcode-Datei kompiliert, da dieser Code zur Laufzeit nicht benötigt wird. Manchmal wird sie aber auch mitkompiliert, wenn die Tests direkt im Programm aufgerufen werden können (z.B. als Debugging-Modus).\n\n### Was ist der Unterschied zwischen einer `.c` und einer `.h` Datei?\n\nStell dir das wie folgt vor:\n\n*   **`.h`-Datei (Header-Datei): Die Speisekarte / Das Inhaltsverzeichnis**\n    *   Sie enthält **Deklarationen**: Das ist wie eine Liste der Funktionen, die in den zugehörigen `.c`-Dateien existieren und verwendet werden können. Es sagt dir nur den Namen der Funktion, welche Eingaben sie erwartet und welchen Typ von Ergebnis sie liefert – aber nicht *wie* sie das macht.\n    *   Sie definiert auch Datenstrukturen (wie `struct World`), die du verwenden kannst.\n    *   Der Zweck ist, anderen `.c`-Dateien zu sagen, \"was\" verfügbar ist, ohne ihnen alle Implementierungsdetails zu zeigen.\n\n*   **`.c`-Datei (Quelldatei): Das Rezeptbuch / Die Implementierung**\n    *   Sie enthält **Definitionen**: Das ist der eigentliche Code, der beschreibt, *wie* jede Funktion funktioniert. Hier sind die Anweisungen Schritt für Schritt aufgeführt.\n    *   Jede `.c`-Datei **inkludiert** ihre eigene `.h`-Datei (und die `.h`-Dateien anderer Module, deren Funktionen sie nutzen möchte), um sicherzustellen, dass die Deklarationen bekannt sind, bevor die Funktionen definiert oder aufgerufen werden.\n\nDieser Ansatz hilft dabei, große Programme zu organisieren, Abhängigkeiten zu kontrollieren und die Kompilierungszeiten zu verkürzen, da nicht bei jeder kleinen Änderung der gesamte Code neu übersetzt werden muss."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre \n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\nin @gui.c"
      },
      {
        "text": "\n--- Content from referenced files ---"
      },
      {
        "text": "\nContent from @gui.c:\n"
      },
      {
        "text": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterstützt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n// Current Run Tracking\nstatic char currentProtocolFilename[256] = \"\";\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterstützt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterstützt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterstützt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {\n    int team;\n    int midCol = c->cols / 2;\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterstützt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\");\n    SetTargetFPS(60);\n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {\n            case STATE_CONFIG:\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;\n                }\n                \n                // KI-Agent unterstützt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;\n\n            case STATE_LOAD:\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                break;\n            \n            case STATE_RUNNING:\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterstützt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n                \n                // KI-Agent unterstützt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterstützt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterstützt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterstützt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n                    \n                    if (sel->has_results) {\n                        DrawLine(previewX - 10, 260, previewX + 250, 260, Fade(THEME_TEXT, 0.3f));\n                        DrawText(\"RESULTS:\", previewX, 270, 20, THEME_HIGHLIGHT);\n                        \n                        if (sel->winner == 1) DrawText(\"WINNER: RED\", previewX, 300, 20, THEME_RED);\n                        else if (sel->winner == 2) DrawText(\"WINNER: BLUE\", previewX, 300, 20, THEME_BLUE);\n                        else DrawText(\"WINNER: DRAW\", previewX, 300, 20, DARKGRAY);\n                        \n                        char scoreBuf[64];\n                        sprintf(scoreBuf, \"R:%d  B:%d\", sel->final_red, sel->final_blue);\n                        DrawText(scoreBuf, previewX, 330, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"NO RESULTS YET\", previewX, 270, 18, DARKGRAY);\n                    }\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 380, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterstützt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}"
      },
      {
        "text": "\n--- End of content ---"
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "A"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "text": "Dieser Code-Abschnitt bereitet die grundlegenden Einstellungen (die \"Konfiguration\") für das Programm vor, bevor das eigentliche Fenster oder die Simulation startet.\n\n**1. Was macht der Code?**\nDer Code legt zwei Dinge fest:\n1.  In welchem Modus (Zustand) die Anwendung starten soll (hier: im Konfigurationsmenü).\n2.  Welche Standardwerte für das Spiel gelten sollen (wie groß ist das Spielfeld, wie schnell läuft es, etc.).\n\n**2. Welche Schlüsselworte/Anweisungen enthält der Code?**\n*   **`AppState` / `GameConfig`**: Das sind benutzerdefinierte Datentypen. `AppState` ist wahrscheinlich ein `enum` (eine Aufzählung von Zuständen), und `GameConfig` ist ein `struct` (eine Struktur, die mehrere verschiedene Werte zusammenfasst).\n*   **`=` (Zuweisungsoperator)**: Damit werden die Werte in die Variablen geschrieben.\n*   **`{ ... }` (Initialisierungsliste)**: Alles, was in den geschweiften Klammern steht, gehört zusammen zur Struktur `config`.\n*   **`.rows = 50` (Designated Initializer)**: Dies ist eine moderne C-Schreibweise (seit C99). Sie sagt explizit: \"Suche in der Struktur das Feld `rows` und setze es auf 50\". Das ist sicherer und lesbarer als nur die Zahlen der Reihe nach aufzuschreiben.\n\n**3. Welche Struktur besitzt der Code?**\nEs handelt sich um zwei **Variablendeklarationen mit gleichzeitiger Initialisierung**:\n*   Zuerst eine einfache Variable (`state`).\n*   Dann eine komplexe Strukturvariable (`config`), die aus vielen Unter-Variablen besteht.\n\n**4. Was gibt es zu den Variablen zu sagen?**\n*   **`state`**: Diese Variable steuert die Programmlogik. Mit `STATE_CONFIG` weiß das Programm: \"Zeige zuerst das Einstellungsmenü an\". Später wird dieser Wert auf `STATE_EDIT` oder `STATE_RUNNING` geändert.\n*   **`config`**: Dies ist der \"Werkzeugkasten\" mit allen Regeln:\n    *   `rows` / `cols`: Das Spielfeld ist 50x50 Felder groß.\n    *   `delay_ms`: Zwischen zwei Schritten liegen 100 Millisekunden (die Geschwindigkeit).\n    *   `max_population`: Jedes Team darf maximal 100 Zellen gleichzeitig haben.\n    *   `max_rounds`: Nach 1000 Schritten stoppt die Simulation automatisch.\n    *   `current_...`: Diese Werte stehen auf 0, weil zu Beginn noch keine Runde gespielt wurde und noch keine Zellen auf dem Feld sind.\n\n**5. Was sonst noch zu erwähnen wäre ...**\nDurch diese zentrale Stelle am Anfang der Funktion `run_gui_app` kann man das Verhalten des Spiels sehr leicht ändern. Wenn du möchtest, dass das Spiel langsamer läuft, müsstest du nur die `100` bei `delay_ms` in einen höheren Wert ändern. Es ist gute Programmierpraxis, solche \"Standardwerte\" gesammelt an einer Stelle zu definieren, statt sie später im Code zu verstecken."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre\n// --- Logic per State ---\n        switch (state) {\n            case STATE_CONFIG:\nin @gui.c"
      },
      {
        "text": "\n--- Content from referenced files ---"
      },
      {
        "text": "\nContent from @gui.c:\n"
      },
      {
        "text": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterstützt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n// Current Run Tracking\nstatic char currentProtocolFilename[256] = \"\";\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterstützt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterstützt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterstützt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {\n    int team;\n    int midCol = c->cols / 2;\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterstützt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\");\n    SetTargetFPS(60);\n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {\n            case STATE_CONFIG:\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;\n                }\n                \n                // KI-Agent unterstützt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation with Auto-Save\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;\n                }\n                break;\n\n            case STATE_LOAD:\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                break;\n            \n            case STATE_RUNNING:\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterstützt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n                \n                // KI-Agent unterstützt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 300, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterstützt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterstützt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterstützt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n                    \n                    if (sel->has_results) {\n                        DrawLine(previewX - 10, 260, previewX + 250, 260, Fade(THEME_TEXT, 0.3f));\n                        DrawText(\"RESULTS:\", previewX, 270, 20, THEME_HIGHLIGHT);\n                        \n                        if (sel->winner == 1) DrawText(\"WINNER: RED\", previewX, 300, 20, THEME_RED);\n                        else if (sel->winner == 2) DrawText(\"WINNER: BLUE\", previewX, 300, 20, THEME_BLUE);\n                        else DrawText(\"WINNER: DRAW\", previewX, 300, 20, DARKGRAY);\n                        \n                        char scoreBuf[64];\n                        sprintf(scoreBuf, \"R:%d  B:%d\", sel->final_red, sel->final_blue);\n                        DrawText(scoreBuf, previewX, 330, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"NO RESULTS YET\", previewX, 270, 18, DARKGRAY);\n                    }\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 380, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterstützt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}"
      },
      {
        "text": "\n--- End of content ---"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "text": "Dieser Code-Schnipsel ist das Herzstück der Programmsteuerung innerhalb der Hauptschleife (Game Loop). Er entscheidet 60 Mal pro Sekunde, welcher Teil des Programms gerade aktiv sein soll.\n\n**1. Was macht der Code?**\nEr prüft den Inhalt der Variable `state` und verzweigt dann in den entsprechenden Code-Block.\n*   Wenn `state` gerade auf `STATE_CONFIG` steht, wird der Code ausgeführt, der das Einstellungsmenü steuert (Tastatureingaben für Gittergröße, Geschwindigkeit usw.).\n*   Wäre `state` z.B. auf `STATE_RUNNING`, würde ein anderer Block (weiter unten im Code) ausgeführt, der die Simulation berechnet.\nMan nennt dies eine **State Machine (Zustandsautomat)**. Das Programm befindet sich immer in genau einem Zustand (z.B. Menü, Spiel, Pause) und verhält sich dementsprechend.\n\n**2. Welche Schlüsselworte/Anweisungen enthält der Code?**\n*   **`switch (...)`**: Eine Kontrollstruktur, die eine Variable auf verschiedene mögliche Werte prüft. Sie ist oft übersichtlicher als viele verschachtelte `if` / `else if` Anweisungen.\n*   **`case ... :`**: Markiert den Einstiegspunkt für einen bestimmten Wert. Hier: \"Im Fall, dass `state` gleich `STATE_CONFIG` ist, mach hier weiter\".\n*   (Nicht im Schnipsel, aber dazugehörig) **`break;`**: Am Ende eines `case`-Blocks steht meist ein `break`, um den `switch`-Block zu verlassen und nicht versehentlich in den nächsten Fall \"hineinzufallen\".\n\n**3. Welche Struktur besitzt der Code?**\nDer Code ist Teil einer **Mehrfachauswahl** innerhalb der `while`-Schleife.\nStrukturell sieht das Ganze so aus:\n1.  Prüfe Zustand (`switch`).\n2.  Führe Logik für diesen Zustand aus (Tasten drücken, Werte ändern).\n3.  Zeichne das Bild für diesen Zustand (weiter unten im Code beim `BeginDrawing`).\n\n**4. Was gibt es zu den Variablen zu sagen?**\n*   **`state`**: Diese Variable fungiert als das \"Gedächtnis\" des Programms. Sie merkt sich, wo sich der Benutzer gerade befindet.\n*   **`STATE_CONFIG`**: Das ist eine Konstante (wahrscheinlich aus einem `enum` in `gui.h`), die für den Zustand \"Konfigurationsmenü\" steht. Durch solche sprechenden Namen wird der Code viel lesbarer als wenn dort einfach eine Zahl wie `0` oder `1` stünde.\n\n**5. Was sonst noch zu erwähnen wäre ...**\nDiese Trennung ist extrem wichtig für sauberen Code in der Spieleprogrammierung. Ohne diesen `switch` hättest du einen riesigen Haufen Code, in dem sich Logik für das Menü mit der Logik für die Simulation vermischt. So ist alles schön in \"Schubladen\" (Cases) sortiert."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Danke. Deine letzte Erklärung war sehr hilfreich. Ein Gedanke zur Optimierung der Ausführungsgeschwindigkeit in form einer Frage. Ist es nicht Zeitverschwendung, 60 mal in einer Sekunde alle möglichen 'state's zu prüfen, obwohl es klar ist, dass wenn das Spiel sich im state = STATE_RUNNING befindet es erst wieder einen anderen state geben kann, wenn eine bestimmte Bedingung für das Ende von STATE_RUNNING erreicht ist?"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "text": "Das ist eine **exzellente Frage**! Sie zeigt, dass du dir Gedanken über Effizienz machst – genau das, was ein Informatiker tun sollte.\n\nDie kurze Antwort ist: **Nein, in diesem Fall ist es keine Zeitverschwendung, sondern architektonisch sogar notwendig.**\n\nHier ist die Erklärung für einen Erstsemester-Studenten, warum wir das so machen:\n\n### 1. Das \"Game Loop\"-Prinzip (Die Illusion der Bewegung)\nEin Spiel (oder eine grafische Anwendung wie diese) funktioniert wie ein Daumenkino. Damit das Bild flüssig wirkt und das Fenster auf Eingaben (Maus, Tastatur) reagiert, **muss** die Schleife etwa 60 Mal pro Sekunde komplett durchlaufen werden.\n\nWürden wir sagen: *\"Bleib im `STATE_RUNNING` und mach dort eine eigene Endlosschleife, bis wir fertig sind\"*, würde folgendes passieren:\n*   Das Programm würde \"einfrieren\".\n*   Das Betriebssystem (Windows) würde denken, das Programm sei abgestürzt (\"Keine Rückmeldung\"), weil die Hauptschleife keine Nachrichten mehr verarbeitet.\n*   Du könntest das Spiel nicht abbrechen (z.B. mit 'Q'), weil die Tastaturabfrage nur einmal pro Frame ganz kurz passiert.\n\nWir **müssen** also jeden Frame kurz prüfen: *\"Was ist zu tun?\"*, es tun (z.B. einen Simulationsschritt rechnen oder nur zeichnen), und dann sofort die Kontrolle zurückgeben, damit das Bild neu gemalt werden kann.\n\n### 2. Wie ein `switch` funktioniert (Compiler-Magie)\nDu hast recht, dass viele `if-else`-Abfragen langsam wären. Aber ein `switch`-Statement in C ist sehr schlau optimiert:\n\n*   **Der naive Weg (If-Else):**\n    *   Ist es 1? Nein.\n    *   Ist es 2? Nein.\n    *   Ist es 3? Ja -> Führe Code aus.\n*   **Der Switch-Weg (Sprungtabelle):**\n    Der Compiler baut eine sogenannte **Jump Table**. Stell dir das wie ein Inhaltsverzeichnis vor. Der Prozessor schaut auf den Wert von `state` (z.B. 3) und springt **sofort** an die richtige Speicheradresse.\n    Es ist also fast egal, ob du 5 oder 100 States hast – der Sprung dauert immer fast gleich kurz (wenige Nanosekunden). Das fällt bei 60 Frames pro Sekunde (16,6 Millisekunden pro Frame) überhaupt nicht ins Gewicht.\n\n### 3. Zusammenfassung\nWir opfern diese winzigen Nanosekunden für die Prüfung des `state`, gewinnen dafür aber:\n1.  **Reaktionsfähigkeit:** Das Programm kann jederzeit auf 'Q' oder Mausbewegungen reagieren.\n2.  **Saubere Struktur:** Jeder Frame ist ein neues \"Blatt Papier\", das basierend auf dem aktuellen Zustand neu gemalt wird.\n\n**Fazit:**\nDeine Intuition ist richtig: *Unnötige Checks vermeiden*.\nAber in der **Ereignis-basierten Programmierung** (GUI, Spiele) ist der Zustandcheck der Preis, den wir für ein flüssiges, reagierendes Fenster zahlen."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre\n// --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\nIch verstehe, wie update_generation() funktioniert. Was mir nicht klar ist, ist wie die neu berechneten Werte aus next_gen in die aktuelle zu zeichnende Generation gelangt. Geschieht das hier in diesem Snippet in STATE_RUNNING, oder anderswo?"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "text": "Du hast den entscheidenden Punkt genau erfasst! Die Antwort lautet: **Ja, es passiert genau in diesem Snippet**, und zwar durch eine Technik, die man **Pointer-Swapping** nennt.\n\nHier ist die Erklärung für einen Erstsemester-Studenten:\n\n### 1. Was macht der Code?\nDieser Code steuert den \"Herzschlag\" der Simulation. Er sorgt dafür, dass nicht bei jedem der 60 Grafik-Frames pro Sekunde eine neue Generation berechnet wird (das wäre viel zu schnell), sondern nur nach einer bestimmten Wartezeit (`delay_ms`). Wenn diese Zeit abgelaufen ist, wird die Welt aktualisiert.\n\n### 2. Welche Schlüsselworte/Anweisungen enthält der Code?\n"
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "A"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "text": "Hier ist die Fortsetzung der Erklärung für das Snippet in `STATE_RUNNING`. Deine Vermutung ist absolut richtig: Der \"Transfer\" passiert genau hier durch einen geschickten Trick mit Zeigern (Pointern).\n\n**1. Was macht der Code?**\nDer Code fungiert als Zeitwächter und Logistik-Manager. Er zählt die vergangene Zeit (`timeAccumulator`). Sobald genug Zeit verstrichen ist (das `delay_ms`), beauftragt er die Berechnung der nächsten Generation, löscht die alte Welt und macht die neue Welt zur \"aktuellen\" Welt.\n\n**2. Welche Schlüsselworte/Anweisungen enthält der Code?**\n*   **`static`**: Das ist extrem wichtig! Eine `static`-Variable innerhalb einer Funktion \"vergisst\" ihren Wert nicht, wenn die Funktion endet. Sie bleibt im Speicher bestehen. Ohne `static` würde der `timeAccumulator` 60 Mal pro Sekunde wieder bei 0.0 starten.\n*   **`GetFrameTime()`**: Eine Funktion der Grafik-Bibliothek (raylib), die uns sagt, wie viele Millisekunden der letzte Frame (der letzte Durchlauf der Schleife) gedauert hat.\n*   **`free_world(...)`**: Gibt den Speicher der alten Generation frei, um \"Memory Leaks\" (Speicherfresser) zu verhindern.\n\n**3. Welche Struktur besitzt der Code?**\nEs ist ein **Timer-gesteuerter Ablauf**:\n1. Zeit aufsummieren.\n2. Prüfen, ob das Limit erreicht ist.\n3. Wenn ja: Berechnen -> Altes löschen -> **Pointer umbiegen** -> Statistiken zählen -> Prüfen, ob das Spiel vorbei ist.\n\n**4. Was gibt es zu den Variablen zu sagen?**\n*   **`timeAccumulator`**: Sammelt die Sekundenbruchteile, bis sie groß genug für einen Simulationsschritt sind.\n*   **`next_gen`**: Ein lokaler Zeiger, der temporär die frisch berechnete Welt hält.\n*   **`gui_world`**: Das ist die **globale Variable** (außerhalb der Funktion definiert). Sie ist der \"Anker\" für die grafische Darstellung.\n\n**5. Die Antwort auf deine Frage: Das \"Pointer-Swapping\"**\nHier passiert die \"Magie\", wie die neuen Werte in die Anzeige gelangen:\n1. `update_generation(gui_world, next_gen, ...)` berechnet aus der alten Welt (`gui_world`) die neue Welt (`next_gen`).\n2. `free_world(gui_world)` löscht die alte Welt aus dem Arbeitsspeicher.\n3. **`gui_world = next_gen;`**: Das ist die entscheidende Zeile. Der Zeiger `gui_world` (den die Zeichenfunktion `DrawGridAndCells` benutzt) zeigt jetzt einfach auf die Speicheradresse, an der die neuen Daten liegen.\n\n**Warum funktioniert das?**\nIn der Hauptschleife wird nach dem `switch(state)`-Block immer `BeginDrawing()` und dann `DrawGridAndCells(...)` aufgerufen. Da du den Zeiger `gui_world` in dem Moment umgebogen hast, greift die Zeichenfunktion im nächsten Moment automatisch auf die neuen Daten zu. Das ist extrem effizient, weil keine großen Datenmengen kopiert werden müssen – man ändert nur eine Adresse im Speicher.\n\n**Zusammenfassend:** Ja, der Transfer findet genau hier statt, indem du der grafischen Oberfläche sagst: \"Ab jetzt ist das hier dein Spielfeld!\"."
      }
    ]
  }
]