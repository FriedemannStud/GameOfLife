[
  {
    "role": "user",
    "parts": [
      {
        "text": "This is the Gemini CLI. We are setting up the context for our chat.\nToday's date is Samstag, 31. Januar 2026 (formatted according to the user's locale).\nMy operating system is: win32\nThe project's temporary directory is: C:\\Users\\Fried\\.gemini\\tmp\\e28ee0484ec4cae024692ec5e73476d86df6b49984f53c9f0519d586dbfc0130\nI'm currently working in the directory: C:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\nHere is the folder structure of the current working directories:\n\nShowing up to 200 items (files + folders). Folders or files indicated with ... contain more items not shown, were ignored, or the display limit (200 items) was reached.\n\nC:\\Users\\Fried\\OneDrive\\Studium\\Inf\\INF-Einf-B\\GameOfLife\\\n├───.gitignore\n├───config.xlaunch\n├───docker-compose.yml\n├───Dockerfile\n├───file_io.c\n├───file_io.h\n├───game_logic.c\n├───game_logic.h\n├───gemini.md\n├───generate_setup_2von3.py\n├───generate_setup.py\n├───gui.c\n├───gui.h\n├───main_original\n├───main_original.c\n├───main.c\n├───project-logfile.md\n├───README.md\n├───setup_bio_readme.md\n├───setup.bio\n├───test_logic.c\n├───.git\\...\n├───biotope_results\\\n├───docs\\\n│   ├───ADR-0000-template.md\n│   ├───ADR-0001-competitive-biotope-mode.md\n│   ├───ADR-0002-biotope-ui-system.md\n│   ├───ADR-0003-integrated-simulation-protocol.md\n│   ├───DEV_SPEC-0000-template.md\n│   ├───DEV_SPEC-0001-competitive-biotope-mode.md\n│   ├───DEV_SPEC-0002-biotope-ui-system.md\n│   ├───DEV_SPEC-0003-integrated-simulation-protocol.md\n│   ├───DEV_TASKS-0000-template.md\n│   ├───DEV_TASKS-0001-competitive-biotope-mode.md\n│   ├───DEV_TASKS-0002-biotope-ui-system.md\n│   ├───DEV_TASKS-0003-integrated-simulation-protocol.md\n│   ├───DEV_TECH_DESIGN-0000-template.md\n│   ├───DEV_TECH_DESIGN-0001-competitive-biotope-mode.md\n│   ├───DEV_TECH_DESIGN-0002-biotope-ui-system.md\n│   ├───DEV_TECH_DESIGN-0003-integrated-simulation-protocol.md\n│   ├───PERFORMANCE_REPORT_UI.md\n│   ├───gemini_protocol\\\n│   │   ├───biotop_260108.md\n│   │   ├───biotop_260109.md\n│   │   ├───biotop_260109a.md\n│   │   ├───biotop_260109b.json\n│   │   ├───biotop_260109b.md\n│   │   ├───biotop_260109c.json\n│   │   ├───biotop_260109c.md\n│   │   ├───biotop_260117.json\n│   │   ├───biotop_260117.md\n│   │   ├───biotop_260123.json\n│   │   └───biotop_260123.md\n│   └───Präsentation\\\n│       ├───C_Performance_Architecture_Biotop.pdf\n│       ├───Struktur.md\n│       └───C_Performance_Architecture_Biotop (1).pdf\\\n│           ├───C_Performance_Architecture_Biotop-01.jpg\n│           ├───C_Performance_Architecture_Biotop-02.jpg\n│           ├───C_Performance_Architecture_Biotop-03.jpg\n│           ├───C_Performance_Architecture_Biotop-04.jpg\n│           ├───C_Performance_Architecture_Biotop-05.jpg\n│           ├───C_Performance_Architecture_Biotop-06.jpg\n│           ├───C_Performance_Architecture_Biotop-07.jpg\n│           ├───C_Performance_Architecture_Biotop-08.jpg\n│           ├───C_Performance_Architecture_Biotop-09.jpg\n│           ├───C_Performance_Architecture_Biotop-10.jpg\n│           ├───C_Performance_Architecture_Biotop-11.jpg\n│           ├───C_Performance_Architecture_Biotop-12.jpg\n│           ├───C_Performance_Architecture_Biotop-13.jpg\n│           ├───C_Performance_Architecture_Biotop-14.jpg\n│           └───C_Performance_Architecture_Biotop-15.jpg\n└───utilities\\\n\nReminder: Do not return an empty response when a tool call is required.\n\nMy setup is complete. I will provide my first command in the next turn."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre // --- Theme Colors (Digital Lab) ---\n// KI-Agent unterstützt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\nin @gui.c"
      },
      {
        "text": "\n--- Content from referenced files ---"
      },
      {
        "text": "\nContent from @gui.c:\n"
      },
      {
        "text": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterstützt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n// Current Run Tracking\nstatic char currentProtocolFilename[256] = \"\";\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterstützt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterstützt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterstützt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {  \n    // Platziert vordefinierte Muster auf World \"w\"\n    // startR, startC = Startposition für Muster kommt von Mauspos\n    // type = welches Muster platziert werden soll\n    int team;\n    int midCol = c->cols / 2; // Mittellinie\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterstützt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\"); // Öffnet Startfenster - Header für Start-Window\n    SetTargetFPS(60); \n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {            // HIER geht's los! Game Loop/Hauptschleife \"WindowShouldClose\" = \"x\" oben-rechts in Win - Fenster\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {                 // Zustandsmaschine - Wert von State gibt Code-Block-Ausführung vor \n            case STATE_CONFIG:           // Spieleinstellungen mit Tasten im Fenster Biotope Configuration\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Presets \n                if (IsActionTriggered(KEY_ONE)) { // Schach Modus\n                    config.cols = 16;\n                    config.rows = 8;\n                    config.delay_ms = 500;\n                    config.max_rounds = 50;\n                    config.max_population = 30;\n                }\n                if (IsActionTriggered(KEY_TWO)) { // Outer Space Battle\n                    config.cols = 400;\n                    config.rows = 200;\n                    config.delay_ms = 100;\n                    config.max_rounds = 300;\n                    config.max_population = 1000;\n                }\n                if (IsActionTriggered(KEY_THREE)) { // Von Neumann\n                    config.cols = 1000;\n                    config.rows = 500;\n                    config.delay_ms = 0;\n                    config.max_rounds = 1000;\n                    config.max_population = 5000;\n                }\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:    // Startkonfiguration für Simulation auf Screen mit Maus setzen\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;  // Absprung alte Spiele laden\n                }\n                \n                // KI-Agent unterstützt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {    // Spielfeld wird mit Zufallsmuster gefüllt\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation initiale Belegung wird gespeichert \"....bio\"\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;   \n                }\n                break;\n\n            case STATE_LOAD:   // Alte Spielkonfigurationen laden\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;   \n                }\n                break;\n            \n            case STATE_RUNNING:  // Hier zurücklehnen und zuschauen\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterstützt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n\n\n                \n                // KI-Agent unterstützt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n\n                DrawText(\"PRESET\", 40, 300, 20, THEME_HIGHLIGHT);\n                DrawText(\"[1] CHESS\", 40, 335, 20, THEME_HIGHLIGHT);\n                DrawText(\"[2] OUTER SPACE BATTLE\", 40, 370, 20, THEME_HIGHLIGHT);\n                DrawText(\"[3] VON NEUMANN\", 40, 405, 20, THEME_HIGHLIGHT);\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 475, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterstützt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterstützt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterstützt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n                    \n                    if (sel->has_results) {\n                        DrawLine(previewX - 10, 260, previewX + 250, 260, Fade(THEME_TEXT, 0.3f));\n                        DrawText(\"RESULTS:\", previewX, 270, 20, THEME_HIGHLIGHT);\n                        \n                        if (sel->winner == 1) DrawText(\"WINNER: RED\", previewX, 300, 20, THEME_RED);\n                        else if (sel->winner == 2) DrawText(\"WINNER: BLUE\", previewX, 300, 20, THEME_BLUE);\n                        else DrawText(\"WINNER: DRAW\", previewX, 300, 20, DARKGRAY);\n                        \n                        char scoreBuf[64];\n                        sprintf(scoreBuf, \"R:%d  B:%d\", sel->final_red, sel->final_blue);\n                        DrawText(scoreBuf, previewX, 330, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"NO RESULTS YET\", previewX, 270, 18, DARKGRAY);\n                    }\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 380, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterstützt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}"
      },
      {
        "text": "\n--- End of content ---"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "thoughtSignature": "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",
        "text": "Absolut! Gerne, hier ist die Erklärung für den Code-Schnipsel, passend für einen Studienanfänger.\n\n### 1. Was macht der Code?\n\nDieser Code-Block definiert eine feste Farbpalette für die grafische Benutzeroberfläche (GUI) des Programms. Man kann es sich wie einen digitalen \"Farbkasten\" vorstellen, bei dem jede Farbe einen festen Namen und einen Zweck hat. Anstatt an jeder Stelle im Programm die Farbwerte neu einzutippen, verwenden Programmierer diese vordefinierten Namen. Das sorgt für ein einheitliches Aussehen im gesamten Programm, hier im Stil eines \"Sci-Fi / Retro\" Designs.\n\n### 2. Welche Schlüsselworte/Anweisungen enthält der Code?\n\n*   `const`: Dies ist ein Schlüsselwort in C, das eine Variable als \"Konstante\" deklariert. Das bedeutet, dass der Wert der Variable nach ihrer ersten Zuweisung nicht mehr verändert werden kann. Das ist perfekt für Werte wie Design-Farben, die im gesamten Programmablauf gleich bleiben sollen.\n*   `Color`: Dies ist der Datentyp. Es ist kein Standard-Typ wie `int` oder `char`, sondern eine benutzerdefinierte `struct` (Struktur), die von der Raylib-Bibliothek bereitgestellt wird. Eine solche `Color`-Struktur enthält typischerweise vier Werte: die Farbanteile für Rot, Grün, Blau und einen Alpha-Wert (Transparenz).\n*   `= { ... };`: Dies ist die Initialisierung. Die Zahlen in den geschweiften Klammern werden den einzelnen Feldern der `Color`-Struktur zugewiesen, in der Regel in der Reihenfolge: `{ Rot, Grün, Blau, Alpha }`.\n\n### 3. Welche Struktur besitzt der Code?\n\nDer Code besteht aus einer Liste von Konstantendefinitionen. Jede Zeile folgt exakt dem gleichen Aufbau:\n`const Datentyp VARIABLENNAME = { Wert1, Wert2, Wert3, Wert4 };`\n\nDiese Gruppe von Definitionen wird durch einen Kommentar (`// --- Theme Colors ... ---`) eingeleitet, was die Lesbarkeit des Codes verbessert. Solche Konfigurationsblöcke stehen oft am Anfang einer Datei, damit man sie leicht finden und anpassen kann.\n\n### 4. Was gibt es zu den Variablen zu sagen?\n\n*   **Benennung:** Die Variablennamen wie `THEME_BG` oder `THEME_RED` sind in Großbuchstaben geschrieben. Das ist eine weit verbreitete Konvention, um sofort zu signalisieren, dass es sich um Konstanten handelt.\n*   **Werte (RGBA):** Jede Variable speichert eine Farbe als eine Kombination aus vier Zahlenwerten von 0 bis 255.\n    *   `THEME_RED = { 255, 60, 100, 255 }` bedeutet: viel Rot (255), wenig Grün (60), etwas Blau (100) und volle Deckkraft (255). Das ergibt den Neon-Rot/Pink-Farbton.\n    *   `THEME_HIGHLIGHT = { 255, 255, 255, 40 }` ist interessant: Es ist Weiß (`255, 255, 255`), aber mit einem sehr niedrigen Alpha-Wert von `40`. Das macht die Farbe stark durchsichtig und erzeugt einen \"Leuchteffekt\", wenn sie über andere Elemente gezeichnet wird.\n\n### 5. Was sonst noch zu erwähnen wäre ...\n\n*   **Wartbarkeit:** Der größte Vorteil dieses Ansatzes ist die einfache Wartbarkeit. Wenn der Entwickler sich entscheidet, die Hintergrundfarbe zu ändern, muss er nur die eine Zeile `const Color THEME_BG = { ... };` anpassen. Die Änderung wirkt sich dann automatisch auf das gesamte Programm aus, ohne dass man dutzende Stellen im Code durchsuchen und ändern muss.\n*   **Kommentare:** Die Kommentare (`// ...`) sind hier sehr nützlich. Sie beschreiben nicht nur, welche Farbe es ist (z.B. \"Neon Cyan\"), sondern auch ihren Zweck (\"Faint Grid Lines\" - schwache Gitterlinien). Das ist eine exzellente Programmierpraxis.\n*   **KI-Hinweis:** Der Kommentar `// KI-Agent unterstützt:` deutet darauf hin, dass eine Künstliche Intelligenz bei der Auswahl oder Implementierung dieses Farbschemas geholfen hat."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre alle Schlüsselworte, Funktionen, Methoden, Datentypen ud so weiter, die aus Raylib in @gui.c bereitgestellt werden."
      },
      {
        "text": "\n--- Content from referenced files ---"
      },
      {
        "text": "\nContent from @gui.c:\n"
      },
      {
        "text": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterstützt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n// Current Run Tracking\nstatic char currentProtocolFilename[256] = \"\";\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterstützt: Sci-Fi / Retro Colors\nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterstützt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH };\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterstützt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {  \n    // Platziert vordefinierte Muster auf World \"w\"\n    // startR, startC = Startposition für Muster kommt von Mauspos\n    // type = welches Muster platziert werden soll\n    int team;\n    int midCol = c->cols / 2; // Mittellinie\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterstützt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\"); // Öffnet Startfenster - Header für Start-Window\n    SetTargetFPS(60); \n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {            // HIER geht's los! Game Loop/Hauptschleife \"WindowShouldClose\" = \"x\" oben-rechts in Win - Fenster\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {                 // Zustandsmaschine - Wert von State gibt Code-Block-Ausführung vor \n            case STATE_CONFIG:           // Spieleinstellungen mit Tasten im Fenster Biotope Configuration\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Presets \n                if (IsActionTriggered(KEY_ONE)) { // Schach Modus\n                    config.cols = 16;\n                    config.rows = 8;\n                    config.delay_ms = 500;\n                    config.max_rounds = 50;\n                    config.max_population = 30;\n                }\n                if (IsActionTriggered(KEY_TWO)) { // Outer Space Battle\n                    config.cols = 400;\n                    config.rows = 200;\n                    config.delay_ms = 100;\n                    config.max_rounds = 300;\n                    config.max_population = 1000;\n                }\n                if (IsActionTriggered(KEY_THREE)) { // Von Neumann\n                    config.cols = 1000;\n                    config.rows = 500;\n                    config.delay_ms = 0;\n                    config.max_rounds = 1000;\n                    config.max_population = 5000;\n                }\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:    // Startkonfiguration für Simulation auf Screen mit Maus setzen\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;  // Absprung alte Spiele laden\n                }\n                \n                // KI-Agent unterstützt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {    // Spielfeld wird mit Zufallsmuster gefüllt\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation initiale Belegung wird gespeichert \"....bio\"\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;   \n                }\n                break;\n\n            case STATE_LOAD:   // Alte Spielkonfigurationen laden\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;   \n                }\n                break;\n            \n            case STATE_RUNNING:  // Hier zurücklehnen und zuschauen\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterstützt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n\n\n                \n                // KI-Agent unterstützt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n\n                DrawText(\"PRESET\", 40, 300, 20, THEME_HIGHLIGHT);\n                DrawText(\"[1] CHESS\", 40, 335, 20, THEME_HIGHLIGHT);\n                DrawText(\"[2] OUTER SPACE BATTLE\", 40, 370, 20, THEME_HIGHLIGHT);\n                DrawText(\"[3] VON NEUMANN\", 40, 405, 20, THEME_HIGHLIGHT);\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 475, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterstützt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterstützt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterstützt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n                    \n                    if (sel->has_results) {\n                        DrawLine(previewX - 10, 260, previewX + 250, 260, Fade(THEME_TEXT, 0.3f));\n                        DrawText(\"RESULTS:\", previewX, 270, 20, THEME_HIGHLIGHT);\n                        \n                        if (sel->winner == 1) DrawText(\"WINNER: RED\", previewX, 300, 20, THEME_RED);\n                        else if (sel->winner == 2) DrawText(\"WINNER: BLUE\", previewX, 300, 20, THEME_BLUE);\n                        else DrawText(\"WINNER: DRAW\", previewX, 300, 20, DARKGRAY);\n                        \n                        char scoreBuf[64];\n                        sprintf(scoreBuf, \"R:%d  B:%d\", sel->final_red, sel->final_blue);\n                        DrawText(scoreBuf, previewX, 330, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"NO RESULTS YET\", previewX, 270, 18, DARKGRAY);\n                    }\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 380, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterstützt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}"
      },
      {
        "text": "\n--- End of content ---"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "thoughtSignature": "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",
        "text": "Hallo! Na klar, hier ist eine detaillierte Aufschlüsselung aller Elemente aus der `raylib`-Bibliothek, die in der Datei `gui.c` verwendet werden. Die Erklärungen sind speziell für Studienanfänger aufbereitet.\n\n### Grundlegende Struktur eines Raylib-Programms\n\nEin typisches Raylib-Programm hat eine einfache Struktur, die auch in `gui.c` zu sehen ist:\n\n1.  **Initialisierung:** Mit `InitWindow()` wird ein Fenster erzeugt. Davor kann man mit `SetConfigFlags()` bestimmte Eigenschaften des Fensters festlegen.\n2.  **Hauptschleife (Game Loop):** Eine `while`-Schleife, die so lange läuft, wie das Fenster offen ist (`!WindowShouldClose()`). In jedem Durchlauf dieser Schleife wird die Logik aktualisiert, Benutzereingaben verarbeitet und alles neu gezeichnet.\n3.  **Zeichnen:** Innerhalb der Schleife beginnt das Zeichnen immer mit `BeginDrawing()` und endet mit `EndDrawing()`. Dazwischen werden alle Zeichenbefehle aufgerufen.\n4.  **Aufräumen:** Nach der Schleife wird mit `CloseWindow()` alles wieder sauber beendet.\n\n---\n\n### Datentypen (Structs)\n\nDas sind benutzerdefinierte Datentypen, die mehrere zusammengehörige Werte bündeln.\n\n*   `Color`: Eine Struktur zum Speichern einer Farbe. Sie enthält vier `unsigned char`-Werte (0-255): `r` (Rot), `g` (Grün), `b` (Blau) und `a` (Alpha/Transparenz).\n*   `Vector2`: Stellt einen Punkt oder Vektor in einem 2D-Raum dar. Enthält zwei `float`-Werte: `x` und `y`. Wird z.B. für die Mausposition verwendet.\n*   `Rectangle`: Definiert ein Rechteck. Enthält vier `float`-Werte: `x`, `y` (die Position der oberen linken Ecke), sowie `width` und `height`.\n*   `Image`: Repräsentiert ein Bild, das im Hauptspeicher des Computers (CPU) liegt. Es ist im Grunde ein Array von Pixeldaten, die man direkt bearbeiten kann.\n*   `Texture2D`: Repräsentiert eine Textur, die in den Speicher der Grafikkarte (GPU) geladen wurde. Das Zeichnen von Texturen ist extrem schnell, weshalb Bilder vor dem Zeichnen in Texturen umgewandelt werden.\n\n---\n\n### Fenster- und Kontextverwaltung\n\nDiese Funktionen steuern das Programmfenster selbst.\n\n*   `SetConfigFlags(flags)`: Setzt Konfigurationseinstellungen *bevor* das Fenster erstellt wird. Im Code wird `FLAG_WINDOW_RESIZABLE` verwendet, damit der Benutzer die Größe des Fensters mit der Maus ändern kann.\n*   `InitWindow(breite, höhe, titel)`: Erstellt ein neues Fenster mit der angegebenen Breite, Höhe und einem Titel in der Titelleiste.\n*   `WindowShouldClose()`: Gibt `true` zurück, wenn der Benutzer versucht, das Fenster zu schließen (z.B. durch Klick auf das 'X' oder Drücken von ALT+F4). Dies ist die Hauptbedingung der Game-Loop.\n*   `CloseWindow()`: Schließt das Fenster und gibt alle von Raylib belegten Ressourcen frei.\n*   `SetTargetFPS(fps)`: Legt die maximale Anzahl an \"Frames per Second\" (Bilder pro Sekunde) fest, mit der die Hauptschleife laufen soll. `60` ist ein gängiger Wert für flüssige Animationen.\n*   `GetScreenWidth()` / `GetScreenHeight()`: Geben die aktuelle Breite bzw. Höhe des Fensters zurück. Nützlich, wenn die Fenstergröße veränderbar ist.\n\n---\n\n### Hauptschleife (Game Loop)\n\nDiese Funktionen definieren den \"Herzschlag\" der Anwendung.\n\n*   `BeginDrawing()`: Signalisiert den Beginn einer \"Zeichenrunde\". Raylib bereitet intern alles vor, um neue Grafiken zu zeichnen (leert z.B. den Bildschirm).\n*   `EndDrawing()`: Beendet die Zeichenrunde. Das fertig gezeichnete Bild wird nun auf dem Bildschirm angezeigt.\n*   `ClearBackground(farbe)`: Füllt das gesamte Fenster mit einer einzigen Farbe. Dies ist meist der erste Zeichenbefehl nach `BeginDrawing()`.\n\n---\n\n### Input-Verarbeitung (Tastatur & Maus)\n\nFunktionen, um auf Benutzereingaben zu reagieren.\n\n*   `IsKeyPressed(taste)`: Gibt `true` zurück, aber nur in *genau dem einen Frame*, in dem eine Taste *gerade eben* heruntergedrückt wurde. Ideal für einmalige Aktionen wie Menü-Navigation.\n*   `IsKeyDown(taste)`: Gibt `true` zurück, solange eine Taste *gedrückt gehalten* wird.\n*   `GetMousePosition()`: Gibt die aktuelle X- und Y-Position des Mauszeigers als `Vector2` zurück.\n*   `IsMouseButtonPressed(taste)`: Äquivalent zu `IsKeyPressed` für Maustasten (z.B. `MOUSE_LEFT_BUTTON`).\n*   `IsMouseButtonDown(taste)`: Äquivalent zu `IsKeyDown` für Maustasten.\n*   `IsMouseButtonReleased(taste)`: Gibt `true` zurück, in dem Frame, in dem eine Maustaste *losgelassen* wird.\n\n---\n\n### Zeit-Funktionen\n\n*   `GetFrameTime()`: Gibt die Zeit in Sekunden zurück, die für die Berechnung und das Zeichnen des letzten Frames benötigt wurde (z.B. `0.01666` bei 60 FPS). Nützlich für zeitbasierte Animationen und Physik.\n\n---\n\n### Bild- & Textur-Management\n\nDiese Funktionen sind Teil der optimierten Gitter-Darstellung.\n\n*   `GenImageColor(breite, höhe, farbe)`: Erzeugt ein neues `Image`-Objekt im CPU-Speicher, das vollständig mit einer Farbe gefüllt ist.\n*   `LoadTextureFromImage(image)`: Lädt die Daten aus einem `Image` (CPU) in eine `Texture2D` (GPU), damit sie schnell gezeichnet werden kann.\n*   `UnloadImage(image)`: Gibt den Speicher eines `Image`-Objekts auf der CPU wieder frei.\n*   `UnloadTexture(textur)`: Gibt den Speicher einer `Texture2D` auf der GPU wieder frei.\n*   `SetTextureFilter(textur, filter)`: Legt fest, wie eine Textur aussieht, wenn sie vergrößert oder verkleinert wird. `TEXTURE_FILTER_POINT` sorgt für einen \"pixeligen\" Look ohne verschwommene Kanten, was für Pixel-Art-Spiele ideal ist.\n*   `UpdateTexture(textur, daten)`: Aktualisiert eine bestehende Textur auf der GPU mit neuen Pixeldaten (einem `Color`-Array) von der CPU. Das ist sehr effizient, um Animationen darzustellen, ohne ständig neue Texturen erstellen zu müssen.\n*   `DrawTexturePro(textur, sourceRect, destRect, ...)`: Eine sehr mächtige Funktion, um Texturen zu zeichnen. Sie erlaubt es, nur einen bestimmten Ausschnitt (`sourceRect`) einer Textur auf einen bestimmten Bereich des Bildschirms (`destRect`) zu zeichnen und dabei zu skalieren, zu drehen und einzufärben.\n\n---\n\n### Zeichen-Funktionen\n\nDie Werkzeuge, um Formen und Text auf den Bildschirm zu bringen.\n\n*   `DrawRectangle(x, y, breite, höhe, farbe)`: Zeichnet ein ausgefülltes Rechteck.\n*   `DrawLine(startX, startY, endX, endY, farbe)`: Zeichnet eine einfache Linie.\n*   `DrawText(text, x, y, schriftgröße, farbe)`: Zeichnet einen Text an der angegebenen Position.\n*   `MeasureText(text, schriftgröße)`: Misst die Breite eines Textes in Pixeln, *ohne* ihn zu zeichnen. Sehr nützlich, um Text zu zentrieren.\n*   `Fade(farbe, alpha)`: Nimmt eine bestehende Farbe und gibt eine neue `Color` zurück, bei der der Alpha-Wert (Transparenz) auf einen neuen Wert (0.0 bis 1.0) gesetzt ist.\n\n---\n\n### Vordefinierte Konstanten\n\nRaylib bietet viele nützliche, vordefinierte Konstanten.\n\n*   **Farben:** `BLANK` (transparentes Schwarz), `WHITE`, `GREEN`, `DARKGRAY`, `GRAY` sind vordefinierte `Color`-Werte.\n*   **Tastatur-Codes:** `KEY_RIGHT`, `KEY_ENTER`, `KEY_G` etc. sind einfach Zahlen, die jeder Taste auf der Tastatur zugeordnet sind und die Lesbarkeit des Codes enorm verbessern."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre \n// --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime(); // Raylib Zeitsteuerung: Benötigte Zeit in Sek. für Berechnung u. Zeichnen  d. letzten Frames   \n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "thoughtSignature": "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",
        "text": "Gerne, hier ist die Erklärung zu diesem wichtigen Code-Abschnitt.\n\n### 1. Was macht der Code?\n\nDieser Code-Teil ist eine **zeitgesteuerte Bremse** für die Simulationslogik.\n\nStell dir vor, dein Computer ist so schnell, dass er tausende von Spielrunden pro Sekunde berechnen könnte. Das wäre für das menschliche Auge nur ein Flimmern. Das Ziel dieses Codes ist es, die Simulation auf eine kontrollierbare Geschwindigkeit zu drosseln (z.B. eine neue Generation alle 100 Millisekunden).\n\nEr funktioniert wie eine Stoppuhr: Er misst die Zeit, die vergeht, und immer wenn ein bestimmtes Zeitintervall (die `delay_ms` aus der Konfiguration) erreicht ist, wird die nächste Generation des \"Game of Life\" berechnet und die Stoppuhr zurückgesetzt.\n\n### 2. Welche Schlüsselworte/Anweisungen enthält der Code?\n\n*   `static float timeAccumulator = 0.0f;`\n    *   `static`: Dies ist hier das wichtigste Schlüsselwort. Es sorgt dafür, dass die Variable `timeAccumulator` ihren Wert zwischen den einzelnen Durchläufen der Hauptschleife **behält**. Sie wird nur ein einziges Mal am Anfang auf `0.0f` gesetzt und \"erinnert\" sich dann an ihren letzten Wert. Ohne `static` würde sie in jedem Frame neu auf 0 gesetzt und der Code würde nie funktionieren.\n    *   `float`: Ein Datentyp für eine Gleitkommazahl (Dezimalzahl).\n    *   `timeAccumulator`: Der Name bedeutet \"Zeit-Sammler\", was seine Aufgabe perfekt beschreibt.\n\n*   `timeAccumulator += GetFrameTime();`\n    *   `GetFrameTime()`: Dies ist eine Raylib-Funktion, die die exakte Zeit in Sekunden zurückgibt, die für den letzten Frame (einen Durchlauf der Hauptschleife) benötigt wurde. Das ist meist eine sehr kleine Zahl (z.B. 0.016 Sekunden bei 60 Frames pro Sekunde).\n    *   `+=`: Dieser Operator addiert den kleinen Zeitwert von `GetFrameTime()` in jedem Frame auf den `timeAccumulator` drauf. Der \"Zeit-Sammler\" füllt sich also langsam auf.\n\n*   `if (timeAccumulator >= config.delay_ms / 1000.0f)`\n    *   Dies ist die entscheidende Abfrage. Sie prüft: \"Ist die gesammelte Zeit (`timeAccumulator`) größer oder gleich der gewünschten Verzögerung?\"\n    *   `config.delay_ms / 1000.0f`: Die Variable `delay_ms` ist in Millisekunden. `GetFrameTime()` arbeitet aber in Sekunden. Hier wird der Wert aus Millisekunden in Sekunden umgerechnet (z.B. 100ms -> 0.1s).\n\n*   `timeAccumulator = 0.0f;`\n    *   Wenn die `if`-Bedingung wahr ist (also genug Zeit vergangen ist), wird der Code für die nächste Generation ausgeführt und der \"Zeit-Sammler\" wird wieder auf Null zurückgesetzt, um für das nächste Intervall von vorne zu zählen.\n\n### 3. Welche Struktur besitzt der Code?\n\nEs ist ein klassisches und sehr verbreitetes Muster in der Spiele- und Anwendungsentwicklung, das man \"Akkumulieren und Prüfen\" nennen könnte.\n1.  **Akkumulieren:** In jedem Schleifendurchlauf wird ein kleiner Wert (hier: Zeit) auf eine Zählervariable addiert.\n2.  **Prüfen:** In jedem Schleifendurchlauf wird geprüft, ob der Zähler einen Schwellenwert erreicht hat.\n3.  **Aktion & Reset:** Wenn der Schwellenwert erreicht ist, wird eine Aktion ausgeführt und der Zähler zurückgesetzt.\n\n### 4. Was gibt es zu den Variablen zu sagen?\n\n*   `timeAccumulator`: Die zentrale Variable in diesem Mechanismus. Ihre einzige Aufgabe ist es, die Zeit zu sammeln. Das `static`-Attribut ist ihr wichtigstes Merkmal, da es ihr ein \"Gedächtnis\" über die Frames hinweg verleiht.\n*   `config.delay_ms`: Eine externe Variable aus der Spielkonfiguration, die es dem Benutzer erlaubt, die Simulationsgeschwindigkeit dynamisch einzustellen.\n\n### 5. Was sonst noch zu erwähnen wäre ...\n\nDies ist ein Beispiel für eine **\"nicht-blockierende\" Zeitsteuerung**. Das ist ein extrem wichtiges Konzept. Eine einfache Alternative wäre, eine Funktion wie `sleep(100)` aufzurufen. Das würde das *gesamte Programm* für 100 Millisekunden anhalten – es könnte in der Zeit keine Mauseingaben verarbeiten, nichts zeichnen und würde sich \"einfroren\" anfühlen.\n\nDer hier gezeigte Ansatz ist viel eleganter: Das Programm läuft mit voller Geschwindigkeit weiter (z.B. 60 FPS), ist immer reaktiv, und die Simulationslogik wird einfach nur dann ausgeführt, wenn ihr \"Zeitfenster\" gekommen ist."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre \nWorld* create_world(int rows, int cols) {\n    World *w = malloc(sizeof(World));\n    w->rows = rows;\n    w->cols = cols;\n    w->grid = malloc(rows * cols * sizeof(int));\n    return w;\n}\nin @game_logic.c"
      },
      {
        "text": "\n--- Content from referenced files ---"
      },
      {
        "text": "\nContent from @game_logic.c:\n"
      },
      {
        "text": "#include <stdlib.h>\n#include <time.h>\n#include \"game_logic.h\"\n\n// KI-Agent unterstützt\nWorld* create_world(int rows, int cols) {\n    World *w = malloc(sizeof(World));\n    w->rows = rows;\n    w->cols = cols;\n    w->grid = malloc(rows * cols * sizeof(int));\n    return w;\n}\n\n// KI-Agent unterstützt\nvoid free_world(World *w) {\n    if (w) {\n        if (w->grid) free(w->grid);\n        free(w);\n    }\n}\n\n// KI-Agent unterstützt\nvoid init_world(World *current_gen, int rows, int cols) {\n    // Initialisiere den Zufallszahlengenerator mit der aktuellen Zeit\n    srand(time(NULL));\n    for (int i = 0; i < (rows * cols); i++) {\n        int val = rand() % 100; // Ganzzahlige Zufallszahlen zw. 0 und 100\n        if (val < 10) {\n            current_gen->grid[i] = TEAM_RED;\n        } else if (val < 20) {\n            current_gen->grid[i] = TEAM_BLUE;\n        } else {\n            current_gen->grid[i] = DEAD;\n        }\n    }\n}\n\n// KI-Agent unterstützt\nvoid update_generation(World *current_gen, World *next_gen, int rows, int cols) {\n    // Macro to check a neighbor index and increment counters\n    // Using a macro avoids function call overhead in the tight loop\n    #define COUNT_NEIGHBOR(idx) \\\n        if (current_gen->grid[idx] == TEAM_RED) red_neighbors++; \\\n        else if (current_gen->grid[idx] == TEAM_BLUE) blue_neighbors++;\n\n    for (int i = 0; i < (rows * cols); i++) {\n        int red_neighbors = 0;\n        int blue_neighbors = 0;\n\n        // --- Neighbor Counting (Unrolled for Edges) ---\n\n        // Sonderfall: i = Eckzelle oben, links\n        if (i == 0) {\n            COUNT_NEIGHBOR(i + (cols * rows) - 1);           // oberhalb, links\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)));         // oberhalb, mittig\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) + 1);     // oberhalb, rechts\n            COUNT_NEIGHBOR(i + cols - 1);                    // links\n            COUNT_NEIGHBOR(i + 1);                           // rechts\n            COUNT_NEIGHBOR(i + cols + cols - 1);             // unterhalb, links\n            COUNT_NEIGHBOR(i + cols);                        // unterhalb, mittig\n            COUNT_NEIGHBOR(i + cols + 1);                    // unterhalb, rechts\n        }\n        // Sonderfall: i = Eckzelle oben, rechts\n        else if (i == (cols - 1)) {\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) - 1);     // oberhalb, links\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)));         // oberhalb, mittig\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) - cols + 1); // oberhalb, rechts\n            COUNT_NEIGHBOR(i - 1);                           // links\n            COUNT_NEIGHBOR(i - (cols - 1));                  // rechts\n            COUNT_NEIGHBOR(i + cols - 1);                    // unterhalb, links\n            COUNT_NEIGHBOR(i + cols);                        // unterhalb, mittig\n            COUNT_NEIGHBOR(i + 1);                           // unterhalb, rechts\n        }\n        // Sonderfall i = Eckzelle unten, rechts\n        else if (i == (cols * rows - 1)) {\n            COUNT_NEIGHBOR(i - cols - 1);                    // oberhalb, links\n            COUNT_NEIGHBOR(i - cols);                        // oberhalb, mittig\n            COUNT_NEIGHBOR(i - cols - (cols - 1));           // oberhalb, rechts\n            COUNT_NEIGHBOR(i - 1);                           // links\n            COUNT_NEIGHBOR(i - (cols - 1));                  // rechts\n            COUNT_NEIGHBOR(i - (cols * (rows - 1)) - 1);     // unterhalb, links\n            COUNT_NEIGHBOR(i - (cols * (rows - 1)));         // unterhalb, mittig\n            COUNT_NEIGHBOR(i - (cols * (rows)) + 1);         // unterhalb, rechts\n        }\n        // Sonderfall: i = Eckzelle unten, links\n        else if (i == (cols * (rows - 1))) {\n            COUNT_NEIGHBOR(i - 1);                           // oberhalb, links\n            COUNT_NEIGHBOR(i - cols);                        // oberhalb, mittig\n            COUNT_NEIGHBOR(i - cols + 1);                    // oberhalb, rechts\n            COUNT_NEIGHBOR(i + (cols - 1));                  // links\n            COUNT_NEIGHBOR(i + 1);                           // rechts\n            COUNT_NEIGHBOR(i - (cols * (rows - 2)) - 1);     // unterhalb, links\n            COUNT_NEIGHBOR(i - (cols * (rows - 1)));         // unterhalb, mittig\n            COUNT_NEIGHBOR(i - (cols * (rows -1)) + 1);      // unterhalb, rechts\n        }\n        // Sonderfall: i = Zelle am oberen Rand\n        else if (i > 0 && i < cols) {\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) - 1);\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)));\n            COUNT_NEIGHBOR(i + (cols * (rows - 1)) + 1);\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1);\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1);\n        }\n        // Sonderfall: i = Zelle am unteren Rand\n        else if (i > (cols * (rows - 1))) {\n            // Nachbarn OBEN (ganz normal)\n            COUNT_NEIGHBOR(i - cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1);\n            \n            // Nachbarn SEITE\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1);\n            \n            // Nachbarn UNTEN (Wrap to Top Row)\n            int top_row_idx = i - (cols * (rows - 1));\n            COUNT_NEIGHBOR(top_row_idx - 1);\n            COUNT_NEIGHBOR(top_row_idx);\n            COUNT_NEIGHBOR(top_row_idx + 1);\n        }\n        // Sonderfall: i = Zelle am linken Rand\n        else if (i != 0 && i % cols == 0) {\n            COUNT_NEIGHBOR(i - cols + cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1);\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + 1);\n            COUNT_NEIGHBOR(i + cols + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1);\n        }\n        // Sonderfall: i = Zelle am rechten Rand\n        else if ((i + 1) % cols == 0) {\n            COUNT_NEIGHBOR(i - cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1 - (cols));\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1 - (cols));\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1 - (cols));\n        }\n        // Zellen innerhalb Spielfeld\n        else {\n            COUNT_NEIGHBOR(i - cols - 1);\n            COUNT_NEIGHBOR(i - cols);\n            COUNT_NEIGHBOR(i - cols + 1);\n            COUNT_NEIGHBOR(i - 1);\n            COUNT_NEIGHBOR(i + 1);\n            COUNT_NEIGHBOR(i + cols - 1);\n            COUNT_NEIGHBOR(i + cols);\n            COUNT_NEIGHBOR(i + cols + 1);\n        }\n\n        // --- Evolution Rules ---\n        int total_neighbors = red_neighbors + blue_neighbors;\n        int current_cell = current_gen->grid[i];\n        \n        if (current_cell != DEAD) {\n            // SURVIVAL: 2 or 3 neighbors -> stay alive\n            if (total_neighbors == 2 || total_neighbors == 3) {\n                next_gen->grid[i] = current_cell;\n            } else {\n                next_gen->grid[i] = DEAD;\n            }\n        }\n        else {\n            // BIRTH: exactly 3 neighbors -> become alive\n            if (total_neighbors == 3) {\n                // Determine color by majority\n                if (red_neighbors > blue_neighbors) {\n                    next_gen->grid[i] = TEAM_RED;\n                } else {\n                    next_gen->grid[i] = TEAM_BLUE;\n                }\n            } else {\n                next_gen->grid[i] = DEAD;\n            }\n        }\n    }\n    #undef COUNT_NEIGHBOR\n}"
      },
      {
        "text": "\n--- End of content ---"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "thoughtSignature": "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",
        "text": "Absolut! Diese Funktion ist ein Kernstück der dynamischen Speicherverwaltung in C. Hier ist die Erklärung:\n\n### 1. Was macht der Code?\n\nDiese Funktion ist eine \"Fabrik\" (oder ein \"Konstruktor\") für ein `World`-Objekt. Ihre Aufgabe ist es, alle notwendigen Datenstrukturen für eine neue Spielwelt im Speicher des Computers zu erstellen und zu initialisieren.\n\nMan übergibt die gewünschte Größe (Anzahl der Zeilen und Spalten), und die Funktion liefert eine komplett vorbereitete, aber noch \"leere\" Welt zurück. Sie baut quasi das Gerüst für das Spielfeld.\n\n### 2. Welche Schlüsselworte/Anweisungen enthält der Code?\n\n*   `World*`: Dies ist der Rückgabetyp der Funktion. Das Sternchen `*` bedeutet, dass die Funktion nicht das `World`-Objekt selbst zurückgibt, sondern einen **Pointer** (Zeiger) darauf – also die *Speicheradresse*, unter der das Objekt zu finden ist.\n*   `malloc()`: Steht für \"memory allocation\" (Speicher anfordern). Dies ist eine Standard-C-Funktion, die ein Stück rohen, uninitialisierten Speicher vom Betriebssystem anfordert. Der Speicher wird vom sogenannten **\"Heap\"** genommen, einem Speicherbereich für Daten, die auch nach dem Ende der Funktion weiterexistieren sollen.\n*   `sizeof()`: Ein Operator, der die Größe eines Datentyps oder einer Variable in Bytes berechnet. `sizeof(World)` ermittelt also, wie viel Speicherplatz die `World`-Struktur selbst benötigt.\n*   `w->rows = rows;`: Der Pfeil-Operator `->` wird verwendet, um auf ein Mitglied (eine Variable) einer Struktur zuzugreifen, wenn man nur einen Pointer auf die Struktur hat. Es ist eine Kurzform für `(*w).rows`. Hier werden die übergebenen `rows` und `cols` in der neu erstellten `World`-Struktur gespeichert.\n*   `return w;`: Gibt den Pointer `w` (also die Speicheradresse der neuen Welt) an die aufrufende Funktion zurück.\n\n### 3. Welche Struktur besitzt der Code?\n\nDie Funktion folgt einem sehr typischen, zweistufigen Prozess zur Erstellung dynamischer Datenstrukturen in C:\n\n1.  **Container anlegen:** Zuerst wird mit `malloc(sizeof(World))` Speicher für die \"Hülle\" bzw. den Container angelegt. Die `World`-Struktur enthält ja nur die Metadaten (`rows`, `cols`) und einen *Pointer* auf das eigentliche Spielfeld (`grid`).\n2.  **Inhalt anlegen:** Danach wird mit `malloc(rows * cols * sizeof(int))` der Speicher für das eigentliche Spielfeld (ein riesiges Array von `int`s) angelegt. Die Größe wird dynamisch basierend auf den `rows` und `cols` berechnet.\n3.  **Verknüpfen:** Die Adresse des neu angelegten Spielfelds wird in der `World`-Struktur gespeichert (`w->grid = ...`).\n4.  **Zurückgeben:** Der Pointer auf den fertig konfigurierten Container wird zurückgegeben.\n\n### 4. Was gibt es zu den Variablen zu sagen?\n\n*   `World *w`: Eine lokale Pointer-Variable, die nur innerhalb der Funktion existiert. Sie dient als \"Arbeitskopie\", um die neue `World`-Struktur im Speicher zu bauen. Ihr Wert (die Speicheradresse) wird am Ende zurückgegeben.\n*   `rows`, `cols`: Das sind die Eingabeparameter, die die Größe der zu erstellenden Welt bestimmen.\n\n### 5. Was sonst noch zu erwähnen wäre ...\n\n*   **Dynamische Speicherverwaltung:** Dies ist ein Paradebeispiel dafür. Die Größe der Welt ist nicht beim Kompilieren des Programms bekannt, sondern wird zur Laufzeit festgelegt. `malloc` ist das Werkzeug, um diesen zur Laufzeit benötigten Speicher anzufordern.\n*   **Verantwortung & Memory Leaks (Speicherlecks):** Das ist extrem wichtig! Speicher, der mit `malloc` angefordert wird, wird **nicht** automatisch freigegeben. Die Funktion, die `create_world` aufruft, erhält die Verantwortung für diesen Speicher. Sie **muss** irgendwann die Gegen-Funktion `free_world(w)` aufrufen, um den Speicher wieder an das System zurückzugeben. Vergisst man das, entsteht ein **Speicherleck**: Das Programm belegt immer mehr Speicher, ohne ihn je freizugeben, und kann im schlimmsten Fall abstürzen. `create_world` und `free_world` sind also ein untrennbares Paar."
      }
    ]
  },
  {
    "role": "user",
    "parts": [
      {
        "text": "Bitte erkläre\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterstützt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\nin @gui.c. Berichte detailliert darüber, wie die aktualisierte Anzeige von gui_world auf dem Bildschirm erzeugt wird. Das erschließt sich mir nicht."
      },
      {
        "text": "\n--- Content from referenced files ---"
      },
      {
        "text": "\nContent from @gui.c:\n"
      },
      {
        "text": "#include \"raylib.h\"\n#include \"gui.h\"\n#include \"file_io.h\" // KI-Agent unterstützt\n#include <stdio.h>\n#include <stdlib.h> // For abs\n#include <time.h>   // For time()\n#include <string.h> // For strncpy\n\n// Global World Pointer for GUI\nWorld *gui_world = NULL;\n\n// Protocol Archive State\nstatic ProtocolInfo *fileList = NULL;\nstatic int fileCount = 0;\nstatic int selectedFileIndex = 0;\n// Current Run Tracking\nstatic char currentProtocolFilename[256] = \"\";\n\n// --- Theme Colors (Digital Lab) ---\n// KI-Agent unterstützt: Sci-Fi / Retro Colors \nconst Color THEME_BG = { 20, 24, 32, 255 };        // Deep Dark Blue/Grey //Datentyp color = von Raylib zur Verfügung gestellt.\nconst Color THEME_HUD = { 10, 12, 16, 230 };       // Semi-transparent Black\nconst Color THEME_GRID = { 40, 44, 52, 255 };      // Faint Grid Lines\nconst Color THEME_RED = { 255, 60, 100, 255 };     // Neon Red/Pink\nconst Color THEME_BLUE = { 0, 220, 255, 255 };     // Neon Cyan\nconst Color THEME_TEXT = { 220, 220, 220, 255 };   // Off-White\nconst Color THEME_HIGHLIGHT = { 255, 255, 255, 40 }; // Selection Glow\n\n// Helper to draw the grid (reused in multiple states)\n// KI-Agent unterstützt: Optimized Texture-Based Rendering for VcXsrv performance\nvoid DrawGridAndCells(GameConfig *config, int screenWidth, int screenHeight, bool drawGridLines) {\n    if (!gui_world) return;\n\n    // Layout Constants\n    const int headerHeight = 60;\n    const int footerHeight = 40;\n    const int margin = 20;\n    \n    int drawWidth = screenWidth - (margin * 2);\n    int drawHeight = screenHeight - headerHeight - footerHeight - (margin * 1); // margin bottom handled by footer\n    int startX = margin;\n    int startY = headerHeight;\n    \n    float cellW = (float)drawWidth / config->cols;\n    float cellH = (float)drawHeight / config->rows;\n    \n    // --- 1. Texture Management (Static to persist across frames) ---\n    static Texture2D gridTex = { 0 };\n    static int texW = 0;\n    static int texH = 0;\n    static Color *pixels = NULL;\n    \n    // Check if grid size changed or not initialized\n    if (config->cols != texW || config->rows != texH) {\n        // Cleanup old resources\n        if (gridTex.id > 0) UnloadTexture(gridTex);\n        if (pixels) free(pixels);\n        \n        // Update dimensions\n        texW = config->cols;\n        texH = config->rows;\n        \n        // Allocate new resources\n        pixels = (Color*)malloc(texW * texH * sizeof(Color));\n        Image img = GenImageColor(texW, texH, BLANK); // Create empty image\n        gridTex = LoadTextureFromImage(img);\n        UnloadImage(img);\n        \n        // IMPORTANT: Point filtering ensures sharp pixels when scaled up\n        SetTextureFilter(gridTex, TEXTURE_FILTER_POINT); \n    }\n    \n    // --- 2. Update Pixel Data (CPU side) ---\n    // Instead of thousands of DrawRectangle calls, we update a single buffer.\n    for (int i = 0; i < texW * texH; i++) {\n        if (gui_world->grid[i] == TEAM_BLUE) {\n            pixels[i] = THEME_BLUE;\n        } else if (gui_world->grid[i] == TEAM_RED) {\n            pixels[i] = THEME_RED;\n        } else {\n            pixels[i] = BLANK; // Transparent, so background shows through\n        }\n    }\n    \n    // --- 3. Upload to GPU & Draw ---\n    UpdateTexture(gridTex, pixels);\n    \n    Rectangle source = { 0.0f, 0.0f, (float)texW, (float)texH }; // Raylib Datentyp: Rectangle definiert Rechteck {x, y, Breite, Höhe}\n    Rectangle dest = { (float)startX, (float)startY, (float)drawWidth, (float)drawHeight };\n    Vector2 origin = { 0.0f, 0.0f };  //Raylib Datentyp: Vector2 stellt Punkt oder Vektor in 2D dar {x, y}\n    \n    DrawTexturePro(gridTex, source, dest, origin, 0.0f, WHITE);\n\n    // --- 4. Draw Grid Lines (Optional - Overhead is low for lines) ---\n    if (drawGridLines) {\n        for (int i = 0; i <= config->cols; i++) DrawLine(startX + i * cellW, startY, startX + i * cellW, startY + drawHeight, THEME_GRID);\n        for (int i = 0; i <= config->rows; i++) DrawLine(startX, startY + i * cellH, startX + drawWidth, startY + i * cellH, THEME_GRID);\n    }\n    \n    // 5. Draw Hemisphere Separator\n    DrawLine(startX + (config->cols / 2) * cellW, startY, \n             startX + (config->cols / 2) * cellW, startY + drawHeight, Fade(THEME_TEXT, 0.3f));\n}\n\n// KI-Agent unterstützt: Pattern Definitions\ntypedef struct { int r; int c; } Point;\n\nvoid PlacePattern(World *w, GameConfig *c, int startR, int startC, int type) {  \n    // Platziert vordefinierte Muster auf World \"w\"\n    // startR, startC = Startposition für Muster kommt von Mauspos\n    // type = welches Muster platziert werden soll\n    int team;\n    int midCol = c->cols / 2; // Mittellinie\n    int *current_pop;\n    \n    // Determine Team based on Mouse Cursor (Start Position)\n    if (startC < midCol) {\n        team = TEAM_BLUE;\n        current_pop = &c->current_blue_pop;\n    } else {\n        team = TEAM_RED;\n        current_pop = &c->current_red_pop;\n    }\n\n    // Pattern Data\n    // Glider (3x3)\n    Point p_glider[] = {{0,1}, {1,2}, {2,0}, {2,1}, {2,2}};\n    // HWSS (Traveler) (5x7)\n    Point p_traveler[] = {{0,3}, {0,4}, {1,1}, {1,6}, {2,0}, {3,0}, {3,6}, {4,0}, {4,1}, {4,2}, {4,3}, {4,4}, {4,5}};\n    // Gosper Glider Gun (Blaster) (9x36)\n    Point p_blaster[] = {\n        {4,0}, {5,0}, {4,1}, {5,1}, // Left Block\n        {4,10}, {5,10}, {6,10}, {3,11}, {7,11}, {2,12}, {8,12}, {2,13}, {8,13}, {5,14}, {3,15}, {7,15}, {4,16}, {5,16}, {6,16}, {5,17}, // Left Mech\n        {2,20}, {3,20}, {4,20}, {2,21}, {3,21}, {4,21}, {1,22}, {5,22}, {0,24}, {1,24}, {5,24}, {6,24}, // Right Mech\n        {2,34}, {3,34}, {2,35}, {3,35} // Right Block\n    };\n\n    Point *cells = NULL;\n    int count = 0;\n\n    if (type == 1) { cells = p_glider; count = 5; }\n    else if (type == 2) { cells = p_traveler; count = 13; }\n    else if (type == 3) { cells = p_blaster; count = 36; }\n\n    for (int i = 0; i < count; i++) {\n        // Check Population Limit\n        if (*current_pop >= c->max_population) break;\n\n        // Calculate Wrap-around Coordinates\n        int r = (startR + cells[i].r) % c->rows;\n        int col = (startC + cells[i].c) % c->cols;\n        \n        // Handle negative modulo (if logic ever allows negative offsets)\n        if (r < 0) r += c->rows;\n        if (col < 0) col += c->cols;\n\n        // Check Border Crossing (Clipping Rule)\n        bool valid = false;\n        if (team == TEAM_BLUE && col < midCol) valid = true;\n        if (team == TEAM_RED && col >= midCol) valid = true;\n\n        if (valid) {\n            int idx = r * c->cols + col;\n            if (w->grid[idx] == DEAD) {\n                w->grid[idx] = team;\n                (*current_pop)++;\n            }\n        }\n    }\n}\n\n// Helper for continuous input handling (Key Repeat)\nbool IsActionTriggered(int key) {\n    static int activeKey = -1;\n    static float timer = 0.0f;\n    const float INITIAL_DELAY = 0.5f;\n    const float REPEAT_INTERVAL = 0.05f; \n\n    if (IsKeyPressed(key)) {\n        activeKey = key;\n        timer = 0.0f;\n        return true;\n    }\n\n    if (IsKeyDown(key)) {\n        if (activeKey == key) {\n            timer += GetFrameTime();\n            if (timer >= INITIAL_DELAY + REPEAT_INTERVAL) {\n                timer = INITIAL_DELAY; \n                return true;\n            }\n        }\n    } else {\n        if (activeKey == key) {\n            activeKey = -1;\n            timer = 0.0f;\n        }\n    }\n    return false;\n}\n\n// KI-Agent unterstützt\nvoid run_gui_app() {\n    // Initial window size\n    int screenWidth = 800;\n    int screenHeight = 600;\n\n    SetConfigFlags(FLAG_WINDOW_RESIZABLE); \n    InitWindow(screenWidth, screenHeight, \"Biotope - Game of Life\"); // Öffnet Startfenster - Header für Start-Window\n    SetTargetFPS(60); \n\n    // Initial state\n    AppState state = STATE_CONFIG;\n    GameConfig config = {\n        .rows = 50, \n        .cols = 50, \n        .delay_ms = 100, \n        .max_population = 100, \n        .max_rounds = 1000,\n        .current_red_pop = 0,\n        .current_blue_pop = 0,\n        .current_round = 0\n    };\n    \n    // Feedback Message System\n    char statusMsg[64] = \"\";\n    float statusTimer = 0.0f;\n\n    while (!WindowShouldClose()) {            // HIER geht's los! Game Loop/Hauptschleife \"WindowShouldClose\" = \"x\" oben-rechts in Win - Fenster\n        // Update dynamic screen dimensions\n        screenWidth = GetScreenWidth();\n        screenHeight = GetScreenHeight();\n        \n        // Timer for status message\n        if (statusTimer > 0) {\n            statusTimer -= GetFrameTime();\n            if (statusTimer <= 0) strcpy(statusMsg, \"\");\n        }\n        \n        // --- Logic per State ---\n        switch (state) {                 // Zustandsmaschine - Wert von State gibt Code-Block-Ausführung vor \n            case STATE_CONFIG:           // Spieleinstellungen mit Tasten im Fenster Biotope Configuration\n                // Interaction: Change Grid Size\n                if (IsActionTriggered(KEY_RIGHT)) config.cols += 10;\n                if (IsActionTriggered(KEY_LEFT) && config.cols > 10) config.cols -= 10;\n                if (IsActionTriggered(KEY_UP)) config.rows += 10;\n                if (IsActionTriggered(KEY_DOWN) && config.rows > 10) config.rows -= 10;\n                \n                // Interaction: Change Delay (incl. German Layout)\n                if (IsActionTriggered(KEY_KP_ADD) || IsActionTriggered(KEY_EQUAL) || IsActionTriggered(KEY_RIGHT_BRACKET)) \n                    config.delay_ms += 50;\n                if ((IsActionTriggered(KEY_KP_SUBTRACT) || IsActionTriggered(KEY_MINUS) || IsActionTriggered(KEY_SLASH)) && config.delay_ms > 0) \n                    config.delay_ms -= 50;\n\n                // Interaction: Change Max Rounds\n                if (IsActionTriggered(KEY_PAGE_UP)) config.max_rounds += 100;\n                if (IsActionTriggered(KEY_PAGE_DOWN) && config.max_rounds > 100) config.max_rounds -= 100;\n\n                // Interaction: Change Max Population\n                int max_squad_cells = (config.rows * config.cols) / 2;\n                // Clamp if grid size reduced below current max_pop\n                if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n\n                if (IsActionTriggered(KEY_INSERT) && config.max_population < max_squad_cells) {\n                    config.max_population += 10;\n                    if (config.max_population > max_squad_cells) config.max_population = max_squad_cells;\n                }\n                if (IsActionTriggered(KEY_DELETE) && config.max_population > 10) config.max_population -= 10;\n\n                // Presets \n                if (IsActionTriggered(KEY_ONE)) { // Schach Modus\n                    config.cols = 16;\n                    config.rows = 8;\n                    config.delay_ms = 500;\n                    config.max_rounds = 50;\n                    config.max_population = 30;\n                }\n                if (IsActionTriggered(KEY_TWO)) { // Outer Space Battle\n                    config.cols = 400;\n                    config.rows = 200;\n                    config.delay_ms = 100;\n                    config.max_rounds = 300;\n                    config.max_population = 1000;\n                }\n                if (IsActionTriggered(KEY_THREE)) { // Von Neumann\n                    config.cols = 1000;\n                    config.rows = 500;\n                    config.delay_ms = 0;\n                    config.max_rounds = 1000;\n                    config.max_population = 5000;\n                }\n\n                // Transition: Start Setup\n                if (IsKeyPressed(KEY_ENTER)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = create_world(config.rows, config.cols);\n                    // Initialize empty\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    \n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    config.current_round = 0;\n                    \n                    state = STATE_EDIT;\n                }\n                break;\n\n            case STATE_EDIT:    // Startkonfiguration für Simulation auf Screen mit Maus setzen\n                // --- Mouse & Pattern Interaction ---\n                {\n                    Vector2 mousePos = GetMousePosition();\n                    \n                    // Constants must match DrawGridAndCells layout\n                    const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    \n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    // State for Drag-and-Paint interaction\n                    static int editAction = 0; // 0:Idle, 1:Place, 2:Remove\n                    if (IsMouseButtonReleased(MOUSE_LEFT_BUTTON)) editAction = 0;\n\n                    // Check if mouse is inside the grid area\n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        \n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        \n                        // Handle Clicks (Single Cell) & Drag\n                        if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON)) {\n                            int index = row * config.cols + col;\n                            // Determine action based on initial cell state: Place (1) or Remove (2)\n                            if (gui_world->grid[index] == DEAD) editAction = 1;\n                            else editAction = 2;\n                        }\n\n                        if (IsMouseButtonDown(MOUSE_LEFT_BUTTON) && editAction != 0) {\n                            int index = row * config.cols + col;\n                            int midCol = config.cols / 2;\n\n                            // Check Hemispheres and Population Limits\n                            if (col < midCol) {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_BLUE) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_blue_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_blue_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_BLUE;\n                                    config.current_blue_pop++;\n                                }\n                            } else {\n                                if (editAction == 2 && gui_world->grid[index] == TEAM_RED) {\n                                    gui_world->grid[index] = DEAD;\n                                    config.current_red_pop--;\n                                } else if (editAction == 1 && gui_world->grid[index] == DEAD && config.current_red_pop < config.max_population) {\n                                    gui_world->grid[index] = TEAM_RED;\n                                    config.current_red_pop++;\n                                }\n                            }\n                        }\n                        \n                        // Handle Patterns\n                        if (IsKeyPressed(KEY_G)) {\n                            PlacePattern(gui_world, &config, row, col, 1); // 1 = Glider\n                            strcpy(statusMsg, \"Deployed: GLIDER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_T)) {\n                            PlacePattern(gui_world, &config, row, col, 2); // 2 = Traveler\n                            strcpy(statusMsg, \"Deployed: TRAVELER\");\n                            statusTimer = 2.0f;\n                        }\n                        if (IsKeyPressed(KEY_B)) {\n                            PlacePattern(gui_world, &config, row, col, 3); // 3 = Blaster\n                            strcpy(statusMsg, \"Deployed: BLASTER\");\n                            statusTimer = 2.0f;\n                        }\n                    }\n                }\n                \n                // File I/O\n                if (IsKeyPressed(KEY_S)) {\n                    if (save_grid(\"setup.bio\", gui_world, &config)) {\n                        strcpy(statusMsg, \"Saved to setup.bio!\");\n                        statusTimer = 2.0f;\n                    } else {\n                        strcpy(statusMsg, \"Save Failed!\");\n                        statusTimer = 2.0f;\n                    }\n                }\n                \n                // NEW: Load State Transition\n                if (IsKeyPressed(KEY_L)) {\n                    fileCount = list_protocol_files(\"biotope_results\", &fileList);\n                    selectedFileIndex = 0;\n                    state = STATE_LOAD;  // Absprung alte Spiele laden\n                }\n                \n                // KI-Agent unterstützt: Random Placement Logic\n                if (IsKeyPressed(KEY_R)) {    // Spielfeld wird mit Zufallsmuster gefüllt\n                    // Reset grid\n                    for(int i=0; i<config.rows*config.cols; i++) gui_world->grid[i] = DEAD;\n                    config.current_blue_pop = 0;\n                    config.current_red_pop = 0;\n                    \n                    int midCol = config.cols / 2;\n                    // Seed random\n                    srand(time(NULL));\n                    \n                    // Iterate and randomly fill\n                    for(int r=0; r<config.rows; r++) {\n                        for(int c=0; c<config.cols; c++) {\n                            int idx = r * config.cols + c;\n                            // 20% chance to be alive\n                            if ((rand() % 100) < 20) {\n                                if (c < midCol) {\n                                    if (config.current_blue_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_BLUE;\n                                        config.current_blue_pop++;\n                                    }\n                                } else {\n                                    if (config.current_red_pop < config.max_population) {\n                                        gui_world->grid[idx] = TEAM_RED;\n                                        config.current_red_pop++;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    strcpy(statusMsg, \"Randomized Grid!\");\n                    statusTimer = 2.0f;\n                }\n                \n                // Transition: Start Simulation initiale Belegung wird gespeichert \"....bio\"\n                if (IsKeyPressed(KEY_ENTER)) {\n                    // Phase 3: Auto-Save on Start\n                    char autoFilename[128];\n                    time_t now = time(NULL);\n                    struct tm *t = localtime(&now);\n                    strftime(autoFilename, sizeof(autoFilename), \"biotope_results/run_%Y%m%d_%H%M%S.bio\", t);\n                    \n                    // Store for result appending later\n                    strcpy(currentProtocolFilename, autoFilename);\n                    \n                    if (save_grid(autoFilename, gui_world, &config)) {\n                        printf(\"Auto-save successful: %s\\n\", autoFilename);\n                    } else {\n                        printf(\"Auto-save failed!\\n\");\n                    }\n                    \n                    state = STATE_RUNNING;   \n                }\n                break;\n\n            case STATE_LOAD:   // Alte Spielkonfigurationen laden\n                if (IsKeyPressed(KEY_UP) && selectedFileIndex > 0) selectedFileIndex--;\n                if (IsKeyPressed(KEY_DOWN) && selectedFileIndex < fileCount - 1) selectedFileIndex++;\n                \n                if (IsKeyPressed(KEY_ENTER) && fileCount > 0) {\n                    if (load_grid(fileList[selectedFileIndex].filepath, gui_world, &config)) {\n                        strcpy(statusMsg, \"Protocol Loaded!\");\n                        statusTimer = 2.0f;\n                    }\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;\n                }\n                \n                if (IsKeyPressed(KEY_Q) || IsKeyPressed(KEY_ESCAPE)) {\n                    if (fileList) free(fileList);\n                    fileList = NULL;\n                    state = STATE_EDIT;   \n                }\n                break;\n            \n            case STATE_RUNNING:  // Hier zurücklehnen und zuschauen\n                if (IsKeyPressed(KEY_BACKSPACE) || IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                    break;\n                }\n\n                // --- Simulation Logic ---\n                static float timeAccumulator = 0.0f;\n                timeAccumulator += GetFrameTime();\n                \n                if (timeAccumulator >= config.delay_ms / 1000.0f) {\n                    timeAccumulator = 0.0f;\n                    \n                    World *next_gen = create_world(config.rows, config.cols);\n                    update_generation(gui_world, next_gen, config.rows, config.cols);\n                    free_world(gui_world);\n                    gui_world = next_gen;\n                    \n                    config.current_round++;\n                    \n                    config.current_red_pop = 0;\n                    config.current_blue_pop = 0;\n                    for(int i=0; i<config.rows*config.cols; i++) {\n                        if (gui_world->grid[i] == TEAM_RED) config.current_red_pop++;\n                        if (gui_world->grid[i] == TEAM_BLUE) config.current_blue_pop++;\n                    }\n                    \n                    if (config.current_round >= config.max_rounds || \n                        config.current_red_pop == 0 || \n                        config.current_blue_pop == 0) {\n                        state = STATE_FINISHED;\n                    }\n                }\n                break;\n                \n            case STATE_FINISHED:\n                if (IsKeyPressed(KEY_ENTER)) {\n                     state = STATE_GAME_OVER;\n                     int winner = 0;\n                     if (config.current_red_pop > config.current_blue_pop) winner = TEAM_RED;\n                     else if (config.current_blue_pop > config.current_red_pop) winner = TEAM_BLUE;\n                     \n                     // Append to Protocol\n                     if (strlen(currentProtocolFilename) > 0) {\n                        append_protocol_result(currentProtocolFilename, winner, config.current_red_pop, config.current_blue_pop);\n                     }\n                }\n                if (IsKeyPressed(KEY_Q)) {\n                    if (gui_world) free_world(gui_world);\n                    gui_world = NULL;\n                    state = STATE_CONFIG;\n                }\n                break;\n\n            case STATE_GAME_OVER:\n                if (IsKeyPressed(KEY_ONE)) {\n                     if (gui_world) free_world(gui_world);\n                     gui_world = NULL;\n                     state = STATE_CONFIG;\n                }\n                break;\n        }\n\n        // --- Drawing ---\n        BeginDrawing();\n        ClearBackground(THEME_BG);\n\n        // Draw HUD Backgrounds (Header & Footer)\n        DrawRectangle(0, 0, screenWidth, 60, THEME_HUD); // Header\n        DrawRectangle(0, screenHeight - 40, screenWidth, 40, THEME_HUD); // Footer\n\n        // Draw Status Message Overlay\n        if (statusTimer > 0) {\n            // KI-Agent unterstützt: Center status message to avoid collision with counters\n            DrawText(statusMsg, screenWidth/2 - MeasureText(statusMsg, 20)/2, 20, 20, GREEN);\n        }\n\n        switch (state) {\n            case STATE_CONFIG:\n                DrawText(\"BIOTOPE CONFIGURATION\", 20, 15, 30, THEME_TEXT);\n                \n                char buf[64];\n                sprintf(buf, \"GRID SIZE:  %03d x %03d\", config.rows, config.cols);\n                DrawText(buf, 40, 100, 20, THEME_BLUE);\n                DrawText(\"(Arrows)\", 300, 100, 18, DARKGRAY);\n                \n                sprintf(buf, \"DELAY:      %04d ms\", config.delay_ms);\n                DrawText(buf, 40, 140, 20, THEME_RED);\n                DrawText(\"(+/-)\", 300, 140, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX ROUNDS: %04d\", config.max_rounds);\n                DrawText(buf, 40, 180, 20, THEME_BLUE);\n                DrawText(\"(PageUp/PageDown)\", 300, 180, 18, DARKGRAY);\n                \n                sprintf(buf, \"MAX INIT POP:    %04d\", config.max_population);\n                DrawText(buf, 40, 220, 20, THEME_RED);\n                DrawText(\"(Insert/Delete)\", 300, 220, 18, DARKGRAY);\n\n\n                \n                // KI-Agent unterstützt: Mission Protocol (Rules Display)\n                int rulesX = screenWidth / 2 + 40;\n                DrawLine(rulesX - 20, 100, rulesX - 20, 240, Fade(THEME_TEXT, 0.3f)); // Vertical Separator\n                \n                DrawText(\"CONWAY'S MISSION PROTOCOL\", rulesX, 100, 20, THEME_HIGHLIGHT);\n                DrawText(\"- SURVIVAL: 2 or 3 neighbors\", rulesX, 135, 20, THEME_TEXT);\n                DrawText(\"- BIRTH: 3 neighbors (Majority Rule of parents)\", rulesX, 160, 20, THEME_TEXT);\n                DrawText(\"- TEAMS: RED vs BLUE\", rulesX, 185, 20, THEME_TEXT);\n                DrawText(\"- GOAL: Max Population after timeout\", rulesX, 210, 20, THEME_TEXT);\n\n\n                DrawText(\"PRESET\", 40, 300, 20, THEME_HIGHLIGHT);\n                DrawText(\"[1] CHESS\", 40, 335, 20, THEME_HIGHLIGHT);\n                DrawText(\"[2] OUTER SPACE BATTLE\", 40, 370, 20, THEME_HIGHLIGHT);\n                DrawText(\"[3] VON NEUMANN\", 40, 405, 20, THEME_HIGHLIGHT);\n                DrawText(\"PRESS [ENTER] TO INITIALIZE SYSTEM\", 40, 475, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_EDIT:\n                DrawText(\"EDITOR MODE\", 20, 18, 24, THEME_BLUE);\n                // KI-Agent unterstützt: Increased font size to 16 for better readability\n                DrawText(\"LEFT: BLUE SQUAD  |  RIGHT: RED SQUAD\", 220, 24, 16, DARKGRAY);\n                \n                // Draw Population Counters\n                char popBuf[64];\n                sprintf(popBuf, \"BLUE: %03d/%03d\", config.current_blue_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 300, 20, 20, THEME_BLUE);\n                sprintf(popBuf, \"RED: %03d/%03d\", config.current_red_pop, config.max_population);\n                DrawText(popBuf, screenWidth - 140, 20, 20, THEME_RED);\n                \n                // Ghost Cursor (Visual Polish)\n                Vector2 mousePos = GetMousePosition();\n                // ... Re-calculate grid metrics for ghost cursor ...\n                {\n                     const int headerHeight = 60;\n                    const int footerHeight = 40;\n                    const int margin = 20;\n                    int drawWidth = screenWidth - (margin * 2);\n                    int drawHeight = screenHeight - headerHeight - footerHeight - margin;\n                    int startX = margin;\n                    int startY = headerHeight;\n                    float cellW = (float)drawWidth / config.cols;\n                    float cellH = (float)drawHeight / config.rows;\n                    \n                    if (mousePos.x >= startX && mousePos.x < startX + drawWidth &&\n                        mousePos.y >= startY && mousePos.y < startY + drawHeight) {\n                        int col = (int)((mousePos.x - startX) / cellW);\n                        int row = (int)((mousePos.y - startY) / cellH);\n                        // Draw Ghost\n                        Color ghostColor = (col < config.cols/2) ? Fade(THEME_BLUE, 0.2f) : Fade(THEME_RED, 0.2f);\n                        DrawRectangle(startX + col * cellW, startY + row * cellH, cellW, cellH, ghostColor);\n                    }\n                }\n                \n                // KI-Agent unterstützt: Draw grid lines only if grid is not too dense (> 150)\n                bool showLines = (config.rows <= 150 && config.cols <= 150);\n                DrawGridAndCells(&config, screenWidth, screenHeight, showLines); \n\n                // KI-Agent unterstützt: Updated Footer Menu Font Size to 14\n                DrawText(\"[ENTER] RUN | [S] SAVE | [L] LOAD | [R] RANDOM | [G] GLIDER | [T] TRAVELER | [B] BLASTER\", \n                         20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_LOAD:\n                DrawText(\"PROTOCOL ARCHIVE\", 20, 15, 30, THEME_TEXT);\n                DrawText(\"SELECT A SIMULATION RUN TO REPLAY\", 400, 24, 16, DARKGRAY);\n\n                if (fileCount == 0) {\n                    DrawText(\"NO PROTOCOLS FOUND IN 'biotope_results/'\", 40, 100, 20, THEME_RED);\n                } else {\n                    // Draw List\n                    int startY = 100;\n                    int itemHeight = 30;\n                    int visibleItems = (screenHeight - 150) / itemHeight;\n                    \n                    // Simple scrolling view\n                    int scrollOffset = 0;\n                    if (selectedFileIndex >= visibleItems) scrollOffset = selectedFileIndex - visibleItems + 1;\n\n                    for (int i = 0; i < visibleItems && (i + scrollOffset) < fileCount; i++) {\n                        int idx = i + scrollOffset;\n                        Color col = (idx == selectedFileIndex) ? THEME_BLUE : THEME_TEXT;\n                        if (idx == selectedFileIndex) {\n                            DrawRectangle(30, startY + i * itemHeight - 5, 400, itemHeight, THEME_HIGHLIGHT);\n                            DrawText(\">\", 15, startY + i * itemHeight, 20, THEME_BLUE);\n                        }\n                        DrawText(fileList[idx].filename, 40, startY + i * itemHeight, 20, col);\n                    }\n\n                    // Draw Preview Panel\n                    int previewX = 460;\n                    DrawLine(previewX - 20, 100, previewX - 20, screenHeight - 60, Fade(THEME_TEXT, 0.3f));\n                    \n                    DrawText(\"PROTOCOL PREVIEW\", previewX, 100, 20, THEME_HIGHLIGHT);\n                    \n                    ProtocolInfo *sel = &fileList[selectedFileIndex];\n                    char infoBuf[128];\n                    \n                    if (sel->timestamp > 0) {\n                        struct tm *t = localtime(&sel->timestamp);\n                        strftime(infoBuf, sizeof(infoBuf), \"DATE: %d.%m.%Y %H:%M:%S\", t);\n                        DrawText(infoBuf, previewX, 140, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"DATE: LEGACY FORMAT\", previewX, 140, 20, DARKGRAY);\n                    }\n                    \n                    sprintf(infoBuf, \"GRID: %d x %d\", sel->rows, sel->cols);\n                    DrawText(infoBuf, previewX, 170, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX ROUNDS: %d\", sel->max_rounds);\n                    DrawText(infoBuf, previewX, 200, 20, THEME_TEXT);\n                    \n                    sprintf(infoBuf, \"MAX POPULATION: %d\", sel->max_population);\n                    DrawText(infoBuf, previewX, 230, 20, THEME_TEXT);\n                    \n                    if (sel->has_results) {\n                        DrawLine(previewX - 10, 260, previewX + 250, 260, Fade(THEME_TEXT, 0.3f));\n                        DrawText(\"RESULTS:\", previewX, 270, 20, THEME_HIGHLIGHT);\n                        \n                        if (sel->winner == 1) DrawText(\"WINNER: RED\", previewX, 300, 20, THEME_RED);\n                        else if (sel->winner == 2) DrawText(\"WINNER: BLUE\", previewX, 300, 20, THEME_BLUE);\n                        else DrawText(\"WINNER: DRAW\", previewX, 300, 20, DARKGRAY);\n                        \n                        char scoreBuf[64];\n                        sprintf(scoreBuf, \"R:%d  B:%d\", sel->final_red, sel->final_blue);\n                        DrawText(scoreBuf, previewX, 330, 20, THEME_TEXT);\n                    } else {\n                        DrawText(\"NO RESULTS YET\", previewX, 270, 18, DARKGRAY);\n                    }\n\n                    DrawText(\"PRESS [ENTER] TO LOAD\", previewX, 380, 20, GREEN);\n                }\n\n                DrawText(\"[UP/DOWN] NAVIGATE  |  [ENTER] LOAD  |  [Q/ESC] CANCEL\", 20, screenHeight - 28, 20, THEME_TEXT);\n                break;\n\n            case STATE_RUNNING:\n                DrawText(\"SIMULATION ACTIVE\", 20, 18, 24, THEME_RED);\n                \n                // KI-Agent unterstützt: Stable positioning for Label and Counter\n                const char* labelText = \"ECO-BLOOM CYCLE:\";\n                char roundBuf[32];\n                sprintf(roundBuf, \"%04d / %04d\", config.current_round, config.max_rounds);\n                \n                // Calculate widths based on a \"worst-case\" wide string to prevent jitter\n                int maxCounterWidth = MeasureText(\"0000 / 0000\", 20); \n                int labelWidth = MeasureText(labelText, 20);\n                int gap = 10;\n                int rightMargin = 20;\n                \n                // Draw Label (Fixed position relative to right edge)\n                DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, 20, 20, THEME_TEXT);\n                \n                // Draw Counter (Fixed start position)\n                DrawText(roundBuf, screenWidth - rightMargin - maxCounterWidth, 20, 20, THEME_TEXT);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false); // false = No Grid Lines (Performance!)\n                \n                DrawText(\"[Q] ABORT SIMULATION\", 20, screenHeight - 30, 20, DARKGRAY);\n                break;\n                \n            case STATE_FINISHED:\n                DrawText(\"SIMULATION COMPLETED\", 20, 18, 24, THEME_BLUE);\n                \n                DrawGridAndCells(&config, screenWidth, screenHeight, false);\n                \n                DrawText(\"[ENTER] VIEW RESULTS  |  [Q] MENU\", 20, screenHeight - 30, 20, THEME_HIGHLIGHT);\n                break;\n\n            case STATE_GAME_OVER:\n                DrawText(\"MISSION REPORT\", screenWidth/2 - 100, 100, 30, THEME_TEXT);\n                \n                char resultBuf[128];\n                Color winnerColor = THEME_TEXT;\n                if (config.current_red_pop > config.current_blue_pop) {\n                    sprintf(resultBuf, \"WINNER: RED TEAM\");\n                    winnerColor = THEME_RED;\n                } else if (config.current_blue_pop > config.current_red_pop) {\n                    sprintf(resultBuf, \"WINNER: BLUE TEAM\");\n                    winnerColor = THEME_BLUE;\n                } else {\n                    sprintf(resultBuf, \"RESULT: DRAW\");\n                }\n                \n                DrawText(resultBuf, screenWidth/2 - MeasureText(resultBuf, 40)/2, 200, 40, winnerColor);\n                \n                sprintf(buf, \"RED: %d  vs  BLUE: %d\", config.current_red_pop, config.current_blue_pop);\n                DrawText(buf, screenWidth/2 - MeasureText(buf, 20)/2, 260, 20, GRAY);\n                \n                DrawText(\"Stats exported to file.\", screenWidth/2 - MeasureText(\"Stats exported to file.\", 20)/2, 400, 20, DARKGRAY);\n                DrawText(\"PRESS [1] TO RESTART SYSTEM\", screenWidth/2 - MeasureText(\"PRESS [1] TO RESTART SYSTEM\", 20)/2, 500, 20, THEME_HIGHLIGHT);\n                break;\n        }\n\n        EndDrawing();\n    }\n\n    if (gui_world) free_world(gui_world);\n    CloseWindow();\n}"
      },
      {
        "text": "\n--- End of content ---"
      }
    ]
  },
  {
    "role": "model",
    "parts": [
      {
        "thoughtSignature": "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",
        "text": "Selbstverständlich! Hier ist die detaillierte Erklärung für den `STATE_RUNNING`-Block, mit einem besonderen Fokus auf deine Frage, wie die `gui_world` auf den Bildschirm kommt.\n\n### Allgemeine Erklärung: `case STATE_RUNNING`\n\nDieser Code-Block wird in jedem Frame ausgeführt, solange sich das Programm im Zustand `STATE_RUNNING` befindet – also, während die Simulation aktiv läuft.\n\nSeine Aufgaben sind:\n\n1.  **Titel anzeigen:** Mit `DrawText(\"SIMULATION ACTIVE\", ...)` wird der Text oben links gezeichnet, um dem Benutzer zu zeigen, was gerade passiert.\n2.  **Rundenzähler anzeigen:** Es wird ein Text wie \"ECO-BLOOM CYCLE: 0015 / 1000\" oben rechts angezeigt.\n3.  **Das Spielfeld zeichnen:** Die Funktion `DrawGridAndCells(...)` wird aufgerufen. **Dies ist der entscheidende Teil für deine Frage.**\n4.  **Hinweis anzeigen:** Unten wird ein Hinweis gezeichnet, wie man die Simulation abbrechen kann (`[Q] ABORT SIMULATION`).\n\n### Das Problem des \"flackernden\" Zählers und seine Lösung\n\nBevor wir zum Spielfeld kommen, ein cleveres Detail bei der Anzeige des Rundenzählers:\n\n*   **Das Problem:** Stell dir vor, der Zähler springt von Runde 9 zu Runde 10. Der Text \"0009 / 1000\" ist schmaler als \"0010 / 1000\". Wenn man den Text einfach rechtsbündig an den Bildschirmrand setzt, würde die Startposition des Textes bei jedem Sprung (z.B. von 9 auf 10, von 99 auf 100) leicht nach links \"springen\". Das nennt man \"Jitter\" und es sieht unprofessionell aus.\n*   **Die Lösung:**\n    1.  `int maxCounterWidth = MeasureText(\"0000 / 0000\", 20);`\n        Diese Zeile misst die Pixel-Breite des *breitestmöglichen* Textes, den der Zähler jemals anzeigen kann (hier wurde \"0000 / 0000\" als Referenz für einen 4-stelligen Zähler genommen). Das Ergebnis ist eine feste Pixelzahl, z.B. 120 Pixel.\n    2.  `DrawText(labelText, screenWidth - rightMargin - maxCounterWidth - gap - labelWidth, ...)`\n        Die Position des Labels (\"ECO-BLOOM CYCLE:\") und des Zählers wird nun basierend auf dieser *fixen maximalen Breite* berechnet.\n    3.  **Ergebnis:** Egal ob \"9\" oder \"1000\" angezeigt wird, der für den Zähler reservierte Platz ist immer gleich breit. Dadurch bleiben das Label und der Zähler absolut stabil an ihrer Position, ohne zu flackern.\n\n---\n\n### Detailliert: Wie `gui_world` auf den Bildschirm kommt (via `DrawGridAndCells`)\n\nDas ist der Kern deiner Frage und eine sehr clevere Optimierung. Ein naiver Ansatz wäre, für jede lebende Zelle ein `DrawRectangle()` aufzurufen. Bei einem großen Gitter (z.B. 1000x500 Zellen) wären das bis zu 500.000 einzelne Zeichenbefehle pro Frame – extrem langsam!\n\nStattdessen wird hier eine professionelle Technik namens **Texture-Based Rendering** verwendet. Der Prozess lässt sich in 3 Schritte unterteilen:\n\n#### Schritt 1: Das Bild im CPU-Speicher \"malen\"\n\n*   In `DrawGridAndCells` gibt es eine `static Color *pixels;` Variable. Das ist ein riesiges Array von `Color`-Werten im Hauptspeicher (CPU-Speicher). Die Größe des Arrays ist `rows * cols`, also genau ein Farb-Pixel für jede Zelle im Spielfeld.\n*   Eine `for`-Schleife geht nun durch **jede einzelne Zelle** des `gui_world->grid`.\n*   Für jede Zelle wird geprüft: Ist sie `TEAM_BLUE`, `TEAM_RED` oder `DEAD`?\n*   Basierend auf dem Zustand wird die entsprechende Farbe (`THEME_BLUE`, `THEME_RED` oder `BLANK` für transparente, tote Zellen) an die passende Stelle im `pixels`-Array geschrieben.\n*   **Wichtig:** Bis hierhin wurde noch *nichts* auf dem Bildschirm gezeichnet! Es wurde nur ein Bild in Form eines Farb-Arrays im CPU-Speicher vorbereitet.\n\n#### Schritt 2: Das Bild zur Grafikkarte hochladen\n\n*   In der Funktion gibt es auch eine `static Texture2D gridTex;`. Eine `Texture2D` ist ein spezielles Bildobjekt, das im extrem schnellen Speicher der Grafikkarte (GPU) lebt.\n*   Jetzt kommt der Befehl `UpdateTexture(gridTex, pixels);`.\n*   Dieser Befehl nimmt das gesamte, im CPU-Speicher vorbereitete `pixels`-Array und kopiert es in **einer einzigen, schnellen Operation** auf die Grafikkarte, wo es in der `gridTex`-Textur gespeichert wird.\n\n#### Schritt 3: Die Textur auf den Bildschirm zeichnen\n\n*   Zuletzt wird `DrawTexturePro(gridTex, source, dest, ...)` aufgerufen.\n*   Dies ist der **einzige Zeichenbefehl** für das gesamte Spielfeld. Er sagt der Grafikkarte: \"Nimm die Textur `gridTex`, die du jetzt in deinem Speicher hast, und zeichne sie auf den Bildschirm. Strecke oder stauche sie so, dass sie genau in den Zielbereich `dest` passt.\"\n*   Die Grafikkarte ist auf genau diese Aufgabe (Texturen zeichnen) spezialisiert und erledigt das blitzschnell.\n\n### Zusammenfassung des Tricks\n\nStatt der Grafikkarte tausende von kleinen Befehlen (\"zeichne hier ein kleines Rechteck\", \"zeichne dort ein kleines Rechteck\") zu schicken, was sehr langsam ist, wird hier so gearbeitet:\n\n1.  **CPU:** Bereitet das gesamte Bild des Spielfelds in einem Rutsch in einem einfachen Array vor.\n2.  **CPU -> GPU:** Schickt das fertige Bild in einem großen Datenpaket an die Grafikkarte (`UpdateTexture`).\n3.  **GPU:** Zeichnet dieses eine große Bild auf den Bildschirm (`DrawTexturePro`).\n\nDieser \"Bulk-Transfer\" ist um Größenordnungen performanter und der Grund, warum die Simulation auch bei großen Spielfeldern flüssig läuft. Der Parameter `false` in `DrawGridAndCells(..., false)` sorgt zusätzlich dafür, dass während der laufenden Simulation die Gitterlinien nicht gezeichnet werden, was noch ein kleines bisschen mehr Leistung spart."
      }
    ]
  }
]